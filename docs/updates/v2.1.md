# v2.1
v2.1 pulls some fixes, changes, and features from ahead in the repo's history, and even from 
Jamesking's work on the upcoming v2.5, with extra help from James in devising and revising 
the new systems in play that weren't in v2.5 yet.

This is a mostly non-breaking update. Very, very few mods should be broken, but some
behavior has been affected, and new behavior is now possible that you may want to implement. 
Read the changelog, then see [Recommended Mod Upgrades](#recommended-mod-upgrades).

There is one breaking change, which affects a feature used by extremely few mods. See 
[breaking changes](#breaking-changes).

If any mods have broken, ping me (Alrysc) on Discord and I'll see about patching. 

## Changelog
* Folder and pack can be sorted using the Pause button (default Enter) 
* Folders can be copied with CTRL+C while editing
* Sea, Metal, and Sand TileStates added
    * Sea boosts damage of Aqua cards used on them, doubles Elec damage taken while on one, and roots Entities that step on them
    * Metal cannot be cracked or broken
    * Sand roots Entities that step on them and doubles Wind damage taken while on one
* Charge times are recalculated even without flinching
    * Player.charge_time_func and PlayerForm.charge_time_func can be used reliably as a result
* Changed parameters and names of charge time functions, see [Charge Time](#charge-time)
* Wood element Entities will heal over time while standing on a Grass Tile
* Fire element Entities will not take damage from Lava
* Elec damage is no longer doubled on Ice
* Grass Tiles are now removed by Fire, even if damage was not dealt to any Entities
* Holy Panel damage rounds up
* Movement no longer acts as if endlag is 1 frame when it's 0 frames
* Drag lasts the correct amount of time now
* Pressing inputs during Stun and Freeze will cause them to end more quickly
* Status interactions with each other are overall more accurate
    * Some may cancel others, and will do so correctly
* Form changing will cancel various statuses
* Flinching can no longer be cancelled by using a card
* TFC cannot be performed until 10 frames into time freeze
* Charge is no longer used up when performing TFC
* Anger/FullSync now only consumed by boostable cards
* Time freeze actions show damage and modifiers
* Health turns red at low HP
* Mugshots no longer bounce
* Freedom battles always send data to the server, and turns can no longer end while the last enemy is dying
* Freedom battles read input during time freeze
* Card long descriptions are prioritized over short descriptions in battle
* Time Freeze actions can be marked uncounterable
* Time Freeze actions now call action_end_func
* Field.find_nearest_characters returns an ordered table
* Battle.AlertSymbol.new is available
* Access to Left_Shoulder and Right_Shoulder inputs
* Hit.NoCounter hitflag, prevents attack from countering
* Hit.Confuse hitflag, adds Confuse for 110 frames
* All Entities can use battle_start_func and battle_end_func
* Access to Character.can_attack
* Access to Entity.set_counter_frame_range
* Access to Entity. is_stunned, is_frozen, is_rooted, is_blind, is_confused, and is_dragged
* Access to Player.is_charging
* Default turn duration is now correctly 512 frames (~8.5 seconds, down from 10 seconds)
* Access to `Battle.get_turn_count`, which returns the current turn number. 0.0 initially, then increases by 1.0 every Battle Start banner
* Access to many functions related to Custom Gauge
    * `Battle.get_cust_gauge_value`, which returns a double with value `0.0` at empty gauge and `1.0` or higher at full, as a percentage completion of the gauge
    * `Battle.get_cust_gauge_time`, which returns a number in frames for the current gauge time (e.g. 256.0 when gauge is half full with default duration)
    * `Battle.get_cust_gauge_max_time`, which returns a number in frames for the current max gauge time (e.g. 512.0 for default time)
    * `Battle.get_default_cust_gauge_max_time`, which returns the default gauge time, 512.0 frames
    * `Battle.set_cust_gauge_time`, takes in a frametime (like frames(256)) to set current gauge time to
    * `Battle.set_cust_gauge_max_time`, takes in frametime to set max time to (current time is automatically readjusted to match the percentage of total time it had before, e.g. max time 512 and current time 256 will have current time 100 if you set max time to 200)
    * `Battle.reset_cust_gauge_to_default`, sets max time to default time
* Form changing resets emotions
* New HitProps constructor and builder pattern
* HitProps builder pattern allows custom durations for Stun, Freeze, Blind, Root, Confuse, and Flash
* HitProps can have a second element, `element2`
* Mob can skip rewards screen with `Mob:no_rewards()`
* Obstacles are now deleted immediately when their health reaches 0, even during time freeze
* Entity can register new Battle.UIComponent, which acts as a SpriteNode
    * Add child nodes to draw to the screen in battle, anchored at 0,0 screen coordinates
    * Position is absolute and does not get flipped by perspective flip
* `Esc` behavior is now the Panic sequence, which is activated by pressing `Esc` three times
    * This means exiting battle is now three `Esc` presses instead of one
* Panic can be used to disconnect from a server
* The engine can now play SFX when dealing damage
    * `Entity:use_default_hurt_sfx(bool)`, determines whether or not to use the default hurt SFX, true by default
    * `Entity:set_hurt_sfx(audio)`, changes the Entity's hurt sound. Default is based on Entity type, must call `Entity:use_default_hurt_sfx(true)` for it to play
        * `nil` is a valid value, to use no sound
* `DefenseFrameStateJudge` now determines whether or not a sound will play, and what sound to play, when damage is dealt
    * `DefenseFrameStateJudge:set_hit_sfx(audio)` changes the final SFX to play. Adopts the victim Entity's hurt sfx if one is provided.
        * `nil` is a valid value, to use no sound
    * `DefenseFrameStateJudge:hint_spawn_gfx(bool)` adds a hint to the DefenseFrameStatJudge whether or not to spawn a hit graphic effect.
        * Because it's a hint, it may or may not be respected
    * `DefenseFrameStateJudge:hint_spawn_gfx()` - used in hitbox attack + collision func to read if the Entity should obey the hint to spawn image graphics or not.
* Hitbox/Spell `attack_func` and `collision_func` now receive an optional last parameter DefenseFrameStateJudge object so you can read this hint and respond to it.
For most people, this means you don't have to provide hit sounds in most of your mods anymore, or handle playing them, unless you specifically want a custom hit sfx.

There are also new server-related features. 
* Battle rewards can be granted, with limited functionality around card rewards
* HUD can be swapped with the PET icon
* Can send email to clients
* Can play PET ring SFX
* New Sprite API lets servers draw sprites on the client's screen
* Can assert asset type when providing assets
* Card mod packages received by client are added to mod partition for the duration of the session
* Battle results no longer have `runaway` bool, now use `reason` enum

## Breaking Changes

There is one breaking change, which affects very few mods. The vast majority of mods 
will not be affected by any breaking changes.

### Charge Time

In v2.0, the `Player.charged_time_table_func` or `PlayerForm.calculate_charge_time_func` 
could be used to affect charge times. These two functions have been renamed, and their 
parameters were changed to now pass in the Player and the charge level, rather than just 
the level. You will need to make the following changes:

* Rename `charged_time_table_func` to `charge_time_func`, no `d`!
* Change the parameters to `(self, level)`, e.g. `player.charge_time_func = function(self, level)`
* Rename `calculate_charge_time_func` to `charge_time_func`, same as Player
* Change the parameters to `(player, level)`, e.g. `form.charge_time_func = function(player, level)`

Before:
```lua
local form = player:create_form()
player.charged_time_table_func = function(level)
    return frames(100 - 10 * level)
end

form.calculate_charge_time_func = function(level)
    return frames(80 - 5 * level)
end
```

After:
```lua
local form = player:create_form()
-- No more 'd' in name or 'table', extra parameter
player.charge_time_func = function(self, level)
    return frames(100 - 10 * level)
end

-- Name matches Player's function, extra parameter
form.charge_time_func = function(player, level)
    return frames(80 - 5 * level)
end
```

For other examples using these functions, see [Custom Charge Times](#custom-charge-times).

## Recommended Mod Upgrades
No mods should be broken by this update (except for mods that affected charge time), but 
modders now have an opportunity to add more to their mods. Some of these recommendations 
are to warn about behavioral changes, but mod updates are not necessarily required.

Other recommendations are for new things that can be added to mods to either make 
certain logic safer, or improve mods with new functionality.

### New Things You May Want To Add

#### Custom Charge Times
v2.1 fixes charge time calculation, which means Player mods are free to have unique 
charge times. If you do not add one, the mod will continue to use the default 
provided by the engine.

This is done using the `charge_time_func`, both on Players and on PlayerForms.
The `charge_time_func` is passed a reference to the Player, and a number `level` 
representing the current Charge level, and expects a `frametime` to be returned. 
The `level` will be a number from 1 to 5, inclusive. Be sure to cover all cases.

```lua
local form = player:create_form()
player.charge_time_func = function(self, level)
    if level == 1 then
        return frames(50)
    end

    if level == 2 then 
        return frames(40)
    end

    -- etc.
end

-- Note that the form receives the Player, not itself, in the parameters, 
-- so standard practice of using `self` as the first parameter is incorrect.
form.charge_time_func = function(player, level)
    if level == 1 then
        return frames(100)
    end

    if level == 2 then 
        return frames(90)
    end

    -- etc.
end
```

Some tips for determining charge times:

* The default charge time is 90 frames at level 1, 80 at level 2, 70 at level 3, 60 at level 4, and 50 and level 5.
* If your charge time can be based on a formula, use one
    * For exmaple, the ONB default can be replicated in one line with `return frames(100 - 10 * level)`
* The official games often do not use linear charge times. For example, HeatCross in BN6 has times 
 60, 50, 40, 35, 30, for levels 1-5. Notice how having more levels past 3 has lesser effect.
* The returned time is applied *after* holding the Shoot button for 10 frames (when the graphic appears)
    * This means returning `frames(10)` actually means you need to hold B for 20 frames total to be fully charged
    * Sources on charge times for the official games may or may not count the 10 frames before holding Shoot. 
    Take this into consideration when taking data from other sources. 

If your mod changes the `Player.charged_attack_func`, consider also changing the `Player.charge_time_func`.

#### Access to Shoulder Buttons
v2.1 adds the `right_shoulder` and `left_shoulder` inputs to be read by mods. You 
can perform some logic based on these, and you might have some mods that were getting 
especially crowded using only the Special button. 

Note that the shoulders are typically used to open the Custom screen. Your logic may 
be performed at the same time the Custom screen opens if the Custom Gauge is full.

#### Safer card_action_event
In v2.0, if you used `Character.card_action_event`, you had no way of knowing whether 
or not the Card would be added or would execute, or even could execute. You might 
have queued the action multiple times, causing it to happen more times than intended. 
With v2.1, this can be made somewhat safer because we can check whether or not the 
Character is available to perform an action using `Character.can_attack`.

`Character.can_attack` returns false if the Character already has a CardAction, or 
is flinching, stunned, frozen, or in the middle of Drag. By combining this with a 
check for `Entity.is_moving`, you can more consistently avoid queueing the action 
multiple times, since the frame after you queue the action `Character.can_attack` will 
return false until the action has either finished or been discarded.

```lua
player.update_func = function(self)
    local can_act = player:can_attack() and not player:is_moving()
    if can_act and player:input_has(Input.Pressed.Left_Shoulder) then 
        player:card_action_event(make_my_action(), ActionOrder.Voluntary)
    end 
end
```
If the above code did not make those checks, a player could repeatedly press the left shoulder
button and queue the action multiple times, or could even press it while stunned and have the 
action happen immediately when stun ends. Guarding the `card_action_event` with `can_attack` 
and `is_moving` prevents this.

#### Hit.NoCounter
You can now make attacks that can never counterhit. In v2.0, this was able to be done using 
the raw value of the enum (2048), but now the enum value is accessible using `Hit.NoCounter`. 
If you used `2048`, consider updating to use the enum value, which is guaranteed to always 
work in the future.

#### Check Confusion and Blind
In the original games, enemies would often act differently than normal if they were blind 
or confused. Modders can now check for these conditions with `Entity.is_confused` and 
`Entity.is_blind`.

According to K1rbyat1na, confused enemies in BN3/EXE3 acted the same as if they were rooted, 
so their movements will not happen. But in later games, confused enemies act the same as 
if they were blinded, which means, quoted:
"
1. They have a longer idle delay.
2. They can't choose the correct tile for an attack and choose it randomly (e.g., StarMan using Star Arrow).
3. They skip attacks that require moving to a specific tile (e.g., StarMan using Moon Dance).

Some bosses have unique features in the Blind state. For example, Blinded Forte always excludes tiles 
containing the player when using Shooting Buster so he never hits them.
"

You might consider following this for your mods to be closer to the source material.

#### `battle_end_func` and `battle_start_func`
All Entities can use the `battle_start_func` and `battle_end_func` now. This is most likely 
to come up where modders have wanted to remove Spells from the Field when battle ends, or 
prevent enemies from spawning new attacks, which is common for official game behavior. 

#### TimeFreeze action_end_func
In v2.0, time freeze CardActions did not call their `action_end_func`. This has been fixed. 
If your mods had certain cleanup that must be performed at the end, this could be a good 
place to move things.

#### TimeFreeze Uncounterable
Time freeze actions can now be marked as uncounterable, using `CardMeta.counterable = false`.

Try not to abuse it too much. This is typically used for time freezes that happen as a 
result of some condition, like Guardian being hit, or an elemental attack appearing 
on the field and triggering ElementTrap, or a boss changing phases. Mods that have these 
sorts of actions likely already wanted to be uncounterable, and now they can be.

#### set_counter_frame_range
Instead of toggling counter on and off, you can now set a range of animation keyframes
for which an Entity will be counterable. This is based on the current animation.

```lua
action.execute_func = function(self, actor)
    actor:set_counter_frame_range(1, 4)
end
```

The above code is equivalent to 
```lua
action.execute_func = function(self, actor)
    action:add_anim_action(1, function()
        actor:toggle_counter(true)
    end)

    action:add_anim_action(4, function()
        actor:toggle_counter(false)
    end)
end
```
Note that this is done specifically in the `execute_func`, which is the first time the 
user has entered the action animation.

#### Breaking Metal Tiles
The Metal TileState prevents cracking and breaking a Tile. This means calls like 
`tile:set_state(TileState.Cracked)` or `tile:set_state(TileState.Broken)` will do 
nothing if the current state is `TileState.Metal`. 

Some effects intend to *overwrite* Tiles, which is different flavor from *breaking* 
them. For example, in BN3, MetalMan, GutsMan, and BassGS don't affect Metal Tiles, 
but Geddon1 and Geddon2 do. Geddon1 cracks all Tiles, including Metal Tiles; Geddon2 
turns all Tiles into holes, but Metal Tiles are instead cracked. If you intend for 
this sort of behavior, you can change the Tile to `TileState.Normal` and then crack 
and break it, or only crack if it was Metal beforehand. 

#### Engine Alert Symbol
v2.1 adds access to `Battle.AlertSymbol.new()`, which creates an alert symbol, the 
double exclamation point icon that appears when taking weakness damage or performing 
TFC. If your mods have created one for themselves, you may consider using this instead. 

#### Turn Counting
In v2.0, some mods tried to create attacks or special effects that activated only 
once per turn. This can now be done much more easily and with fewer holes by the 
new `Battle.get_turn_count`.

`Battle.get_turn_count` returns the current turn of the battle. It will return `0.0`
before the first turn, then `1.0` more every time the "Battle Start!" banner appears 
after exiting card select.

```lua
player.last_known_turn = 0.0
player.allow_special_attack = true


-- Set allow_special_component true if it's a new turn
local special_component = Battle.Component.new(player, Lifetimes.Scene)
special_component.update_func = function()
    local turn = Battle.get_turn_count()
    if turn ~= player.last_known_turn then
        player.last_known_turn = turn
        player.allow_special_attack = true
    end
end
player:register_component(special_component)

-- Do nothing if allow_special_attack is false
-- Otherwise, return special attack and set 
-- allow_special_attack false
player.special_attack_func = function(self)
    if not self.allow_special_attack then 
        return 
    end

    local action = Battle.CardAction.new(self, "PLAYER_IDLE")

    action.excute_func = function()
        self.allow_special_attack = false
    end

    return action
end
```

#### New HitProps Constructor
HitProps can now be constructed and modified using a builder pattern.
This is best done using the new constructors, `HitProps.new()` or 
`HitProps.new(context)`.

Before:
```lua
local hit_props = HitProps.new(
    props.damage,
    Hit.Impact | Hit.Flinch | Hit.Stun,
    props.element,
    user:get_context(),
    Drag.None
)
```
Now:
```lua
local hit_props = HitProps.new()
    :dmg(props.damage)
    :impact()
    :flinch()
    :stun()
    :elem(props.element)
    :from(user:get_context())
```
You no longer need to remember the order of values to give to the constructor, 
and don't have to specify that you will have no Drag. If your attack did have 
Drag, you can decide to do
```lua
hit_props:drg(Drag.new(user:get_facing(), 1))
```

#### Use element2
With the [new HitProps builder pattern](#new-hitprops-constructor), you can now 
add secondary elements.

```lua
local hit_props = HitProps.new()
    :dmg(props.damage)
    :impact()
    :flinch()
    :stun()
    :elem(props.element)
    :elem2(Element.Sword)
    :from(user:get_context())
```
This can be read with `hit_props.elem2`.

Be sure to take `elem2` into account in your DefenseRules, which should react the same 
to primary and secondary element.

#### Use Status Durations
With the [new HitProps builder pattern](#new-hitprops-constructor), you can now 
add durations to certain statuses.

```lua
local hit_props = HitProps.new()
    :dmg(props.damage)
    :impact()
    :flinch()
    :stun(frames(90))
    :elem(props.element)
    :from(user:get_context())
```
Note that a status generally needs at least two frames of duration to take effect. 

The following statuses can be given durations in this way:

* stun (default 120 frames)
* freeze (default 150 frames)
* flash (default 120 frames)
* root (default 120 frames)
* blind (default 300 frames)
* confuse (default 110 frames)

### Behavior Changes (Be Aware)

#### Using Hit.Drag
v2.1 makes Drag interactions much closer to source material. This reveals some 
possible mistakes modders have made with Drag attacks. Below are some nuances that 
may have been unknown before, and that modders should reconsider for attacks that 
inflict Drag:
1. Drag makes the hit Entity totally unable to act for over 20 frames after movement stops
2. Drag and Freeze are fully incompatible. If any attacks have Hit.Freeze and Hit.Drag, they 
   will never cause Freeze. If you have done this, consider removing Hit.Freeze.

#### Drag Endlag
The Drag status now properly keeps Entities from acting for over 20 frames after movement 
stops. This is the Drag endlag, during which `Entity.is_moving` and `Entity.is_sliding` 
will return false, which was not the case in v2.0.

See [safer card_action_event](#safer-card_action_event).

#### Movement Endlag
In v2.0, all movement had at least one frame of endlag. Endlag of `frames(0)` and 
`frames(1)` were identical. With v2.1, this is no longer the case. 

This will affect any MoveEvent that was using `frames(0)` for its endlag, which 
is most sliding Spells. There is no actual fix necessary, because modders likely 
intended their 0 frame endlag to really be 0 frames, but modders should be aware 
that projectiles may appear to move slightly more quickly. 

The actual effect on speed has to do with how long it takes to reach mutiple Tiles 
away. Things that moved two Tiles will reach the second Tile 1 frame faster now that 
the endlag isn't there. Moving three Tiles will reach the third Tile 2 frames faster, 
etc.

If you intended to have an extra frame on each Tile, you can use `frames(1)` as the 
endlag to replicate how `frames(0)` looked and moved in v2.0.

#### Spawning Hit Effects
Some Spells will spawn hit effects in their `collision_func` or `attack_func`. Some 
mods spawn the effect on the Spell's Tile; others spawn on the hit Entity's Tile. 
Spawning on the Spell's Tile has always been less correct, because the Spell is moving 
and may have already reached the next Tile before the effect was spawned. This could 
mean the effect spawns behind the hit Entity, for example. 

Because of the [movement endlag change](#movement-endlag), this may be more noticeable
(but it could have happened in v2.0, too).
If a mod spawned the hit effect on the target's Tile, no change is necessary. If they 
spawned on the Spell's Tile, consider changing this.

#### Deleting Moving Attacks
Some Spells will delete themselves in their `collision_func`. If the Spell is moving, 
it may have changed Tiles before the `collision_func` ran. This means it could have 
been drawn on the next Tile even though it hit on the previous Tile, because Entities 
still draw on the frame `Entity:delete()` is called.

This draw error could happen in v2.0, but is likely more noticeable now because of the 
[movement endlag change](#movement-endlag).

If you call `erase` in your `delete_func`, or if you called `erase` intead of `delete`, 
or if you call `hide` when you called `delete`, or if you call `hide` in the `delete_func`, 
this will never happen to your Spells. If you do not do any of these, consider adding one.
My recommendation is to call `Entity.hide` in your `delete_func`.

#### find_nearest_characters Fix
In v2.0, `Field.find_nearest_characters` did not actually return an ordered list, so the 
first item was not necessarily the nearest Character. This is fixed by v2.1. 

If you have used `find_nearest_characters` and intended to target the nearest Character, 
no change is needed; you may notice that you are now actually getting the nearest Character.

If you have avoided `find_nearest_characters` to use your own solution, or because it did 
not work as expected, consider updating to now use it.

#### Fire and Grass
Fire element attacks now remove Grass even if they did not hit an Entity. Mods that 
handled this interaction on their own in v2.0 can now remove their implementation, as
the engine will handle it.

#### Grass, Lava Effects
Grass now heals Wood Entities. If your Player mods have implemented a sort of grass heal, 
you can now remove this and rely on the engine's. If you do not, your healing effect will
stack with the engine's.

Fire Entities are no longer harmed by Lava Tiles. If you have added FloatShoes to your 
Player mods only to recreate this interaction in v2.0, you can now remove the FloatShoes 
and remain immune to Lava.

#### New TileStates
Because of the new TileStates (Sea, Metal, Sand), mods that attempted to change Tiles 
on the Field to any TileState (e.g. a mod that picks random TileStates each time) 
may want to be updated to support the additions.

Servers that send data for encounters tend to use hardcoded values based on the TileState 
enum (ezencounters does this). Any use of `TileState.Hidden` on your server encounters 
may now appear as Sea Tiles. See the repo for new values to adjust to.
