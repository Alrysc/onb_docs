{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Open Net Battle","text":"<p>These docs contain information on creating mods for the Open Net Battle (ONB) engine,  an engine recreating the mechanics of MegaMan Battle Network 6 where all content  is user generated.</p> <p>The current version of Open Net Battle is v2.1.2. Many pages on this site were written  when v2.0a was the latest version, and need to be updated where needed to refer to v2.1.  Certain things may be different in the next large engine update, and I'll be updating  information here to reflect changes when they happen. </p>"},{"location":"#topics-covered","title":"Topics Covered","text":"<p>These docs are in the early stages. So far, you'll find:</p> <ol> <li>A summary of Lua features in the Lua Primer tab</li> <li>Small usage tips for Entity class objects and summaries of their notable functions</li> <li>Overviews of some of the C++ enums that have Lua bindings</li> <li>A changelog and suggestions for improving and fixing mods with respect to new features     in v2.1.</li> </ol> <p>I still plan to add at least:</p> <ol> <li>Pages on the rest of the engine C++ objects that have Lua bindings, similar to  the Entity pages</li> <li>Pages on the rest of the values of engine enums</li> <li>Overviews of the mod package types</li> <li>Sections that cover setting up a new mod of each type</li> <li>Sections dedicated to other tools that can help certain parts of modding and how to use them</li> <li>Sections covering common desired behavior, like making attacks that move</li> <li>Sections that warn of logical pitfalls that could cause code to act in unexpected,  less noticed ways</li> <li>Sections on specific engine details, like the order of logic in a frame</li> <li>Sections on details and behavior from the official games, to help make mods feel more authentic (things like the typical number of chip codes, or how much each charge  level tends to speed up charging)</li> </ol>"},{"location":"#other-help","title":"Other Help","text":"<p>You most likely got here through the official Discord server. If you didn't, I  recommend you join it. You'll be around for updates, other players, the latest  tools as the develop, and, most importantly, other modders like me who can help  you figure stuff out. </p>"},{"location":"changelog/","title":"Changelog","text":"<p>Here you'll find a record of changes made to these docs. I won't mention smaller changes  much, so expect to mostly see new pages and the dates they were added.</p> <p>This is also partially here so readers can see the date of the last update. When the  next engine update arrives, check here to see if I've updated the docs yet to reflect  new changes or new information.</p>"},{"location":"changelog/#december-16th-2025","title":"December 16th, 2025","text":"<ul> <li>Added new sections on v2.1, which has been at work for some months</li> </ul>"},{"location":"changelog/#july-2025","title":"July 2025","text":"<ul> <li>Added Hit enum page</li> <li>Added Lifetimes enum page</li> </ul>"},{"location":"changelog/#june-2025","title":"June 2025","text":"<ul> <li>First Launch</li> <li>Added Enums section and some pages<ul> <li>Element</li> <li>Direction</li> <li>Team</li> <li>Input</li> <li>Rank</li> <li>AudioPriority</li> <li>AudioType</li> <li>Highlight</li> <li>Shadow</li> <li>ColorMode</li> <li>Playback</li> <li>CardClass</li> <li>Blocks</li> <li>EntityStatus</li> <li>TileState enum</li> <li>DefenseOrder</li> <li>LockType </li> </ul> </li> </ul>"},{"location":"lua/","title":"Overview","text":"<p>All mods are written in the Lua programming language. The goal of this section is not to teach you Lua, especially as  your first programming language, but to highlight basic usage and differences from other languages, as well as important features. I will try to cover the bare minimum in order to understand the code examples and logic behind other guides in these  docs.</p> <p>Sometimes I can't help myself and might make a few suggestions on how to or how not to use things. If you're new to coding, I  (with some bias) recommend reading them. If you're already familiar with other languages, they probably won't add anything.</p> <p>I may also sometimes have short sections that relate to usage in ONB. I'll reiterate on these in other places in documentation  specifically for ONB, so don't worry about skipping.</p> <p>You can also follow along some of the sections here using some Lua interpreter. Some can be found online and used from your  browser, such as https://onecompiler.com/lua/.</p>"},{"location":"lua/#learning","title":"Learning","text":"<p>Programming in Lua (PiL) does a much better job going over language features than I  do. If you want to seriously learn the language, give it and the official Lua manual and documentation a read. If you want a second opinion, more examples, or similar information in different words, feel free to read from here  and those links.</p> <p>Don't let either those or these few pages be the end, either. There are plenty of Lua tutorials you can find even on  YouTube. Look for them.</p>"},{"location":"lua/#lua-features-we-dont-get","title":"Lua Features We Don't Get","text":"<p>While covered in the manual and other Lua learning resources, there are parts of the language we cannot use in ONB mods. Some are mentioned here, but this is not an exhaustive list:</p> <ol> <li>The String library<ul> <li>No checking for substrings, pattern matching, characters at a position, or indexing a String</li> </ul> </li> <li>Coroutines</li> <li>Checking the date or time<ul> <li>If you could, you would likely desync whenever you did, anyway</li> </ul> </li> <li>File system access</li> </ol>"},{"location":"lua/boolean_expressions/","title":"Boolean Expressions","text":"<p>Like a math expression, which uses numbers, a boolean expression uses  booleans. And, like a math expression, you can solve one down to a  single value (\"resolve\" it).</p> <pre><code>1. 2 + 4 + 8\n    - Add the 2 and 4\n2. 6 + 8\n    - Add the 6 and 8\n3. 14\n    - Final value\n</code></pre> <pre><code>1. false or false or true\n    - OR the `false` and `false`\n2. false or true\n    - OR the `false` and `true`\n3. true\n    - Final value\n</code></pre>"},{"location":"lua/boolean_expressions/#other-values","title":"Other Values","text":"<p>Booleans are not the only types that can be used in a boolean expression.</p> <p>A value of any type, except for if the value is <code>nil</code> or <code>false</code>, will  resolve to <code>true</code>. Both <code>nil</code> and <code>false</code> are treated as <code>false</code>.</p> <pre><code>-- true\nprint(1 and true)\n\n-- true\nprint(0 and true)\n\nlocal x = -1\n\n-- true\nprint(x and \"\")\n\n-- false\nprint(nil or false)\n</code></pre> <p>My code examples will often use this feature as a shorthand in conditions,  but remember to check if something is explicitly == false if your logic  should consider <code>nil</code> as a separate case.</p>"},{"location":"lua/boolean_expressions/#short-circuit","title":"Short Circuit","text":"<p>Boolean expressions can be short circuited. This is when the program skips part  of the evaluation because it knows the result of the expression is already determined. </p> <p>For example, </p> <p><pre><code>local x = true and false and true\n</code></pre> When executing this statement, the logic is more like</p> <pre><code>1. true and false and true\n    - AND `true and `false`\n2. false and --\n    - It doesn't matter what is on the other side of the `and`.\n    `false` ANDed with anything is `false`, so it doesn't check.\n3. false\n    - Final result\n</code></pre> <p>This is more obvious in more complex expressions.</p> <pre><code>--[[\n    Return true if a and b are both greater than 0 \n    and a is greater than b.\n]]\nfunction greater_above_zero(a, b)\n    print(\"Check zero.\")\n    if a &lt; 0 or b &lt; 0 then \n        return false\n    end\n\n    return a &gt; b\nend\n\nlocal check = greater_above_zero(1, 2) and greater_above_zero(2, 1)\n\nprint(check)\n</code></pre> <p>In the above code, when <code>greater_above_zero</code> is called, we expect a <code>print</code> call  as well. <code>greater_above_zero</code> is called twice, so you might expect it to appear  twice. However, if you run this, you will see</p> <pre><code>Check zero.\nfalse\n</code></pre> <p>It only appeared once. Here's how the resolution looked:</p> <pre><code>1. greater_above_zero(1, 2) and greater_above_zero(2, 1)\n    - Call greater_above_zero with 1 and 2, run that function.\n    It printed and returned false.\n\n2. false and --\n    - The other side of the `and` is ignored because anything\n    ANDed with `false` is `false`.\n</code></pre>"},{"location":"lua/boolean_expressions/#avoid-expensive-calls","title":"Avoid Expensive Calls","text":"<p>An important aspect of short circuiting is that it can avoid more expensive, or additional,  calls when they aren't necessary. Take the following code:</p> <pre><code>--[[\n    Compare all elements in t1 to all elements in t2. \n\n    Returns true if they each contain exactly the same elements \n    as the other.\n]]\nfunction deep_compare_table(t1, t2)\n    -- Implementation omitted for example\nend\n\n\nif player:get_element() == Element.None \n    and player:get_health() &gt; 1000\n    and deep_compare_table(player.t1, player.t2)\nthen\n    print(\"All satisfied\")\nend\n</code></pre> <p>We only want that statement to <code>print</code> if the player's element is None, they have more than  1000 health, and two tables contain the same elements. The latter operation is obviously  much more expensive and can take many more computations than the former two. </p> <p>Because of short circuiting, that comparison is never even attempted if the element is not  None, or if their health is not above 1000.</p> <p>The code above can similarly be written as</p> <p><pre><code>function deep_compare_table(t1, t2)\n    -- Implementation omitted for example\nend\n\n\nif player:get_element() == Element.None then\n    if player:get_health() &gt; 1000 then \n        if deep_compare_table(player.t1, player.t2) then\n            print(\"All satisfied\")\n        end\n    end\nend\n</code></pre> You can see why you might prefer to short circuit in one boolean expression instead.</p>"},{"location":"lua/boolean_expressions/#avoid-erroneous-calls","title":"Avoid Erroneous Calls","text":"<p>Short circuiting can also be a useful technique for writing code that avoids making calls  that would otherwise result in an error. In the ONB sections of these docs, you will see  me use it often when checking Tiles.</p> <p><pre><code>--[[\n    Return true if a &lt; b. \n\n    a and b both must be numbers.\n]]\nfunction check_lesser(a, b)\n    return a &lt; b\nend\n\n--[[[\n    Roll a random number between 1 and 2.\n\n    If the number is 1, returns nil.\n    If the number is 2, returns 2.\n]]\nfunction get_number()\n    local r = math.random(1, 2)\n\n    if r == 1 then \n        return nil\n    end\n\n    return r\nend\n\nlocal maybe_r = get_number()\n\nlocal lesser = maybe_r and check_lesser(maybe_r, 4)\n\nprint(lesser)\n</code></pre> In the above code, the result returned from <code>get_number</code> may be <code>nil</code>. It would be an error to call  <code>check_greater</code> with <code>nil</code>, because you cannot compare a number to <code>nil</code>. </p> <p>In order to avoid this, I check first check if <code>maybe_r</code> is <code>nil</code>, and AND that with the result  of <code>check_greater</code>. Recall that <code>nil</code> evaluates to <code>false</code>, and any other value that isn't <code>false</code>  evaluates to <code>true</code>. Then, the resolution of this expression might look like:</p> <pre><code>1. maybe_r and check_greater(maybe_r, 4)\n    - Substitute in the variable value\n2. 2 and check_greater(2, 4)\n    - Check boolean value of `2`\n3. true and check_greater(2, 4)\n    - Resolve the check_greater call\n4. true and true\n5. true\n</code></pre> <p>Or</p> <pre><code>1. maybe_r and check_greater(maybe_r, 4)\n    - Substitute in the variable value\n2. nil and check_greater(nil, 4)\n    - Check boolean value of `nil`\n3. false and --\n    - `false` ANDed with any other value is `false`, so \n    there is no need to check the other side.\n4. false\n</code></pre> <p>The order here matters. If the code was instead </p> <pre><code>local lesser = check_lesser(maybe_r, 4) and maybe_r\n</code></pre> <p><code>check_lesser</code> would have been called with <code>nil</code>, and an error would occur.</p>"},{"location":"lua/comments/","title":"Comments","text":"<p>You can, should, and will add comments to your code. </p> <p>A comment is some text you can have in your code that will not be read by the program.  That means you can leave notes for yourself or others who read your code, describe how  certain functions behave and how they expect to receive data, and so on. </p> <p>You can also \"comment out\" some code to leave it in your file, but prevent it from  being executed. This can be safer for you than deleting lines when testing.</p> <p>You will usually want to write your comment above the code it relates to. While you  can write it on the same line, your text will go off the screen faster that way,  and it could be harder to convert your comment to a multiline comment later or remove it.</p>"},{"location":"lua/comments/#single-line","title":"Single Line","text":"<p>Comments in Lua start with two hyphens <code>--</code>. Every character after that in the line  will not be read by the program.</p> <pre><code>-- x offset for the player\nlocal x = 0\n-- y offset for the player\nlocal y = 0\n\nlocal num = 20 -- 50\n\n-- Crashes if this is negative\nlocal countdown = 10\n</code></pre>"},{"location":"lua/comments/#multiple-lines","title":"Multiple Lines","text":"<p>You can comment multiple lines at once by surrounding a region of code with <code>--[[ ]]</code>.</p> <pre><code>--[[\n    Multiplies `x` and `y` and returns the result.\n\n    `x` and `y` both must be numbers.\n]]\nlocal function multiply(x, y)\n    return x * y\nend\n\n--[[\n\nThis is a different implementation of the multiply function\nthat would multiply all values in a table. \n\nI didn't finish it, but it might be useful someday. Come back \nto finish it later.\n\nlocal function multiply(number_table)\n\nend\n\n]]\n</code></pre>"},{"location":"lua/comments/#when-to-comment","title":"When To Comment","text":"<p>Different people might teach you to use comments more or less frequently, or for more  or less specific code. For example, I would tell you not to do something like:</p> <pre><code>-- This is the player's offset\nlocal player_offset = player:get_offset()\n-- This is the x offset of the player\nlocal x_off = player_offset.x\n-- This is the y offset of the player\nlocal y_off = player_offset.y\n</code></pre> <p>Very wordy, and the variable names already state what they are. A comment may not  add much insight. </p> <p>You might want to ask yourself a few questions, like</p> <ol> <li>Is the code simple enough that you can tell what it does by looking at it?</li> <li>Is there any special behavior or requirement to the code that isn't obvious?</li> <li>Will I forget what this does when I come back to fix a bug in a month?</li> </ol> <p>For your ONB mods, I would encourage leaving comments where appropriate. You might  just need to fix a bug and you've forgetten what the behavior should be. A new  modder might look to your mod for inspiration and try to read its code. You might  want to come back and update it with a new engine feature that makes the logic  much cleaner. Help yourself and everyone else.</p>"},{"location":"lua/comparisons/","title":"Comparisons","text":"<p>You can compare two values with comparison operators.</p> <ol> <li>&lt;    (less than)</li> <li>&lt;=   (less than or equal to)</li> <li>&gt;    (greater than)</li> <li>&gt;=   (greater than or equal to)</li> <li>==   (equal to)</li> <li>~=   (not equal to)</li> </ol> <p>Note that <code>~</code> is used for \"not equal to\" instead of <code>!</code> like other languages.</p> <p>The result of these operators will be a <code>boolean</code>.</p> <pre><code>-- false, because true is not false\nprint(true == false)\n\n-- true\nprint(\"Hello\" == \"Hello\")\n\n-- true\nprint(10 &gt; 2)\n\nlocal x = 10\nlocal y = 8\n\n-- true\nprint(x ~= y)\n\ny = y + 2\n\n-- false\nprint(x ~= y)\n</code></pre>"},{"location":"lua/control_structures/","title":"Control Structures","text":"<p>These are covered more succinctly in Programming in Lua. If you read only one source, choose that one over this.</p> <p>Each control structure involves some keywords, a boolean expression,  and usually an <code>end</code>. They create a new scope, or block, as their body.</p> <p>There are no switch statements.</p>"},{"location":"lua/control_structures/#if","title":"if","text":"<p>A <code>if</code> statement is made by the <code>if</code> keyword, a boolean expression, the <code>end</code> keyword,  the body logic, and is closed by the <code>end</code> keyword.</p> <pre><code>if true then \n    -- Body logic\nend\n</code></pre> <p>The code within the body will only run if the boolean expression resolves to <code>true</code>.</p> <p><pre><code>if 5 &lt; 2 then \n    print(\"Run 1\")\nend\n\nif 5 &gt; 2 then \n    print(\"Run 2\")\nend\n</code></pre> In the above code, the only output will be <code>Run 2</code>.</p> <p>Notice that there are no <code>{}</code> like other languages, and parentheses around the  boolean expression are not required.</p>"},{"location":"lua/control_structures/#else","title":"else","text":"<p>You can have a second body that will run only if the boolean expression resolves  to false. Use the keyword <code>else</code> in place of <code>end</code>, and move the <code>end</code> to the end  of the <code>else</code> body.</p> <p><pre><code>if 5 &lt; 2 then \n    print(\"Run 1\")\nelse\n    print(\"No Run 1\")\nend\n\nif 5 &gt; 2 then \n    print(\"Run 2\")\nelse\n    print(\"No Run 2\")\nend\n</code></pre> In the above code, the output will be:</p> <pre><code>No Run 1\nRun 2\n</code></pre>"},{"location":"lua/control_structures/#elseif","title":"elseif","text":"<p>You can have any number of extra blocks following an <code>if</code> that will only  run if the previous condition was <code>false</code> and a new condition is met.</p> <p>This can be done similar to <code>else</code>, but requires a <code>then</code> after.</p> <pre><code>if 5 &lt; 2 then \n    print(\"Run 1\")\nelseif 5 &gt; 2 then\n    print(\"Run 1 else\")\nelse\n    print(\"Default\")\nend\n\nif 5 &gt; 2 then \n    print(\"Run 2\")\nelseif 5 ~= 5 then \n    print(\"Run 2 else 1\")\nelseif 5 == 5 then\n    print(\"Run 2 else 2\")\nend\n</code></pre> <pre><code>Run 1 else\nRun 2\n</code></pre>"},{"location":"lua/control_structures/#while","title":"while","text":"<p>A <code>while</code> loop can be created by using the keyword <code>while</code>, a boolean expression,  the keyword <code>do</code>, and finally closing the body with <code>end</code>.</p> <p>Until the expression resolves to <code>false</code>, the body will run over and over. If  the expression resolves to <code>false</code> before running even once, the body will not  run.</p> <pre><code>local counter = 3\nwhile counter &gt; 0 do\n    print(counter)\n    counter = counter - 1\nend\n\nlocal x = 1\nwhile x ~= 1 do\n    print(\"Not 1\")\nend\n</code></pre> <p>The output of the above code will be</p> <pre><code>3\n2\n1\n</code></pre> <p>You can also use the keyword <code>break</code> to exit the loop early. If <code>break</code> is used,  the next line must be <code>end</code>.</p> <pre><code>local counter = 3\nwhile counter &gt; 0 do\n    print(counter)\n    if counter == 2 then \n        break\n    end\n\n    counter = counter - 1\nend\n</code></pre> <p>The output of the above code will be</p> <pre><code>3\n2\n</code></pre>"},{"location":"lua/control_structures/#repeat-until","title":"repeat-until","text":"<p>You can <code>repeat</code> some body <code>until</code> a condition is met. Use the keyword <code>repeat</code>,  followed by the body. Then close the body with the <code>until</code> keyword, followed by a  boolean expression. </p> <p>Note that there is no <code>do</code> or <code>end</code>, like other loops.</p> <p>Unlike <code>while</code>, <code>repeat-until</code> will always run the body at least once. The boolean expression  is checked after the body runs instead of before.</p> <pre><code>local counter = 3\nrepeat\n    print(counter)\n    counter = counter - 1\nuntil counter == 0\n\nlocal x = 1\nrepeat\n    print(\"Not 1\")\nuntil x == 1\n</code></pre> <p>The above code will have the following outupt:</p> <pre><code>3\n2\n1\nNot 1\n</code></pre> <p><code>break</code> can be used in the body in the same way as a <code>while</code> loop.</p> <pre><code>local counter = 3\nrepeat\n    print(counter)\n\n    if counter == 2 then \n        break\n    end\n\n    counter = counter - 1\nuntil counter == 0\n\nlocal x = 1\nrepeat\n    print(\"Not 1\")\nuntil x == 1\n</code></pre> <pre><code>3\n2\nNot 1\n</code></pre>"},{"location":"lua/control_structures/#for","title":"for","text":"<p>A <code>for</code> loop is used to loop over a block of code a specified number of times. You can create  a <code>for</code> loop by using the keyword <code>for</code>, defining a variable name and default value as the  iterator, a number where the iterator will stop at, optionally a number to increment by  after each iteration (the \"step\"), the keyword <code>do</code>, the body, and finally an <code>end</code>.</p> <p>Conventionally, the iterator will be named <code>i</code>. If you have multiple <code>for</code> loops nested, you  might move onto <code>j</code>, <code>k</code>, and other letters.</p> <p>This one will be easier to understand visually than through that text.</p> <pre><code>for i=1, 3, 1 do\n    print(\"Loop 1: \"..i)\nend\n\nprint(\"\")\n\nfor i=1, 3 do\n    print(\"Loop 2: \"..i)\nend\n\nprint(\"\")\n\nfor i=4, 0, -2 do\n    print(\"Loop 3: \"..i)\nend\n\nprint(i)\n</code></pre> <p>This outputs</p> <pre><code>Loop 1: 1\nLoop 1: 2\nLoop 1: 3\n\nLoop 2: 1\nLoop 2: 2\nLoop 2: 3\n\nLoop 3: 4\nLoop 3: 2\nLoop 3: 0\nnil\n</code></pre> <p>There are a few things to notice here:</p> <ol> <li>The variable name is not declared with <code>local</code>, but it is local to the loop body. The <code>nil</code> print at the end proves that.</li> <li>The default step is <code>1</code> when not provided.</li> <li>No boolean expression is given for the end of the loop, only a number to stop at.</li> <li>The loop ends when <code>i</code> is &gt; the limit for a positive step, and ends when <code>i</code>  is &lt; the limit for a negative step.</li> </ol> <p>The 4th point means the following code will run the body of the <code>for</code> loop once:</p> <pre><code>for i=1, 1 do\n    print(i)\nend\n</code></pre> <p>It also means that this loop's body will not run at all:</p> <pre><code>for i=1, -1 do\n    print(i)\nend\n</code></pre> <p>Separately, a step of <code>0</code> is considered an error.</p> <p>You can use <code>break</code> in a <code>for</code> loop.</p> <pre><code>for i=1, 3, 1 do\n    print(\"Loop: \"..i)\n    break\nend\n</code></pre> <p>This outputs</p> <pre><code>Loop: 1\n</code></pre>"},{"location":"lua/control_structures/#ipairs","title":"ipairs","text":"<p>You can iterate over a table's numerical indexes using special <code>for</code> loop syntax.  Instead of defining a incremented variable, a step, and so on, you give names for the  key and value of each pair, and pass the table into a call to <code>ipairs</code>.</p> <p>The <code>key</code> will be set to a key in the input table, and the <code>value</code> will be the value  at the <code>key</code> index in the table.</p> <p><pre><code>local my_table = {\n    2,\n    4,\n    8\n}\n\nfor k, v in ipairs(my_table) do\n    print(\"Key \"..k..\" has value \"..v)\nend\n</code></pre> This will output </p> <pre><code>Key 1 has value 2\nKey 2 has value 4\nKey 3 has value 8\n</code></pre> <p>When iterating with <code>ipairs</code>, the <code>key</code> will start at 1 and increase by 1 each iteration. Once a <code>nil</code> value is encountered as the value, the loop ends.</p> <p><pre><code>local my_table = {\n    2,\n    4,\n    nil,\n    8\n}\n\nfor k, v in ipairs(my_table) do\n    print(\"Key \"..k..\" has value \"..v)\nend\n</code></pre> This will output</p> <pre><code>Key 1 has value 2\nKey 2 has value 4\n</code></pre> <p>Because <code>nil</code> was found at <code>my_table[3]</code>, the loop broke.</p> <p>Note that, because only numerical indexes are visited, <code>ipairs</code> will never encounter  a value at any other type of index, like a String index.</p>"},{"location":"lua/control_structures/#pairs","title":"pairs","text":"<p>You can iterate over all of a table's indexes using special <code>for</code> loop syntax.  Instead of defining a incremented variable, a step, and so on, you give names for the  key and value of each pair, and pass the table into a call to <code>pairs</code>.</p> <p>Compare to <code>ipairs</code>.</p> <pre><code>local my_table = {\n    str = \"Hello\",\n    [-1] = -2,\n    2,\n    4,\n    nil,\n    8,\n    str_2 = \"World\"\n}\n\nmy_table.other_str = \"!\"\n\nfor k, v in pairs(my_table) do\n    print(\"Key \"..k..\" has value \"..v)\nend\n</code></pre> <pre><code>Key 1 has value 2\nKey 2 has value 4\nKey 4 has value 8\nKey -1 has value -2\nKey other_str has value !\nKey str_2 has value World\nKey str has value Hello\n</code></pre> <p>Notice that the order is not necessarily the same as the order in which key-value pairs were  added.</p>"},{"location":"lua/control_structures/#other","title":"Other","text":"<p>There's more information about these types of <code>for</code> loops, but I won't cover them here. See  the manual.</p>"},{"location":"lua/objects/","title":"Tables As Objects","text":"<p>Tables can be used to act much like objects in other object oriented languages. This is closely related to special syntax you can use for functions that are  in a table.</p> <p>Related reading: https://www.lua.org/pil/16.html</p>"},{"location":"lua/objects/#calling-functions","title":"Calling Functions","text":"<p>When a table has a function at some index, the function can be called in the  normal way, with a dot. But you can also call it using a colon <code>:</code> for extra  behavior.</p> <pre><code>local my_table = {\n    func = function()\n        print(\"Func call\")\n    end\n}\n\n-- Normal way\nmy_table.func()\n\n-- Other way\nmy_table:func()\n</code></pre> <p>When calling these functions with a colon, there is an impliict value passed into  the function, being the lefthand side of the colon.</p> <pre><code>function func(param)\n    print(param)\nend\n\nlocal my_table = {}\nmy_table.func = func\n\nmy_table.func()\nmy_table:func()\n</code></pre> <p>The above code outputs</p> <p><pre><code>nil\ntable: 0x55f82a449f40\n</code></pre> or similar.</p> <p>Despite putting nothing in the parentheses, the function call using the colon received the  table as input.</p>"},{"location":"lua/objects/#self","title":"self","text":"<p>When using the colon to call a function, you can say the table passes itself in.  self is the standard name to use for this first parameter. You might notice it  color differently in your code editor. </p> <p>Having itself passed in means we can safely modify members of the table.</p> <pre><code>--[[\n    Adds `a` to the `num` index\n]]\nfunction add_to_num(self, a)\n    self.num = self.num + a\nend\n\nlocal my_table = {\n    num = 0,\n    add_to_num = add_to_num\n}\n\n-- 0\nprint(my_table.num)\n\nmy_table:add_to_num(2)\n\n-- 2\nprint(my_table.num)\n\n-- Notice that the above call is identical to this.\nmy_table.add_to_num(my_table, 2)\n\n-- 4\nprint(my_table.num)\n</code></pre>"},{"location":"lua/objects/#defining-functions","title":"Defining Functions","text":"<p>There's special syntax for defining a function at some String index in a table.</p> <pre><code>local my_table = {\n    num = 0\n}\n\n-- Normal\nmy_table.func_1 = function(self, a)\n    self.num = self.num + a\nend\n\n-- Another way\nfunction my_table.func_2(self, a)\n    self.num = self.num + a\nend\n\n-- Another way that also implicitly has a \"self\" parameter\nfunction my_table:func_3(a)\n    self.num = self.num + a\nend\n\n-- 0\nprint(my_table.num)\n\nmy_table:func_1(1)\nmy_table:func_2(1)\nmy_table:func_3(1)\n\n-- 3\nprint(my_table.num)\n</code></pre>"},{"location":"lua/objects/#in-onb","title":"In ONB","text":"<p>In the ONB sections, you will often see <code>self</code> in example functions, and you  will nearly always call engine functions with a colon. When interacting with  the C++ objects the engine provides, you can nearly think of them the same  way as these tables.</p>"},{"location":"lua/scope/","title":"Scope","text":"<p>Your code can only access data if that data is within its scope. </p>"},{"location":"lua/scope/#indenting","title":"Indenting","text":"<p>While not required, please indent your code to indicate a new scope. It'll  make it easier to read for you and everyone else, and it'll make it easy to  identify each unique scope. You'll see plenty of examples of this through  the code examples here and everywhere else.</p>"},{"location":"lua/scope/#blocks","title":"Blocks","text":"<p>A block of code creates a new scope. A new block exists in the space between  something and its accompanying <code>end</code>. </p> <p>That's between:</p> <ul> <li>The parentheses and <code>end</code> of a function</li> <li>The <code>then</code> and <code>end</code> of a conditional</li> <li>The <code>do</code> and <code>end</code> of a <code>for</code> or <code>while</code> loop</li> <li>The <code>repeat</code> and <code>until</code> of a repeat-until</li> </ul> <pre><code>local y = nil\n\nif true then \n    --[[\n        This `x` only exists until this block closes.\n        When it stops existing, we say it \"went out of \n        scope\".\n    ]]\n    local x = 10\n\n    --[[\n        This is a new block within the other one, \n        so it can still access `x`.\n    ]]\n\n    local function func()\n        -- 10\n        print(x)\n    end\nend\n\n--[[\n    Both print `nil`, because they exist nested in \n    a different scope.\n]]\nprint(x)\nprint(func)\n</code></pre>"},{"location":"lua/scope/#other-files","title":"Other Files","text":"<p>Each working file is its own block, unable to access anything local to any block  of another file. </p> file1.lua<pre><code>local x = 10\n\ninclude(\"file2.lua\")\n\n-- nil\nprint(y)\n</code></pre> file2.lua<pre><code>local y = 20\n\n-- nil\nprint(x)\n</code></pre> <p>Here, even though <code>file2.lua</code> is read and executed by the program running <code>file1.lua</code>, and  you might think <code>file2.lua</code>'s block is inside <code>file1.lua</code>, neither has access to each other's  local variables.</p>"},{"location":"lua/useful_functions/","title":"Useful Functions","text":"<p>Useful Lua functions for use in ONB are highlighted here. They still exist  in other Lua environments, but this page will especially relate to their use  in ONB.</p> <p>Notice how some, specifically in the math and table libraries, are accessed as  if they are parts of a global table named <code>math</code> and <code>table</code>, respectively.</p>"},{"location":"lua/useful_functions/#print","title":"print","text":"<p>You will use the <code>print</code> function, not in finished code but as part of debugging.  It will print the input data to the console (black) window that opens with the  ONB executable.</p> <p><code>print</code> takes any type as parameter, and any number of inputs can be passed in. A newline is implicitly generated.</p> <pre><code>-- Hello World\nprint(\"Hello World\")\n\n-- 100\nprint(10 * 10)\n\n-- Hello World  10  Goodbye table: 0x561832bbdf90\nprint(\"Hello World\", 10, \"Goodbye\", {})\n</code></pre> <p>It can be relatively expensive to write to the console output, so you will want  to make sure no calls to <code>print</code> are left in finished code.</p>"},{"location":"lua/useful_functions/#the-math-library","title":"The math Library","text":"<p>The math library includes a few useful functions for us.</p>"},{"location":"lua/useful_functions/#mathmin","title":"math.min","text":"<p>Calling <code>math.min</code> will return the smaller of two numbers given as input.</p> <pre><code>local a = 10\nlocal b = 20\n\n-- 10\nprint(math.min(a, b))\n</code></pre>"},{"location":"lua/useful_functions/#mathmax","title":"math.max","text":"<p>Calling <code>math.max</code> will return the larger of two numbers given as input.</p> <pre><code>local a = 10\nlocal b = 20\n\n-- 20\nprint(math.max(a, b))\n</code></pre>"},{"location":"lua/useful_functions/#mathfloor","title":"math.floor","text":"<p><code>math.floor</code> will truncate the given input, returning the input number with the decimal  portion removed. In other words, it will round down to the nearest whole number.</p> <p>Importantly, this \"converts\" a double to an integer.</p> <pre><code>local a = 10\na = a / 3\n\n-- 3.333333...\nprint(a)\n\na = math.floor(a)\n\n-- 3\nprint(a)\n</code></pre> <p>For ONB mods, you may often use this to round down after division. You can't use a number  with a decimal as a damage value without an error, so a <code>math.floor</code> call will get you a  proper number.</p>"},{"location":"lua/useful_functions/#mathceil","title":"math.ceil","text":"<p><code>math.ceil</code> will take the given input and round it up to the nearest whole number, and  return the new number.</p> <p>Importantly, this \"converts\" a double to an integer.</p> <pre><code>local a = 10\na = a / 3\n\n-- 3.333333...\nprint(a)\n\na = math.ceil(a)\n\n-- 4\nprint(a)\n</code></pre>"},{"location":"lua/useful_functions/#mathrandom","title":"math.random","text":"<p><code>math.random</code> returns a random number. It can be called with either zero, one, or two inputs.</p> <p>ONB seeds the random number generator for us, so you will never need to call <code>math.randomseed</code>  (in fact, attempting to do so will fail),</p>"},{"location":"lua/useful_functions/#zero-inputs","title":"Zero Inputs","text":"<p>Giving zero inputs in the call will generate a real number between 0 and 1, including 0 but  not including 1.</p> <pre><code>local r = math.random()\n\n--[[\n    This may print 0, 0.3, 0.014, 0.999, etc.\n]]\nprint(r)\n</code></pre>"},{"location":"lua/useful_functions/#one-input","title":"One Input","text":"<p>Giving one input will generate an integer between 1 and the number given, inclusive.</p> <pre><code>local r = math.random(3)\n\n--[[\n    This may print 1, 2, or 3.\n]]\nprint(r)\n</code></pre> <p>Crash!</p> <p>In ONB v2.0, calling <code>math.random</code> with a single input will crash if the input  is <code>0</code>!</p> <p>Unexpected Behavior!</p> <p>In ONB v2.0, calling <code>math.random</code> with a single input when that input is negative will return numbers outside of the expected range.</p>"},{"location":"lua/useful_functions/#two-inputs","title":"Two Inputs","text":"<p>Giving two inputs will generate an integer between the first input and the second, inclusive.</p> <pre><code>local r = math.random(2, 4)\n\n--[[\n    This may print 2, 3, or 4.\n]]\nprint(r)\n</code></pre> <p>Crash!</p> <p>In ONB v2.0, calling <code>math.random</code> with two inputs will crash if the second input  is <code>0</code>!</p> <p>Unexpected Behavior!</p> <p>In ONB v2.0, calling <code>math.random</code> with two inputs when the second input is negative will return numbers outside of the expected range.</p>"},{"location":"lua/useful_functions/#trig-functions","title":"Trig Functions","text":"<p>Various trigonometry functions, such as <code>math.sin</code> are present, and return values in radians.  I will not cover them specifically here, since they have not seen much usage in ONB mods.</p>"},{"location":"lua/useful_functions/#the-table-library","title":"The table Library","text":"<p>There are a few functions on <code>table</code>. <code>table.insert</code> and <code>table.remove</code> are covered in the  section on adding data to tables and the  section on removing data, respectively.</p> <p>Other functions exist, but will not be covered here.</p>"},{"location":"lua/variables/","title":"Variables","text":"<p>We can store information in variables and read from them later. A variable can be created in the following ways:</p> <pre><code>local my_local_var\nlocal my_local_var_2 = 0\nmy_global_var = \"\"\n</code></pre> <p>Here, three variables have been declared. </p> <ol> <li> <p><code>my_local_var</code> is declared local, as you can see. This means that this variable can only be accessed within this scope.  More on what \"scope\" means later. </p> </li> <li> <p><code>my_local_var_2</code> is also declared <code>local</code>, but it is initialized with a value. That value is <code>0</code>, a number.</p> </li> <li> <p>Lastly, <code>my_global_var</code> is declared and initailized to a value of <code>\"\"</code> (an empty String), but has no <code>local</code> in front of it. This  variable is global and can be accessed anywhere in the file, no matter the scope. </p> </li> </ol> <p>Notice that the first variable here, <code>my_local_var</code>, is the only one declared and not given a value. It actually does have a value  implicitly: <code>nil</code>, a keyword in Lua. You can think of it as \"nothing\". We could have also written <code>local my_local_var = nil</code> for  the same effect. I recommend using <code>=</code> and explicitly assigning to <code>nil</code> if you do, for more consistency and to make sure you are  giving it no value with intent.</p> <p>You'll almost always be using <code>local</code> variables. They're easier to work with, generally, and also help you to avoid making mistakes  that are harder to debug. Even better, they help you avoid making mistakes that are hard to notice.</p> <p>Be wary of the scope a variable is defined in. Even if your variable is declared <code>local</code>, having it in the highest, broadest scope  will leave it almost no different from a global variable.</p>"},{"location":"lua/variables/#types","title":"Types","text":"<p>Lua is dynamically typed. Unlike some other languages, where a variable declaration must also declare the type of value it will  hold, a variable in Lua can contain any type of data the language supports. That includes the following:</p> <ol> <li>Numbers (Kind of integers and doubles)</li> <li>Strings</li> <li>Booleans</li> <li>Functions</li> <li>Tables</li> <li>Other userdata (in our case, C++ engine objects)</li> <li><code>nil</code></li> </ol> <p>Here's an example of a variable using each type: <pre><code>-- Initialized to nil, no value\nlocal var = nil\n\n-- Set to an integer\nvar = 1\n\n-- Divide the value in `var` and set `var` to new value.\n-- This gets 0.5, a double\nvar = var / 2\n\n-- Set to a String\nvar = \"Hello World\"\n\n-- Set to boolean value `true`\nvar = true\n\n-- Set to an empty table\nvar = {}\n\n-- Set to a function that does nothing\nvar = function()\n\nend\n\n-- Set to a new Artifact, one of ONB's types. More on that in another section.\nvar = Battle.Artifact.new()\n</code></pre></p> <p>Other sections go over specifics for each type, except for userdata.</p>"},{"location":"lua/variables/#naming-variables","title":"Naming Variables","text":"<p>Variables can be named almost anything, with some exception. They:</p> <ol> <li>Cannot start with a number (<code>1_var</code> is an invalid name)</li> <li>Cannot start with most special characters (<code>!var</code> is invalid, but <code>_var</code> is valid)</li> <li>Cannot be the same as a keyword</li> </ol> <p>Variables named with different casing are distinct.</p> <pre><code>local x = 1\nlocal X = 2\n\n--[[\n    1\n    2\n]]\nprint(x)\nprint(X)\n</code></pre> <p>Lua variable naming convention is to use snake_case, where every word in the name is  lowercase, and every word is separated by an underscore. I will be using snake case for most example code. A large majority  of mods also stick to snake case.</p> <p>You'll want to name your variables based on what they are and how they will be used. A billion <code>var_1</code>, <code>var_2</code> and so on isn't  helping anyone, and neither is a variable named <code>number</code> that's actually a String. </p> <p>Be concise and and be precise, but don't be afraid to be verbose if you need to. Leave comments if it helps to clarify.</p>"},{"location":"lua/variables/#shadowing","title":"Shadowing","text":"<p>If two variables in the same scope share a name, the variable in the smaller scope \"shadows\" the other.  Attempting to access the veriable by name will climb up the code and scopes until it finds a match, and  it'll find the closer match sooner.</p> <p><pre><code>local x = 10\n\nfunction my_func()\n    local x = 20\n\n    -- 20, because that definition is found first\n    print(x)\nend\n\nmy_func()\n\n--[[\n    10, because my_func's `x` is enclosed in an inaccessible \n    scope and the other `x` is still reachable and unaffected\n]]\nprint(x)\n</code></pre> The previous definition is still accessible by name up until the statement declaring the  new variable finishes. That means you can do this:</p> <pre><code>local x = 10\n\nfunction my_func()\n    -- The new `x` is initialize to a value based on the old `x`\n    local x = x - 2\n\n    -- 8\n    print(x)\nend\n\nmy_func()\n\n\n-- 10\nprint(x)\n</code></pre>"},{"location":"lua/variables/booleans/","title":"Booleans","text":"<p>Booleans have only two possible values: <code>true</code> and <code>false</code>.</p> <pre><code>local t = true\nlocal f = false\n</code></pre>"},{"location":"lua/variables/booleans/#operators","title":"Operators","text":""},{"location":"lua/variables/booleans/#and","title":"AND","text":"<p><code>and</code> will take a boolean on both sides and result in <code>true</code> if both inputs are <code>true</code>, or else  it will be <code>false</code>.</p> <p>We write the word, not <code>&amp;&amp;</code> like other languages.</p> <pre><code>-- true\nprint(true and true)\n-- false\nprint(true and false)\n-- false\nprint(false and true)\n-- false\nprint(false and false)\n</code></pre>"},{"location":"lua/variables/booleans/#or","title":"OR","text":"<p><code>or</code> will take a boolean on both sides and result in <code>true</code> if one input is <code>true</code>, or else  it will be <code>false</code>.</p> <p>We write the word, not <code>||</code> like other languages.</p> <pre><code>-- true\nprint(true and true)\n-- true\nprint(true and false)\n-- true\nprint(false and true)\n-- false\nprint(false and false)\n</code></pre>"},{"location":"lua/variables/booleans/#not","title":"NOT","text":"<p><code>not</code> will reverse a boolean in front of it.</p> <p>We write the word, not <code>!</code> like other languages.</p> <pre><code>-- false\nprint(not true)\n-- true\nprint(not false)\n</code></pre> <p>You can use multiple <code>not</code> in a row.</p> <pre><code>-- false\nprint(not not not true)\n</code></pre>"},{"location":"lua/variables/booleans/#operator-precedence","title":"Operator Precedence","text":"<p>Similar to the order of operations for math operators, boolean operators  also have an order in which they resolve.</p> <ol> <li>Parentheses</li> <li>not</li> <li>and</li> <li>or</li> </ol> <p>For their placement within all other operators, see the manual.</p> <pre><code>1. true and not true or false\n    - Apply the `not`\n2. true and false or false\n    - `and` the `true` and `false`\n3. false or false\n    - `or` the false and false\n4. false\n    - Final result\n</code></pre> <p>When in doubt, use parentheses. They can make the expression easier to read, too.</p> <pre><code>1. (true and not true) or false\n2. (true and false) or false\n3. true or false\n4. false\n</code></pre>"},{"location":"lua/variables/booleans/#boolean-expressions","title":"Boolean Expressions","text":"<p>Booleans can be used in expressions. There's a lot more to say on this, so they  are covered in a different section.</p>"},{"location":"lua/variables/functions/","title":"Functions","text":"<p>Functions are like reusable groups of code that can carry out a task. This is a more complicated  type, so I encourage doing more reading than only this page. See the manual.</p>"},{"location":"lua/variables/functions/#defining-a-function","title":"Defining a Function","text":"<p>Functions are defined by the keyword <code>function</code>, followed by the name of the function and a set  of parentheses. They are closed by the keyword <code>end</code>. </p> <p>Follow the same naming conventions as any other variable.</p> <p>No <code>{ }</code> here, like other languages.</p> <pre><code>function my_func()\n\nend\n</code></pre> <p>You can name incoming variables that are passed into the function with a comma separated list of  names in the parentheses. I'll be calling these parameters, arguments, and inputs interchangeably.</p> <pre><code>function my_func(var_1, var_2, var_3)\n\nend\n</code></pre> <p>No two functions can share the same name. It will be shadowed by the second same-name declaration,  similar to other variables.</p> <p>Note that this means there is no function overloading.</p>"},{"location":"lua/variables/functions/#global-and-local","title":"Global and Local","text":"<p>Like other variables, a function can also be global or local. The <code>local</code> keyword applies just the  same.</p> <pre><code>local function my_func()\n\nend\n</code></pre> <p>Typical behavior of local vs. global variables applies.</p>"},{"location":"lua/variables/functions/#usage","title":"Usage","text":"<p>You can call, or invoke, a function by using its name and a set of parentheses.</p> <pre><code>function my_func()\n\nend\n\nmy_func()\n</code></pre> <p>You can pass values in, which will be mapped, in order, to the parameters defined.</p> <pre><code>function my_func(var_1, var_2)\n    print(var_1)\n    print(var_2)\nend\n\n--[[\n    Prints\n\n    10\n    20\n]]\nmy_func(10, 20)\n</code></pre> <p>The <code>print</code> function that has been called in some examples is a global function that Lua provides  for us. </p> <p>If you pass in a different number of parameters than the function defines in its parentheses,  the function call will not fail. If you passed in more than defined, they will be ignored;  if you passed in fewer than defined, the remaining will have a value of <code>nil</code>.</p> <pre><code>function print_vals(a, b, c)\n    print(a)\n    print(b)\n    print(c)\nend\n\n--[[\n    nil\n    nil\n    nll\n]]\nprint_vals()\n\n--[[\n    1\n    2\n    nil\n]]\nprint_vals(1, 2)\n\n--[[\n    1\n    2\n    3\n]]\nprint_vals(1, 2, 3, 4, 5)\n</code></pre>"},{"location":"lua/variables/functions/#as-a-type","title":"As a Type","text":"<p>Functions are treated just like any other variable, and can be assigned to one.</p> <pre><code>function my_func()\n    print(\"Hello World\")\nend\n\nlocal func = my_func\n\n--[[\n    Hello World\n    Hello World\n]]\nmy_func()\nfunc()\n</code></pre> <p>Functions can also be created inline with the keyword <code>function</code> followed by parentheses,  which may contain parameters.</p> <p><pre><code>local my_func = function()\n    print(\"Hello World\")\nend\n\n-- Hello World\nmy_func()\n</code></pre> Whether they are <code>local</code> or not will depend on the variable declaration.</p>"},{"location":"lua/variables/functions/#return-value","title":"Return Value","text":"<p>Functions can have a return value. The function call will resolve to the return value. A value is returned by putting the keyword <code>return</code> before it. All code after the <code>return</code> within the function will not run, and  using <code>return</code> without having an <code>end</code> as the next line is considered an error.</p> <pre><code>function add(a, b)\n    return a + b\nend\n\nlocal sum = add(1, 3)\n\n-- 4\nprint(sum)\n</code></pre> <pre><code>--[[\n    Returns the sum of `a` and `b`.\n\n    If `a` or `b` are larger than 10, \n    returns nil.\n]] \nfunction add_small(a, b)\n    if a &gt; 10 or b &gt; 10 then \n        return\n    end\n\n    return a + b\nend\n\nlocal sum = add(1, 3)\nlocal sum_big = add(100, 300)\n\n-- 4\nprint(sum)\n-- nil\nprint(sum_big)\n</code></pre> <p>When a function has no return value, <code>nil</code> is returned. This can be if there is no <code>return</code> keyword  in the code path, or if there is a <code>return</code> with no value after it.</p>"},{"location":"lua/variables/functions/#closures","title":"Closures","text":"<p>Functions create closures. Basically, anything in their scope when defined can be accessed within  the function.</p> <pre><code>local x = 10\n\nfunction print_x()\n    print(x)\nend\n\nfunction print_y()\n    print(y)\nend\n\nlocal y = 20\n\n-- 10\nprint_x()\n\n-- nil, because `y` is local and defined after print_y\nprint_y()\n</code></pre>"},{"location":"lua/variables/functions/#passing-data","title":"Passing Data","text":"<p>Data may be passed by value or by reference, depending on the type.</p> <p>Primitive types, like numbers and booleans, will be passed by value.  The function receives a copy of the value and acts on it, leaving the  original unaffected.</p> <pre><code>function add_1(a)\n    a = a + 1\nend\n\nlocal a = 1\n\nadd_a(a)\n\n-- 1\nprint(a)\n</code></pre> <p>Tables and other objects are passed by reference. Anything done to it  inside the function will affect the original as well, because the function  body is acting on the original.</p> <pre><code>function set_str(t)\n    t.str = \"Hello\"\nend\n\nlocal my_table = {}\n\n-- nil\nprint(my_table.str)\n\nset_str(my_table)\n\n-- Hello\nprint(my_table.str)\n</code></pre> <p>If you want to pass around a primitive and have it be affected in multiple places  without making it global, this can be a way to achieve that.</p> <pre><code>--[[\n    Accesses the \"num\" index on `t` and adds 1 to it.\n]]\nfunction add_1(t)\n    t.num = t.num + 1\nend\n\n--[[\n    Accesses the \"num\" index on `t` and multiplies it by 10.\n]]\nfunction mult_10(t)\n    t.num = t.num + 1\nend\n\n\nlocal my_table = {\n    num = 0\n}\n\n-- 0\nprint(my_table.num)\n\nadd_1(my_table)\n\n-- 1\nprint(my_table.num)\n\nmult_10(my_table.num)\n\n-- 10\nprint(my_table.num)\n</code></pre>"},{"location":"lua/variables/numbers/","title":"Numbers","text":"<p>Lua uses integers and doubles as number values.</p> <p>Technically, Lua only has Numbers. Integers are represented through a double, but for our purposes,  it can be necessary to differentiate. Because of this, I will sometimes talk about integers and doubles  as if they are separate types.</p>"},{"location":"lua/variables/numbers/#integers","title":"Integers","text":"<p>An integer is a number, negative or positive, that does not have a decimal point. We can perform normal arithmetic operations on them.</p> <pre><code>local counter = 0\nlocal num = 100\n\ncounter = counter + 1\nnum = num * 2\n\nlocal p = num ^ counter\n\nlocal x = p % 10\n\nx = x / 2\n</code></pre> <p>Unfortunately, Lua does not have a shorthand increment. No <code>counter++</code> for us.</p>"},{"location":"lua/variables/numbers/#bitwise-operations","title":"Bitwise Operations","text":"<p>When a number value has no decimal point, it's valid for bitwise operations. </p> <pre><code>local counter = 1\n\n-- 3\ncounter = counter | 2\nprint(counter)\n\n-- 3\ncounter = counter | 2\nprint(counter)\n\n-- 1\ncounter = counter &amp; ~2\nprint(counter)\n</code></pre> <p>and so on. </p> <p>Note that <code>~</code> is used as NOT. It can also be used as XOR.</p> <p><pre><code>-- 0, 1, 1, 0\nprint(1 ~ 1)\nprint(1 ~ 0)\nprint(0 ~ 1)\nprint(0 ~ 0)\n</code></pre> Similar to the differencee between a negative number and subtraction, use a space.</p>"},{"location":"lua/variables/numbers/#doubles","title":"Doubles","text":"<p>You can think of a double as a decimal number. </p> <pre><code>local x = 1.7\nx = x * 3\nx = x + 2.34\n</code></pre> <p>If the decimal is <code>0</code>, it'll be treated as an integer.</p> <pre><code>-- No error\nlocal x = 1.0\nx = x | 2\n\n-- This gets an error\nx = 1.5\nx = x | 2\n</code></pre>"},{"location":"lua/variables/numbers/#conversions","title":"Conversions","text":"<p>If the result of an operation on an integer ends with a value that has a decimal, you'll  have a double. That could be adding a double to an integer, or dividing by a number that  doesn't divide perfectly.</p> <pre><code>local x = 5\nx = x | 2\nx = x + 1.2\n-- x has a decimal, so this will throw an error.\nx = x | 1\n</code></pre> <p>If you're unsure of the state of a number after doing some operations on it and you need  an integer, <code>math.floor</code> or <code>math.ceil</code> will cut off the decimal. Prefer <code>math.floor</code> for  calculations in your mods, since the original games would.</p> <pre><code>-- No error\nlocal x = 1.5\nx = math.floor(x) | 2\n</code></pre>"},{"location":"lua/variables/strings/","title":"Strings","text":"<p>Strings are words, letters, and so on. </p>"},{"location":"lua/variables/strings/#creating-a-string","title":"Creating a String","text":"<p>You can create a String by wrapping any characters in quotation marks or single quotes.</p> <pre><code>local str = \"Hello\"\nlocal str_2 = 'World'\nlocal num_str = \"123\"\n</code></pre> <p>You can also wrap the characters with double brackets, but I won't cover that here.</p>"},{"location":"lua/variables/strings/#string-concatenation","title":"String Concatenation","text":"<p>You can't use math operators on a String, but you can still \"add\" them together using the  concatenation operator, <code>..</code> (two dots).</p> <p>You can put spaces between the operator and the Strings. I usually won't in my code and  examples.</p> <pre><code>local player_name = player:get_name()\nlocal str = \"Player name is \"\n\nprint(str..player_name)\n</code></pre> <p>You can also concatenate numbers, which will automatically be converted to a String.</p> <pre><code>local hp = player:get_health()\n\nprint(\"Player has \"..hp..\" HP\")\n</code></pre>"},{"location":"lua/variables/strings/#escape","title":"Escape","text":"<p>You'll notice that you can't use quotation marks in your String if you define the String  using them. You can escape the character with a backslash to make it clear to the  program that you aren't ending the String yet, and are instead literally using that character.</p> <pre><code>-- Hello \"World\"\nlocal str = \"Hello \\\"World\\\"\"\n</code></pre>"},{"location":"lua/variables/strings/#escape-characters","title":"Escape Characters","text":"<p>Typical escape characters are also present. If you don't know what those are or what that means,  the only one you'll likely be using in your modding adventures is <code>\\n</code>.</p> <p><pre><code>local str = \"Hello\\nWorld\"\n</code></pre> If you printed out the above String, you would see <pre><code>Hello\nWorld\n</code></pre> <code>\\n</code> creates a newline at that place in the String. It can be useful for formatting some debug prints  in a way that's nicer to look at.</p> <pre><code>local hp = player:get_health()\nlocal new_hp = math.max(0, hp - 200)\n\nprint(\"HP before: \"..hp..\"\\nHP After: \"..new_hp)\n</code></pre> <pre><code>HP before: 1000\nHP after: 800\n</code></pre>"},{"location":"lua/variables/strings/#equality","title":"Equality","text":"<p>Strings are equal to another String with exactly the same characters in the same order.</p> <pre><code>local str = \"Hello \"\nlocal str_2 = \"Hello\"\nlocal str_3 = \"Hello \"\n\n-- false\nprint(str == str_2)\n-- true\nprint(str == str_3)\n</code></pre>"},{"location":"lua/variables/strings/#restrictions","title":"Restrictions","text":"<p>In ONB, we don't have access to the String library. You will not be able to check for specific  characters or their position, check for substrings or patterns, capitalize and lowercase, and  so on.</p>"},{"location":"lua/variables/strings/#warnings","title":"Warnings","text":"<p>When creating a String that will be displayed to a player, such as the name of a Player Character,  or the name a chip, keep in mind that we are \"restricted\" to the characters that are valid for the  font used. Unfortunately, accuracy to BN means that there are many fonts used for many different things,  so keep this in mind as you assign Strings.</p> <p>For example, in text boxes, you'll see periods just fine. But the font used to display a Player's name  in battle does not have that character, so it can't be displayed properly.</p> <p>Characters used that aren't in the font will often be shown as a tiny capital A.</p>"},{"location":"lua/variables/tables/","title":"Tables","text":"<p>Tables are basically the backbone of Lua. A lot of strong behavior and logic will hinge  on your understanding and usage of these.</p> <p>They're like arrays and maps in one type. Using them like either will have their own  sections here, but you can also do both at the same time.</p> <p>This is a more complex type, so I recommend doing additional reading. A lot more can  be done with tables that I don't touch on. See the manual.</p>"},{"location":"lua/variables/tables/#creating-a-table","title":"Creating a Table","text":"<p>Tables are created using a pair of curly braces <code>{}</code>.</p> <pre><code>local my_table = {}\n</code></pre> <p>You can construct a table and assign it data at the same time by separating data with commas.</p> <pre><code>local my_table = {\n    \"Hello\",\n    \"World\",\n    100,\n    {}\n}\n</code></pre> <p>Here, a table was created with data in integer indexes staring at 1, NOT 0. The String <code>\"Hello\"</code> is stored at index 1, <code>\"World\"</code> at index 2, and the number <code>100</code> is  stored at index 3. Finally, an empty table is stored at index 4.</p>"},{"location":"lua/variables/tables/#string-indexes","title":"String Indexes","text":"<p>Strings can also be indexes. You can construct a table with data at String indexes.</p> <pre><code>local my_table = {\n    str = \"Hello\",\n    100\n}\n</code></pre> <p>Here, a table was created with String index <code>\"str\"</code> containing <code>\"Hello\"</code>, and numerical index  <code>1</code> containing <code>100</code>.</p>"},{"location":"lua/variables/tables/#variable-indexes","title":"Variable Indexes","text":"<p>You can also use brackets, which allow the usage of a variable as the index or a number outside  of the sequential order.</p> <pre><code>local x = 10\nlocal str = \"Hello\"\n\nlocal my_table = {\n    [20] = x,\n    [x] = -13,\n    [str] = 0,\n    str = -1\n}\n</code></pre>"},{"location":"lua/variables/tables/#adding-and-accessing-data","title":"Adding and Accessing Data","text":"<p>You can add data to a table by storing it at an index, and access it using that index. These indexes can be Strings or integers. They can also be other things, but you are very unlikely to want to do that,  so I won't talk about it.</p>"},{"location":"lua/variables/tables/#integer-indexes","title":"Integer Indexes","text":"<p>Integer indexes are automatically assigned when constructing a table without explicitly declaring an  index. In this case, they start at <code>1</code>. </p> <p>Data can be accessed and set using brackets <code>[]</code>, with the index inside.</p> <pre><code>local my_table = {\n    \"Hello\",\n    \"World\",\n    100,\n    {}\n}\n\n-- Hello\nprint(my_table[1])\n-- World\nprint(my_table[2])\n-- 100\nprint(my_table[3])\n-- Pointer to the empty table\nprint(my_table[4])\n-- nil\nprint(my_table[5])\n\nmy_table[5] = 2\n-- 2\nprint(my_table[5])\n</code></pre> <p>You can also add data at numerical indexes by calling <code>table.insert</code>, passing in the table and  the data to add. The data will be added after the last numerical index in sequence.</p> <pre><code>local my_table = {\n    2, \n    4, \n    6\n}\n\n--[[\n    Table is now equivalent to\n\n    {\n        [1] = 2,\n        [2] = 4,\n        [3] = 6,\n        [4] = 8\n    }\n]]\ntable.insert(my_table, 8)\n</code></pre> <p>By adding one more parameter between the table to insert into and the value to insert, you can specify  the index to insert at, as long as the index specified is at the end of the sequential numerical indexes  or is a numerical index that has a value. This will push data at any numerical index at and after this  point up.</p> <pre><code>local my_table = {\n    2, \n    4, \n    6\n}\n\n--[[\n    Table is now equivalent to\n\n    {\n        [1] = 2,\n        [2] = 8,\n        [3] = 4,\n        [4] = 6\n    }\n]]\ntable.insert(my_table, 2, 8)\n</code></pre>"},{"location":"lua/variables/tables/#string-indexes_1","title":"String Indexes","text":"<p>Data at String indexes, like integer indexes, can be accessed with brackets <code>[]</code> and the index inside.</p> <pre><code>local my_table = {\n    str = \"Hello\"\n}\n\n-- Hello\nprint(my_table[\"str\"])\n\nmy_table[\"str\"] = \"World\"\n-- World\nprint(my_table[\"str\"])\n\nmy_table[\"num\"] = 2\n-- 2\nprint(my_table[\"num\"])\n</code></pre> <p>There's also a shorthand access that can be done using a dot.</p> <pre><code>local my_table = {\n    str = \"Hello\"\n}\n\n-- Hello\nprint(my_table.str)\n\nmy_table.str = \"World\"\n-- World\nprint(my_table.str)\n\nmy_table.num = 2\n-- 2\nprint(my_table.num)\n</code></pre> <p>Most code examples will use this type of \"dot\" access.</p>"},{"location":"lua/variables/tables/#nested-tables","title":"Nested Tables","text":"<p>As you might have noticed in the first example, a table can contain a table. Accessing  members of this nested table works as expected.</p> <pre><code>function pr()\n    print(\"Hello Nested World\")\nend\n\nlocal my_table = {\n    {\n        [10] = 4\n    },\n\n    table = {print = pr}\n}\n\n-- 4\nprint(my_table[1][10])\n\n-- Hello Nested World\nmy_table.table.print()\n</code></pre>"},{"location":"lua/variables/tables/#removing-data","title":"Removing Data","text":"<p>To remove data, simply set the value to <code>nil</code>. </p> <pre><code>local  my_table = {\n    2,\n    4,\n    6\n}\n\nmy_table[3] = nil\n</code></pre> <p>You may also call <code>table.remove</code> to remove from the end, or give it a number to remove a specific  index and move all other numerical indexes down around it. <code>table.remove</code> will return the removed value.</p> <pre><code>local  my_table = {\n    2,\n    4,\n    6\n}\n\n--[[\n    Table is now equivalent to\n\n    {\n        [1] = 4,\n        [2] = 6\n    }\n]]\nlocal removed = table.remove(my_table, 1)\n\n--2\nprint(removed)\n</code></pre> <pre><code>local  my_table = {\n    2,\n    4,\n    6\n}\n\n--[[\n    Table is now equivalent to\n\n    {\n        [1] = 2,\n        [2] = 4\n    }\n]]\ntable.remove(my_table)\n</code></pre>"},{"location":"lua/variables/tables/#table-length","title":"Table Length","text":"<p>There's a special operator to count the number items in a table. <code>#</code> placed before the table  will return the number of sequential integer indexes, starting at <code>1</code>, which have a value.</p> <pre><code>local my_table = {\n    [0] = 0,\n    2,\n    4,\n    8,\n    [5] = 10,\n    str_index = 12\n}\n\n--[[\n    This prints 3.\n\n    6 values are in the table, but one is a String index, \n    one is at index 0, and one is not in sequence by skipping \n    ahead by a number.\n]]\nprint(#my_table)\n</code></pre>"},{"location":"lua/variables/tables/#nil-values","title":"Nil Values","text":""},{"location":"lua/variables/tables/#accessing","title":"Accessing","text":"<p>Accessing data at an index which does not have any data is safe. <code>nil</code> will be given  as the value.</p> <pre><code>local my_table = {}\n\n-- nil\nprint(my_table[2])\n-- nil\nprint(my_table.string_index)\n</code></pre>"},{"location":"lua/variables/tables/#sequential-indexes","title":"Sequential Indexes","text":"<p>For certain operations, it will matter that data is stored in sequential integer indexes,  starting at 1. A consequence of <code>nil</code> being considered empty and nonexistent is that it can  break up a table.</p> <pre><code>local my_table = {\n    2,\n    4,\n    6,\n    8\n}\n\nmy_table[4] = nil\n\n--[[ \n    This will throw an out of bounds error, because index `4` is\n    completely disconnected from the sequence.\n]]\ntable.insert(my_table, 3, 6)\n</code></pre> <p>This matters for counting as well.</p> <pre><code>local my_table = {\n    2,\n    4,\n    nil,\n    8\n}\n\n--[[\n    Prints `2`, not `3`.\n]]\nprint(#my_table)\n</code></pre> <p>And iterating using <code>ipairs</code>, but not <code>pairs</code>.</p> <pre><code>local my_table = {\n    2,\n    4,\n    nil,\n    8\n}\n\nlocal visited_indexes = 0\n\nfor k, v in ipairs(my_table) do\n    visited_indexes = visited_indexes + 1\nend\n\n-- 2\nprint(visited_indexes)\n\nlocal visited_pairs_indexes = 0\n\nfor k, v in pairs(my_table) do\n    visited_pairs_indexes = visited_pairs_indexes + 1\nend\n\n-- 3\nprint(visited_pairs_indexes)\n</code></pre>"},{"location":"lua/variables/tables/#objects","title":"Objects","text":"<p>Tables can function similarly to objects in other languages. This is covered in  another section.</p>"},{"location":"onb_overview/","title":"Overview","text":"<p>The pages under this tab will introduce you to some of the tools Open Net  Battle offers, and give a sort of \"tech\" overview. I won't go deep into object usage in this section, nor will I document every aspect of them. </p> <p>You will not find documentation of every engine function in these pages. For that, see here: https://paintylux.github.io/OpenNetBattleDocs. Make sure to click into the <code>Main Docs</code>, <code>Classes &amp; Functions</code>, and <code>Code Snippets</code> tabs.</p> <p>Those linked docs are incomplete, and some information may be a little inaccurate. Just  small things that you might notice. For example, some index access is shown to use a colon  in places where you might have to use a period. If you find any information here that contradicts what you could find there, trust what I write. </p>"},{"location":"onb_overview/#capitalized-words","title":"Capitalized Words","text":"<p>Every time you see the name of an object type and it's capitalized, I'm referring to the  object type. Pay attention to this when wording would otherwise be ambiguous, like when  a variable named <code>tile</code> refers to a Tile class object.</p> <p>You'll notice this mostly when I talk about Player, the object, versus player, the person  behind the screen playing the game. Be careful not to confuse those.</p>"},{"location":"onb_overview/entities/","title":"Entity Class","text":"<p>The base class of things that appear on the field during battle. The player character,  an explosion effect, a pillar of fire, an enemy\u2014all of these are types of Entity.</p> <p>In the below sections, you will read about each type of Entity in the engine:</p> <ul> <li>Artifact</li> <li>Spell</li> <li>Obstacle</li> <li>Character</li> <li>Player</li> </ul> <p>Each of these types should be used in different scenarios, so be sure to understand  each one and use the most appropriate. </p>"},{"location":"onb_overview/entities/#scripted-version","title":"\"Scripted\" Version","text":"<p>I left out some types of Entity from the above list. For each Entity type (and most non-Entity  types), the engine has a second, very similar class:</p> <ul> <li>ScriptedArtifact</li> <li>ScriptedSpell</li> <li>ScriptedObstacle</li> <li>ScriptedCharacter</li> <li>ScriptedPlayer</li> </ul> <p>For the most part, there is not much difference between each class and its \"Scripted\"  counterpart. In these pages, I usually don't make the distinction and use them interchangeably, but keep an eye out for when I specifically mention the Scripted versions. They sometimes  have additional functionality and functions.</p> <p>Generally, when you create an instance of the class, it will be a Scripted version. When you are given an instance of the class, such as through the return value of an  engine function, it will not be. When you define callbacks on the class, the <code>self</code>  passed in will be the Scripted version, seen in the below callbacks section.</p> <p>When in doubt, use <code>print</code> to check the type. The console will tell you if it's a  Scripted version or not.</p>"},{"location":"onb_overview/entities/#is-a-relationship","title":"Is-A Relationship","text":"<p>In object oriented programming, you will often see a base class that other classes  inherit from. This means that those classes, those types of objects, have some things  in common. </p> <p>An Artifact is an Entity.  A Spell is an Entity. An Obstacle is an Entity. A Character is an Entity. A Player is an Entity. They all share traits with Entity.</p> <p>For descendants of Entity, this means they have access to many of the same functionality.  Everything outlined on this page, and more, applies to every other type of Entity.</p> <p>I will often be general in wording and say something affects Entities, or something  searches for Entities. You will also see this wording in the code. Know that that means  the function, code, logic, or intent applies to all types of Entity.</p> <p>Look out for this phrasing as you read.</p>"},{"location":"onb_overview/entities/#id","title":"ID","text":"<p>The engine keeps a running tally of created Entities. Whenever a new Entity is created,  it's assigned a unique ID in sequence. This ID can be used to identify the Entity without  storing a reference to the Entity, and is required for a few functions.</p> <pre><code>local artifact = Battle.Artifact.new()\nlocal spell = Battle.Spell.new(Team.Red)\n\nlocal id_1 = artifact:get_id()\nlocal id_2 = spell:get_id()\n\nprint(id_1)\n-- This number will be 1 higher than id_1\nprint(id_2)\n</code></pre> <p>This can almost be used to determine what Entity is older, except that the ID is divorced  from spawn order. An Entity with an older ID could be spawned before after with a newer ID. Modders are encouraged to spawn their Entities in the same frame they are created, both  to ensure no resources are wasted and to try to keep IDs in a chronological order.</p>"},{"location":"onb_overview/entities/#accessible-class-members","title":"Accessible Class Members","text":"<p>Entities have their own, or store a reference to, some other engine class objects.  Below are functions related to these.</p> <p>Each of these classes will have their own page. Be sure to check them for what  you can do with these objects.</p>"},{"location":"onb_overview/entities/#field","title":"Field","text":"<p>An Entity has a Field that they are on. </p> <pre><code>local field = ent:get_field()\n</code></pre> <p><code>get_field</code> will fail if the Entity has not been spawned.</p>"},{"location":"onb_overview/entities/#tile","title":"Tile","text":"<p>An Entity has a single Tile on the Field that it stands on at a time.</p> <pre><code>local tile = ent:get_current_tile()\ntile = ent:get_tile()\ntile = ent:get_tile(Direction.Right, 1)\n</code></pre> <p>The <code>tile</code> returned from these functions can be <code>nil</code> if the Entity has  not been spawned, or if the Entity is not on the Field. (Being absent from  the field is unusual, so you will likely not have to code around it. But be  aware of it.)</p>"},{"location":"onb_overview/entities/#hitprops","title":"HitProps","text":"<p>An Entity has HitProps.</p> <pre><code>local props = ent:copy_hit_props()\nent:set_hit_props(props)\n</code></pre> <p>Only Spells and Obstacles make relevant use of HitProps.</p>"},{"location":"onb_overview/entities/#sprite","title":"Sprite","text":"<p>An Entity has a Sprite.</p> <pre><code>local sprite = ent:sprite()\n</code></pre>"},{"location":"onb_overview/entities/#animation","title":"Animation","text":"<p>An Entity has an Animation.</p> <pre><code>local anim = ent:get_animation()\n</code></pre>"},{"location":"onb_overview/entities/#other-important-values","title":"Other Important Values","text":"<p>There are many other handy fields on Entity. </p>"},{"location":"onb_overview/entities/#facing","title":"Facing","text":"<p>Every Entity is facing either Left or Right. Its Sprite will be drawn facing left  or right based on this. An Entity's facing is a Direction enum  value, but only <code>Direction.Right</code> and <code>Direction.Left</code> are valid.</p> <pre><code>local facing = player:get_facing()\nprint(\"Facing right?\", facing == Direction.Right)\n</code></pre> <p>You can also get the opposite of an Entity's facing using <code>Entity.get_facing_away</code>.</p> <pre><code>local facing_away = player:get_facing_away()\nprint(\"Not facing right?\", facing_away == Direction.Right)\n</code></pre> <p>Most importantly, you can set an Entity's facing.</p> <pre><code>spell:set_facing(player:get_facing())\n</code></pre> <p>An Entity can only face Left or Right. Others values are ignored.</p>"},{"location":"onb_overview/entities/#default-facing","title":"Default Facing","text":"<p>When an Entity is created, it has no facing. You should set its facing. If you don't, it  will be given one when it is spawned, and it may not be what you wanted. </p> <p>If an Entity is spawned without having a facing set, its facing will be set to match the  facing of the Tile it was spawned on. Tiles on the left side of the field have a facing of  Direction.Right, and Tiles on the right side of the Field have a facing of Direction.Left.</p> <p>Essentially, their facing will be set so that they face the center of the screen.</p>"},{"location":"onb_overview/entities/#team","title":"Team","text":"<p>Entities have a Team, which is a Team enum. For Entities which can  be hit, this determines what attacks can hit them.</p> <pre><code>local team = player:get_team()\nprint(\"On Red Team?\", team == Team.Red)\n</code></pre> <p>You can set an Entity's Team with <code>Entity.set_team</code>, which takes a Team as input.</p> <pre><code>local artifact = Battle.Artifact.new()\nartifact:set_team(player:get_team())\n</code></pre> <p>You won't do this often, because you will give most Entities a Team when you  create them.</p> <p>Changing Player Teams</p> <p>You will usually not want to change an Entity's Team after it has spawned. For  Players, this is even more true. A battle ends when one Team has no members left,  so swapping the Player's team might end the battle if doing so causes their old  Team to be empty.</p>"},{"location":"onb_overview/entities/#default-team","title":"Default Team","text":"<p>Most Entities are given a Team when you create them, but not all. An Artifact will  default to <code>Team.Other</code>. Characters and Players created by a Mob package will default  to the Team of the Tile they spawn on.</p>"},{"location":"onb_overview/entities/#element","title":"Element","text":"<p>Every Entity has an Element, which is an Element enum value.  See the page on Element for their effects.</p> <p>You can set an Entity's Element with <code>Entity.set_element</code>, and fetch it with  <code>Entity.get_element</code>.</p> <pre><code>player:set_element(Element.Fire)\nlocal element = player:get_element()\n-- true\nprint(element == Element.Fire)\n</code></pre> <p>By default, an Entity's Element is <code>Element.None</code>.</p>"},{"location":"onb_overview/entities/#callbacks","title":"Callbacks","text":"<p>Entities have some indexes which are used as callback functions. They are often <code>nil</code> by default, but can be set to a function which the  engine will call under certain conditions.</p> <p>Many callbacks pass <code>self</code> in. Expect the same type that the Entity on the  lefthand side of the <code>.</code> is, which may mean the Scripted variants.</p> <p>Many of these callbacks only exist and can be set on the Scripted class  versions.</p>"},{"location":"onb_overview/entities/#update_func","title":"update_func","text":"<p>An Entity's <code>update_func</code> takes the Entity as a parameter. It will be  called no more than once during a frame, and will be called alongside the  Entity's update. </p> <p>It will not be called in a frame if the Entity will not update during that frame. </p> <pre><code>ent.update_func = function(self)\n    print(\"Update\")\nend\n</code></pre>"},{"location":"onb_overview/entities/#delta-time","title":"Delta Time","text":"<p>The update_func actually has one more input, a delta time <code>dt</code>, in milliseconds,  since the last frame. It will nearly always be equal to <code>1/60</code>. I omit it here  for two reasons:</p> <ol> <li>It will be removed in the next engine update.</li> <li>It encourages you to make logic that is not based on frame numbers and that  may be vulnerable to floating point imprecision.</li> </ol> <p>For point 2, the latter reason may be a non-issue in almost all cases. But it's  more correct to use frame numbers as a basis for logic in an engine that is precisely  based on frame timing. You are less likely to regret it.</p> <p>If you need to count or time something, remember that this callback will run once  every frame.</p> <pre><code>spell.delay = 5\nspell.update_func = function(self)\n    if self.delay == 0 then\n        print(\"Did nothing for 5 frames\")\n    end\n\n    self.delay = self.delay - 1\nend\n</code></pre>"},{"location":"onb_overview/entities/#on_spawn_func","title":"on_spawn_func","text":"<p>The <code>on_spawn_func</code> takes the Entity as a parameter. The engine will call it when  the Entity is successfully spawned. It will run only once in an Entity's lifetime.</p> <pre><code>ent.on_spawn_func = function(self)\n    print(\"Spawned entity with ID \"..self:get_id())\nend\n</code></pre> <p>Fact Check Needed</p> <p>This notice will be removed once I check if it can run for an Entity which failed  to spawn.</p>"},{"location":"onb_overview/entities/#battle_start_func","title":"battle_start_func","text":"<p>The <code>battle_start_func</code> takes the Entity as a parameter. The engine will call it  when battle starts. This will happen only once.</p> <pre><code>ent.battle_start_func = function(self)\n    print(\"Battle started.\")\nend\n</code></pre> <p>This callback may run later than you would expect. Specifically, it will be called  on the first frame the player gains control after clicking OK on the Custom Screen.  This will be just as the \"Battle Start\" text disappears.</p> <p>Fact Check Needed</p> <p>This notice will be removed once I check if it runs at the start of this frame, or the end of the previous one.</p> <p>Because it runs only once, an Entity that is spawned after this will never have its  callback run.</p> <p>Fact Check Needed</p> <p>This notice will be removed once I check if it only runs for Entities which exist  as the battle is created. </p>"},{"location":"onb_overview/entities/#battle_end_func","title":"battle_end_func","text":"<p>The <code>battle_end_func</code> takes the Entity as a parameter. It will run when the battle ends. Specifically, when the text saying \"Enemy Deleted\" or similar begins to appear.</p> <pre><code>player.battle_end_func = function(self)\n    print(\"Battle ended.\")\nend\n</code></pre>"},{"location":"onb_overview/entities/#can_move_to_func","title":"can_move_to_func","text":"<p>The <code>can_move_to_func</code> takes a Tile as paramter. It will be called whenever  the Entity attempts a MoveEvent, and the destination Tile for the MoveEvent  will be passed in.</p> <p>The engine expects a boolean value to be returned. If <code>true</code> is returned,  you are telling the engine that the movement to that Tile is OK and should  be allowed to continue. If <code>false</code> is returned, you are telling the engine to  reject the movement.</p> <pre><code>spell.can_move_to_func = function(tile)\n    return tile:is_walkable()\nend\n</code></pre> <p>A common mistake when making a projectile that should move across the screen  is forgetting to define a <code>can_move_to_func</code>. Without it, the engine will  believe that all MoveEvents should fail.</p> <p>This callback will not be used for any type of Player. </p>"},{"location":"onb_overview/entities/#delete_func","title":"delete_func","text":"<p>The <code>delete_func</code> takes the Entity as parameter. It will be called immediately  when the Entity is marked for deletion by the <code>Entity.delete</code> function.</p> <p><pre><code>spell.delete_func = function(self)\n    print(\"Deleted\")\nend\n\nprint(\"About to delete\")\nspell:delete()\nprint(\"Finished deleting\")\n</code></pre> The above code would output</p> <pre><code>About to delete\nDeleted\nFinished deleting\n</code></pre> <p>The <code>delete_func</code> will not be called more than once.</p>"},{"location":"onb_overview/entities/#deletion","title":"Deletion","text":"<p>An Entity can be marked for deletion at the end of the frame by calling <code>Entity.delete</code>.</p> <pre><code>spell:delete()\n</code></pre> <p>This will cause the Entity's <code>delete_func</code> callback to run.</p> <p>Once <code>delete</code> has been called, the Entity is put into a state where it is waiting to  be removed from the field. The Entity \"is deleted\" already.</p> <p>While deleted, certain actions cannot be taken on the Entity object. If you try, you'll  see an error appear telling you that data is deleted. Your code should often have  safeguards when handling Entity references because of this, especially if the reference  is kept and accessed across frames.</p> <pre><code>--[[\n    Runs every frame. `player` could be deleted by the next \n    time this runs, so check.\n]]\nspell.update_func = function(self)\n    if player:is_deleted() then \n        return\n    end\n\n    print(player:get_current_tile():x())\nend\n</code></pre> <p>At some point, the \"deleted\" Entity will be removed from the field.</p> <p>Missing Info</p> <p>This notice will be removed once I check when exactly they are removed.</p>"},{"location":"onb_overview/entities/#erase","title":"erase","text":"<p>There is another function similar to <code>Entity.delete</code>. This is <code>Entity.erase</code>.</p> <pre><code>spell:erase()\n</code></pre> <p>My recommendation is to never call it, and to always use <code>Entity.delete</code> if you  want to delete something. This is because <code>Entity.erase</code> will skip running an  Entity's <code>Entity.delete_func</code> callback, which may have had important cleanup  logic. </p> <p>One benefit to <code>Entity.erase</code> is that the Entity will not be drawn the frame  it's called, unlike <code>Entity.delete</code>. But calling <code>Entity.delete</code> with a call to  <code>Entity.hide</code> will accomplish the same, without compromising <code>Entity.delete_func</code>.</p>"},{"location":"onb_overview/entities/artifact/","title":"Artifact","text":"<p>Artifacts are the lightest Entity type. They have the least logic associated with them. </p>"},{"location":"onb_overview/entities/artifact/#creating-an-artifact","title":"Creating an Artifact","text":"<p>Calling <code>Battle.Artifact.new()</code> will return a new Artifact object. Like every  other type of Entity, it will need to be spawned on the Field before it will  do anything.</p> <pre><code>local artifact = Battle.Artifact.new()\n</code></pre>"},{"location":"onb_overview/entities/artifact/#when-to-use","title":"When to Use","text":"<p>Artifacts should only be used for purely graphical effects. Tying any sort  of logic to them beyond that is often a mistake, due to their update timing.</p> <p>Other Entity types may only update during time freeze if they were spawned  during that time freeze, and the next time time freezes they will not update  during it. An Artifact, on the other hand, will continue to update during every  time freeze. </p> <p>This is perfect for a graphical effect, so it can continue to animate, finish its  animation, and remove itself without blocking the players' view for very long. But  if you have any logic that affects the battle tied to it, the timing can be thrown  completely off by time freeze beginning during it.</p>"},{"location":"onb_overview/entities/character/","title":"Character","text":"<p>Characters can take damage and use CardActions. They display their HP below their sprite. They also have a \"Rank\". Deleting them affects final battle results.</p>"},{"location":"onb_overview/entities/character/#creating-a-character","title":"Creating a Character","text":"<p>Calling <code>Battle.Character.new(Team, Rank)</code> will return a new Character object. Like  every other type of Entity, it will need to be spawned on the Field before it will  do anything.</p> <pre><code>local character = Battle.Character.new(team, rank)\n</code></pre> <p>The <code>team</code> variable in the above code snippet must be a Team enum value, and <code>rank</code>  must be a Rank enum value. </p> <p>You will usually not directly call the function to create a Character, since it  will be handled for you in Mob packages. </p>"},{"location":"onb_overview/entities/character/#from-character-id","title":"From Character ID","text":"<p>There is no loadable mod package specifically for Characters, but you can still define a Character and give it a unique package ID. How to do this will be covered in a  different section.</p> <p>If you know a Character's ID, you can create that Character, calling its <code>package_init</code> in the process, using that ID.</p> <pre><code>local character = Battle.Character.from_package(id, team, rank)\n</code></pre> <p>Mod Sync</p> <p>When mods sync for PvP, a library that defines the Character with that ID might  not have been shared Be wary of using this in a context where the function could be  called in PvP.</p>"},{"location":"onb_overview/entities/character/#when-to-use","title":"When to Use","text":"<p>You will typically use Characters when you want to create a more character-like  Entity, something that has movement and attack patterns. Enemies are the most  common Character uses.</p>"},{"location":"onb_overview/entities/character/#character-or-obstacle","title":"Character or Obstacle","text":"<p>When deciding whether to use Characters or Obstacles, keep the following in mind:</p> <ol> <li>Characters can be counterhit, granting FullSynchro and a bonus towards Busting Level</li> <li>Characters can be double- or triple-deleted, putting text on the screen and granting  a bonus to Busting Level</li> <li>Characters are made to be able to easily respond to Rank, to allow you to set different  stats, colors, behavior, etc. for different versions of the same Character (like V1 and V2 bosses)</li> </ol>"},{"location":"onb_overview/entities/character/#type-checking","title":"Type Checking","text":"<p>You can test if an Entity is a Character. The <code>Battle.Character.from(entity)</code> function  call will return a Character cast of the input Entity if it was a Character, or <code>nil</code>  if it was not.</p> <pre><code>spell.attack_func = function(self, other)\n    local p = Battle.Character.from(other)\n    if p ~= nil then \n        print(\"Damaged a Character\")\n    else\n        print(\"Damaged a different type of Character\")\n    end\nend\n</code></pre> <p>Remember that a Player is a Character, so <code>Battle.Character.from(entity)</code> when  <code>entity</code> is a Player will return a Character object, not nil.</p>"},{"location":"onb_overview/entities/obstacle/","title":"Obstacle","text":"<p>Obstacles are non-Characters which can take damage. Unlike Characters, they  do not display their HP, and they don't count towards any battle results.</p>"},{"location":"onb_overview/entities/obstacle/#creating-an-obstacle","title":"Creating an Obstacle","text":"<p>Calling <code>Battle.Obstacle.new(Team)</code> will return a new Obstacle object. Like every  other type of Entity, it will need to be spawned on the Field before it will  do anything.</p> <pre><code>local obstacle = Battle.Obstacle.new(team)\n</code></pre> <p>The <code>team</code> variable in the above code snippet must be a Team enum value. </p> <p>Don't forget to give it a health value after creating one, or else it will not  be able to get hit. The first call to <code>Obstacle.set_health</code> will also set its max health.</p> <pre><code>local obstacle = Battle.Obstacle.new(team)\n\n-- 0\nprint(obstacle:get_max_health())\n\nobstacle:set_health(200)\n\n-- 200\nprint(obstacle:get_max_health())\n</code></pre>"},{"location":"onb_overview/entities/obstacle/#when-to-use","title":"When to Use","text":"<p>Things like RockCube or Anubis are often called \"objects\", or maybe \"summons\"  by Battle Network players. These are the sorts of things you would replicate  using an Obstacle.</p> <p>Their use is not limited to just those, however. Remember, an Obstacle is just  something that can take damage that isn't a Character. You might use them for  detecting a hit on a different Tile, or an attack that can be destroyed, like  PropellerBomb from BN4, or CutMan's scissors which block attacks.</p>"},{"location":"onb_overview/entities/obstacle/#obstacle-limit","title":"Obstacle Limit","text":"<p>BN players may remember that certain objects they spawn have a limit. You can  only have two RockCubes on your field before trying to spawn a third will  destroy the first, or you might want to use Prism and BlkBomb at the same time,  but trying to throw the BlkBomb will destroy the Prism. The limit is based on  a sort of \"type\" of object, where certain objects fit into the type that allows  2 slots, and others fit into the 1 slot type. Others still, like FlashBomb from  BN6, can be thrown without ever affecting other field objects.</p> <p>These limits do not exist and are not enforced in ONB. Modders have created  importable scripts to add the behavior to your Obstacles, with a short an opt-in  process.This will be talked about in another section. Until then, you can find me  (Alrysc) on the ONB Discord server and ask about my ObstacleInfo library.</p>"},{"location":"onb_overview/entities/obstacle/#attacking","title":"Attacking","text":"<p>Obstacles are allowed to attack and deal damage in the same way as Spells. See  similar sections on the Spells page.</p>"},{"location":"onb_overview/entities/obstacle/#type-checking","title":"Type Checking","text":"<p>You can test if an Entity is an Obstacle. The <code>Battle.Obstacle.from(entity)</code> function  call will return an Obstacle cast of the input Entity if it was an Obstacle, or <code>nil</code>  if it was not.</p> <pre><code>spell.attack_func = function(self, other)\n    local ob = Battle.Obstacle.from(other)\n    if ob ~= nil then \n        print(\"Damaged an Obstacle\")\n    else\n        print(\"Damaged a different type of Entity\")\n    end\nend\n</code></pre>"},{"location":"onb_overview/entities/obstacle/#deleting-at-0-health","title":"Deleting At 0 Health","text":"<p>When an Obstacle's health is set to 0, either by <code>set_health</code> or by taking damage,  it will be deleted immediately, even during time freeze.</p>"},{"location":"onb_overview/entities/player/","title":"Player","text":"<p>Players are Characters that are controlled by the one playing the game.  They have their own mod package type, and additional stats and functions.</p>"},{"location":"onb_overview/entities/player/#creating-a-player","title":"Creating a Player","text":"<p>You cannot create a Player object. You will explicity be given a ScriptedPlayer in the function parameters of the <code>player_init</code> in a Player mod file.</p>"},{"location":"onb_overview/entities/player/#stats","title":"Stats","text":"<p>In addition to health, Players have a few extra stats.</p>"},{"location":"onb_overview/entities/player/#attack-level","title":"Attack Level","text":"<p>Players have an attack level, which is an integer ranging from 1 to 5. By default,  it is 1.</p> <p>You can use <code>Player.get_attack_level</code> to get the current attack level, and  <code>player.set_attack_level</code> to set a new one. </p> <pre><code>local current_attack = player:get_attack_level()\n\n-- 1\nprint(current_attack)\n\nplayer:set_attack_level(current_attack + 10)\n\n-- 5, because it's capped\nprint(player:get_attack_level())\n</code></pre> <p>A Player's attack level is often used in the formula to determine the damage their  attacks will do.</p>"},{"location":"onb_overview/entities/player/#charge-level","title":"Charge Level","text":"<p>Players have a charge level, which affects how fast they can charge for their charged attack. See Charging for specific speeds.</p> <p>Charge level is an integer ranging from 1 to 5. By default, it is 1.</p> <pre><code>local current_charge = player:get_charge_level()\n\n-- 1\nprint(current_charge)\n\nplayer:set_charge_level(current_charge + 10)\n\n-- 5, because it's capped\nprint(player:get_charge_level())\n</code></pre>"},{"location":"onb_overview/entities/player/#charging","title":"Charging","text":"<p>While holding the Shoot button, a Player will begin to charge. There are three states  to charging:</p> <ol> <li>For the first 10 frames, there is no visual cue that charging has started</li> <li>After the first 10 frames, a graphic appears</li> <li>After the full charge time, the graphic changes and changes color</li> </ol> <p>While in the third state, releasing the Shoot button will call the <code>charged_attack_func</code>.</p> <p>It takes 110 frames to reach full charge. The Player cannot charge during another action. Anything that would end an active action will also reset the charge. </p>"},{"location":"onb_overview/entities/player/#charge-speed","title":"Charge Speed","text":"<p>By default, it takes 100 frames to reach full charge at charge level 1. The higher the Player's charge level, the less time it will take. Specifically, 10 frames are cut off for each level. The  formula would be something like:</p> <p><code>110 - 10 * c</code></p> <p>where <code>c</code> is the charge level. Keep in mind that charge level will be a number from 1 to 5,  hence the 110 frame time at level 1.</p> <p>Officially, the charge time formula is slightly different from the above. 10 frames are factored  into all charge times, because it takes that long for the charge graphic to appear. So in  reality, the engine has a formula more like</p> <p><code>10 + (100 - 10 * c)</code></p> <p>Keep this in mind for scripted charge time formulas.</p>"},{"location":"onb_overview/entities/player/#changing-the-formula","title":"Changing the Formula","text":"<p>You can determine the time it takes to charge by setting the Player's <code>charge_time_func</code>,  both on Players and on PlayerForms. The <code>charge_time_func</code> is passed a reference to the Player,  and a number <code>level</code> representing the current Charge level, and expects a <code>frametime</code> to be  returned. The <code>level</code> will be a number from 1 to 5, inclusive. Be sure to cover all cases.</p> <pre><code>local form = player:create_form()\nplayer.charge_time_func = function(self, level)\n    if level == 1 then\n        return frames(50)\n    end\n\n    if level == 2 then \n        return frames(40)\n    end\n\n    -- etc.\nend\n\n-- Note that the form receives the Player, not itself, in the parameters, \n-- so standard practice of using `self` as the first parameter is incorrect.\nform.charge_time_func = function(player, level)\n    if level == 1 then\n        return frames(100)\n    end\n\n    if level == 2 then \n        return frames(90)\n    end\n\n    -- etc.\nend\n</code></pre> <p>Some tips for determining charge times:</p> <ul> <li>The default charge time is 90 frames at level 1, 80 at level 2, 70 at level 3, 60 at level 4, and 50 and level 5.</li> <li>If your charge time can be based on a formula, use one<ul> <li>For exmaple, the ONB default can be replicated in one line with <code>return frames(100 - 10 * level)</code></li> </ul> </li> <li>The official games often do not use linear charge times. For example, HeatCross in BN6 has times   60, 50, 40, 35, 30, for levels 1-5. Notice how having more levels past 3 has lesser effect.</li> <li>The returned time is applied after holding the Shoot button for 10 frames (when the graphic appears)<ul> <li>This means returning <code>frames(10)</code> actually means you need to hold B for 20 frames total to be fully charged</li> <li>Sources on charge times for the official games may or may not count the 10 frames before holding Shoot.  Take this into consideration when taking data from other sources. </li> </ul> </li> </ul> <p>If your mod changes the <code>Player.charged_attack_func</code>, consider also changing the <code>Player.charge_time_func</code>.</p>"},{"location":"onb_overview/entities/player/#built-in-cardactions","title":"Built-In CardActions","text":"<p>ScriptedPlayers have three definable functions that can return CardActions, which  will be called by the engine under certain circumstances.</p>"},{"location":"onb_overview/entities/player/#normal_attack_func","title":"normal_attack_func","text":"<p>The <code>normal_attack_func</code> will run when the player presses the Shoot button  while the Player is actionable. It takes the ScriptedPlayer as input and expects  to return a CardAction.</p> <p>A common CardAction to return is the Buster action, which replicates MegaMan's  normal attacks in the official games when given <code>false</code> as the second parameter.</p> <pre><code>player.normal_attack_func = function(self)\n    -- false to use normal attack graphics on hit, attack level as damage\n    return Battle.Buster.new(self, false, self:get_attack_level())\nend\n</code></pre>"},{"location":"onb_overview/entities/player/#charged_attack_func","title":"charged_attack_func","text":"<p>The <code>charged_attack_func</code> will run when the player releases the Shoot button after  holding it for long enough to become fully charged. It takes the ScriptedPlayer as  input and expects to return a CardAction.</p> <p>A common CardAction to return is the Buster action, which replicates MegaMan's  charged attacks in the official games when <code>true</code> is given as the second parameter.</p> <pre><code>player.charged_attack_func = function(self)\n    --[[\n        true to use charged attack graphics on hit and charged attack\n        framedata, attack level * 10 as damage\n    ]]\n    return Battle.Buster.new(self, true, self:get_attack_level() * 10)\nend\n</code></pre>"},{"location":"onb_overview/entities/player/#special_attack_func","title":"special_attack_func","text":"<p>The <code>special_attack_func</code> will run when the player releases the Special button  while the Player is actionable. It takes the ScriptedPlayer as input and expects  to return a CardAction. </p> <p>The Special button is intended to parallel the B+Back input from the official  games. </p> <pre><code>-- Play the \"PLAYER_HIT\" animation and do nothing else\nplayer.special_attack_func = function(self)\n    local action = Battle.CardAction.new(self, \"PLAYER_HIT\")\n\n    return action\nend\n</code></pre>"},{"location":"onb_overview/entities/player/#inputs","title":"Inputs","text":"<p>You can read the player's inputs from their associated Player using the <code>Player.input_has</code>  function, passing in the input to check for. These are represented by the Input enum  values.</p> <p>Inputs come in three types:</p> <ol> <li>Pressed, true only on the exact frame a button was pressed down</li> <li>Held, true every frame the button is down after the first</li> <li>Released, true on the exact frame a button was let up</li> </ol> <p>Only one of the above types will be <code>true</code> at a time for one input.</p> <p>Frame Step</p> <p>In v2.1, the tracking for held button inputs continues to advance even while  the engine is paused. This means it's difficult, if not impossible, to read a  Pressed input while frame stepping.</p> <pre><code>if player:input_has(Input.Pressed.Shoot) then \n    print(\"Shoot button was pressed this frame\")\nend\n</code></pre> <pre><code>local count = 0\nspell.update_func = function(self)\n    if player:input_has(Input.Held.Right) then \n        count = count + 1\n        print(\"Holding Right for \"..count..\" frames\")\n    elseif player:input_has(Input.Released.Right) then \n        print(\"Player let go\")\n        self:delete()\n    end\nend\n</code></pre>"},{"location":"onb_overview/entities/player/#forms","title":"Forms","text":"<p>Players have access to a form changing mechanic, a recreation of the Cross system  in Battle Network 6. A player can choose forms that are added to the Player from the  Custom screen, the same as BN6.</p> <p>A Player can have up to 5 forms. You can add one by calling <code>Player.create_form</code>  when the <code>player_init</code> runs. Calling it later will not add the form.</p> <pre><code>function player_init(player)\n    local form_1 = player:create_form()\nend\n</code></pre> <p>This creates a PlayerForm object. These will be detailed in another page.</p>"},{"location":"onb_overview/entities/player/#type-checking","title":"Type Checking","text":"<p>You can test if an Entity is a Player. The <code>Battle.Player.from(entity)</code> function  call will return a Player cast of the input Entity if it was a Player, or <code>nil</code>  if it was not.</p> <pre><code>spell.attack_func = function(self, other)\n    local p = Battle.Player.from(other)\n    if p ~= nil then \n        print(\"Damaged a Player\")\n    else\n        print(\"Damaged a different type of Entity\")\n    end\nend\n</code></pre> <p>Remember that a Player is a Character, so <code>Battle.Character.from(entity)</code> when  <code>entity</code> is a Player will return a Character object, not nil.</p>"},{"location":"onb_overview/entities/player/#checking-for-scriptedplayer","title":"Checking For ScriptedPlayer","text":"<p><code>Battle.Player.from(entity)</code> will return a ScriptedPlayer instead of a Player if  the input Entity is exactly the Player type.</p> <p>Because this is a Scripted type, this means you can access and set user indexes  on the Player. This is commonly used for mods that change normal, charged, or  special attacks.</p> <p>This can be dangerous, however, because you may collide with the names of indexes  the creator of that Player mod added to the Player. Take care when adding any.  Try to use especially unique names, similar to when you choose a package ID name.</p>"},{"location":"onb_overview/entities/spell/","title":"Spell","text":"<p>Spells are nearly synonymous with hitboxes. They are what you will spawn  on the field to do damage to something.</p>"},{"location":"onb_overview/entities/spell/#creating-a-spell","title":"Creating a Spell","text":"<p>Calling <code>Battle.Spell.new(Team)</code> will return a new Spell object. Like every  other type of Entity, it will need to be spawned on the Field before it will  do anything.</p> <pre><code>local spell = Battle.Spell.new(team)\n</code></pre> <p>The <code>team</code> variable in the above code snippet must be a Team enum value. </p>"},{"location":"onb_overview/entities/spell/#when-to-use","title":"When to Use","text":"<p>A Spell is used to attack and deal damage. It's one of the two Entity types  that is allowed to attack, alongside Obstacle.</p>"},{"location":"onb_overview/entities/spell/#attacking","title":"Attacking","text":"<p>We attack using a Spell by telling a Tile (typically its own) to queue an attack. Usually you will see this done during its <code>update_func</code> logic.</p> <pre><code>spell.update_func = function(self)\n    self:get_current_tile():attack_entities(self)\nend\n</code></pre> <p>The above code snippet will, every frame the Spell <code>spell</code> is on the Field, queue  an attack on the Spell's Tile to happen later in the frame, when attacks are  processed.</p> <p>It's important to understand that attacks will happen later in the frame, and  not immediately when you call <code>Tile.attack_entities</code>. </p>"},{"location":"onb_overview/entities/spell/#attack-targets","title":"Attack Targets","text":"<p>All Entities on the Tile will be checked for attacking. Entities which are on the  same Team as the Spell will not be hit, unless the Spell is Team.Other. </p> <p>Only Characters, Obstacles, and Players can be hit by an attack.</p>"},{"location":"onb_overview/entities/spell/#attacking-multiple-times","title":"Attacking Multiple Times","text":"<p>The snippet above will queue an attack every frame, but this does not mean an  Entity standing on the same Tile as a Spell will take damage rapidly. </p> <p>Once a Spell has collided with an Entity, further attacks  on the same Tile will not be queued. You may still queue attacks on other  Tiles which have not yet been hit by this Spell, but if you want to hit again,  you will need to spawn additional Spells.</p> <p>For example, see the code below. A Spell is created which does not attack itself,  but instead spawns another Spell every few frames to do the attack. This allows  you to repeatedly attack the same Tile.</p> <pre><code>function spawn_attack(field, team, props, tile)\n    local spell = Battle.Spell.new(team)\n    spell:set_hit_props(props)\n\n    spell.update_func = function(self)\n        self:get_current_tile():attack_entities(self)\n        -- Only attack for one frame, and then delete. \n        self:delete()\n    end\n\n    field:spawn(spell, tile)\nend\n\nlocal field = player:get_field()\nlocal team = player:get_team()\nlocal tile = player:get_current_tile()\nlocal props = -- Omitted HitProps creation\n\nlocal spell = Battle.Spell.new(team)\n\nlocal frame = 0\nspell.update_func = function(self)\n    if frame % 5 == 0 then \n        spawn_attack(field, self:get_team(), props, self:get_current_tile())\n    end\n\n    frame = frame + 1\nend\n\nfield:spawn(spell, tile)\n</code></pre>"},{"location":"onb_overview/entities/spell/#on-queuing-attacks","title":"On Queuing Attacks","text":"<p>You may have noticed in the above code that I called <code>Tile.attack_entities</code> and then  immediately deleted the Spell used to attack. The attack was queued, so it won't  happen until later in the frame. Then, by the time the attack happens, won't the Spell  be deleted? Can it still attack?</p> <p>The answer is \"Yes\". That queued attack will still go through later in the frame, so  that Spell queuing an attack and then deleting itself will only attack once.</p>"},{"location":"onb_overview/entities/spell/#attack_func","title":"attack_func","text":"<p>ScriptedSpells have an <code>attack_func</code> index that your code can define. It will  run only if and when an attack made by the Spell dealt damage. If it was blocked  by a DefenseRule, it will not run. </p> <p>It takes the Spell, the Entity that was hit, and the DefenseFrameStateJudge as  parameter. Modders have taken to calling the second parameter <code>other</code>, so you will  often see that name. I will also use it here.</p> <pre><code>spell.attack_func = function(self, other, judge)\n    print(\"Spell \"..self:get_id()..\" damaged Entity \"..other:get_id())\nend\n</code></pre>"},{"location":"onb_overview/entities/spell/#collision_func","title":"collision_func","text":"<p>ScriptedSpells have a <code>collision_func</code> index that your code can define. It will  run only if and when an attack made by the Spell collided with the Entity. It  could not run if, for example, an Entity is intangible after being hit with an attack  that had the Hit.Flashing flag. If it does run, it will run before the <code>attack_func</code>,  or may run even if the <code>attack_func</code> does not.</p> <p>It takes the Spell, the Entity that was hit as parameter, and the DefenseFrameStateJudge.  Modders have taken to calling the second parameter <code>other</code>, so you will often see that name.  I will also use it here.</p> <pre><code>spell.collision_func = function(self, other, judge)\n    print(\"Spell \"..self:get_id()..\" collided with Entity \"..other:get_id())\nend\n</code></pre>"},{"location":"onb_overview/entities/spell/#hitbox","title":"Hitbox","text":"<p>There is another type, Hitbox, that is related to Spell. A Hitbox is a Spell. I  briefly mention it here without much detail, mostly because I have never felt the  need to use it. </p> <p>A Hitbox is a Spell which has a few preconfigurations. Notably, it's automatically  set up to queue an attack and delete itself.</p> <p>Overall, however, a Hitbox is more restrictive than a Spell, and often cannot be  used alone to replicate attacks you can find in the official games.</p> <ul> <li>It has no \"Scripted\" version<ul> <li>You cannot set indexes on it to contain your own data</li> </ul> </li> <li>It can't be used with a graphic or animation</li> <li>The attack can only have one active frame (one frame where it can do damage)</li> <li>Setting the <code>collision_func</code> and <code>attack_func</code> indexes is more awkward</li> </ul> <p>A Hitbox can be created in the same way as a Spell.</p> <pre><code>local hitbox = Battle.Hitbox.new(team)\n</code></pre> <p>You must use its <code>Hitbox.set_callbacks</code> function to set both the <code>collision_func</code>  and the <code>attack_func</code> at the same time.</p> <pre><code>local hitbox = Battle.Hitbox.new(team)\n\nlocal function collision_func(self, other, judge)\n    print(\"Hitbox \"..self:get_id()..\" collided with Entity \"..other:get_id())\nend\n\nlocal function attack_func(self, other, judge)\n    print(\"Hitbox \"..self:get_id()..\" damaged Entity \"..other:get_id())\nend\n\n\nhitbox:set_callbacks(attack_func, collision_func)\n</code></pre> <p>In the Attacking Multiple Targets section of this page,  there was a code snippet that would attack one Tile multiple times. In that particular  instance, Hitbox could do the same in fewer lines.</p> <pre><code>function spawn_attack(field, team, props, tile)\n    local hitbox = Battle.Hitbox.new(team)\n    hitbox:set_hit_props(props)\n\n    field:spawn(hitbox, tile)\nend\n\nlocal field = player:get_field()\nlocal team = player:get_team()\nlocal tile = player:get_current_tile()\nlocal props = -- Omitted HitProps creation\n\nlocal spell = Battle.Spell.new(team)\n\nlocal frame = 0\nspell.update_func = function(self)\n    if frame % 5 == 0 then \n        spawn_attack(field, self:get_team(), props, self:get_current_tile())\n    end\n\n    frame = frame + 1\nend\n\nfield:spawn(spell, tile)\n</code></pre>"},{"location":"onb_overview/entities/spell/#sharedhitbox","title":"SharedHitbox","text":"<p>A SharedHitbox is in a similar place to Hitbox. You may see it used in especially  old mods that replicate Sword chips, but it isn't required and I have never felt  the need to use it.</p> <p>You can create a SharedHitbox by passing in an Entity and a time, in milliseconds,  that it will exist for. I'll be referring to that Entity as the SharedHitbox's \"owner\".  The engine source code uses the same name.</p> <pre><code>local spell = Battle.Spell.new(team)\nlocal shared = Battle.SharedHitbox.new(spell, 0.033)\n</code></pre> <p>Frames</p> <p>Remember that 1 in-game frame is roughly equal to 0.0166 seconds. When in doubt, use  <code>frame_count / 60</code>. For example, <code>21/60</code> as the time if you want it to last for 21 frames.</p> <p>A SharedHitbox will reference the HitProps and Team of its owner, as well as its <code>attack_func</code> and  <code>collision_func</code>. When spawned, it will stay on the Field and continually attack its Tile  until the specified amount of time passes. </p> <p>A SharedHitbox will stop attacking before its timer expires if the Entity used to  created it is deleted.</p> <p>No Deletion</p> <p>If the Entity used to create the SharedHitbox is deleted before the timer expires,  the SharedHitbox may not be deleted automatically.</p>"},{"location":"onb_overview/enums/","title":"Enums","text":"<p>Enums are not an actual Lua type, but they are a C++ type, and the engine  gives access to them.</p>"},{"location":"onb_overview/enums/#what-are-enums","title":"What Are Enums","text":"<p>You can think of an enum as a table with String indexes which hold number  values. The number value usually isn't important, but the String is. Its  name will tell you what it should be treated as.</p> <p>They're a way to keep code looking less arbitrary and more readable when  you need logic to respond to certain signals. For example, take the following  code:</p> <pre><code>function do_something(thing, a, b)\n    if thing == 0 then \n        return a + b\n    elseif thing == 1 then \n        return a * b\n    elseif thing == 2 then \n        return a / b\n    end\nend\n\n\n-- 2\nprint(do_something(2, 10, 5))\n</code></pre> <p>When you call <code>do_something</code>, it's a little less clear what the intent is.  Future code changes might add or remove values, and now the <code>2</code> that's given  here might have a different meaning.</p> <p>With enums, we can essentially assign these values a name. Here's how something  else could look:</p> <pre><code>local things = {\n    add = 1,\n    multiply = 2,\n    divide = 3\n}\n\nfunction do_something(thing, a, b)\n    if thing == things.add then \n        return a + b\n    elseif thing == things.multiply then \n        return a * b\n    elseif thing == things.divide then \n        return a / b\n    end\nend\n\n-- 2\nprint(do_something(things.divide, 10, 5))\n</code></pre> <p>Now it's much more clear what the intent is behind each value. When working  with the values given in Lua, the first <code>do_something</code> function, which checked  <code>thing == 0</code> etc., checking against exact numbers, would still work when given the  new <code>things.add</code> and so on, but remember the reasons why we wouldn't refer to the  exact value.</p> <p>Say we had updated the \"enum\" values in a month to now be </p> <pre><code>local things = {\n    add = 1,\n    subtract = 2,\n    multiply = 3,\n    divide = 4\n}\n</code></pre> <p>Now the function which checked exactly == 2 and multiplied is incorrect. The  version that checked for <code>things.multiply</code> will still work as expected.</p>"},{"location":"onb_overview/enums/#enums-in-onb","title":"Enums In ONB","text":"<p>The pages in this section describe the engine enums we have access to from Lua  when modding. There are a couple things you should notice about them:</p> <ol> <li>They always use capitalized names</li> <li>Accessing is just like a Lua table with String indexes</li> <li>Their indexed values are (almost) always numbers</li> </ol> <p>The first point is a reminder that you may want to avoid capitalizing your variable  names. snake_case is perferred. Imagine you had code like this:</p> <pre><code>local Direction = player:get_facing()\n</code></pre> <p>You've now shadowed the actual <code>Direction</code> enum and can't access it in this scope  anymore. You won't be able to test against <code>Direction.Left</code> and so on because now  <code>Direction</code> refers to a number value, which you can't index without error.</p> <p>The third point is a reminder that trying to print values will not be that useful.</p> <pre><code>local facing = player:get_facing()\n\n-- Prints 2... What does that mean?\nprint(facing)\n</code></pre> <p>Because of this, you might instead want to use comparisons to check.</p> <pre><code>local facing = player:get_facing()\n\nprint(\"Facing left? \"..(facing == Direction.Left))\n</code></pre> <p>I won't include the number values of any enums here, because you mostly shouldn't  use them for reasons described above. You can find them in the engine source if  you really need them.</p>"},{"location":"onb_overview/enums/audiopriority/","title":"AudioPriority","text":"<p><code>AudioPriority</code> values are used in calls to <code>Engine.play_audio</code> to describe  how aggressively the audio will try to be played. </p> <p>Similar to the GBA games, ONB has a number of SFX channels. Using certiain  AudioPriority could cause a sound to defer to another, not playing at all  if channels are busy. The following priorities exist:</p> <ul> <li>Lowest</li> <li>Low</li> <li>High</li> <li>Highest</li> </ul>"},{"location":"onb_overview/enums/audiopriority/#usage","title":"Usage","text":"<p><code>Engine.play_audio</code> takes an AudioPriority as its second parameter.</p> <pre><code>Engine.play_audio(SFX_HANDLE, AudioPriority.Low)\n</code></pre> <p><code>SFX_HANDLE</code> in the above snippet must be an audio handle returned from a  call to <code>Engine.load_audio</code>, or an AudioType enum value.</p>"},{"location":"onb_overview/enums/audiopriority/#lowest","title":"Lowest","text":"<p><code>AudioPriority.Lowest</code> plays on a free channel, but other <code>Lowest</code> priority  sounds will not play at the same time.</p>"},{"location":"onb_overview/enums/audiopriority/#low","title":"Low","text":"<p><code>AudioPriority.Low</code> plays the sound a free channel. It can play at the same  time as other sounds. If you ever have issues where a sound doesn't play, using  this priority will solve it.</p>"},{"location":"onb_overview/enums/audiopriority/#high","title":"High","text":"<p><code>AudioPriority.High</code> forces your sound to play, but other High priority can't play  at the same time. This also means your sound won't play if another High priority sound  is currently playing.</p>"},{"location":"onb_overview/enums/audiopriority/#highest","title":"Highest","text":"<p><code>AudioPriority.Highest</code> tries to force your sound to play. </p> <p>Missing Info</p> <p>I'm not sure what the difference between Highest and Low is in practice. This notice  will be removed once I've done more research.</p>"},{"location":"onb_overview/enums/audiopriority/#usage-suggestion","title":"Usage Suggestion","text":"<p>I almost always use the Low piority. It practically guarantees that the sound will play. If you are sure your code is supposed to be playing it but you're not hearing it, and you  know it's loud enough to hear, you may want to change to Low priority.</p>"},{"location":"onb_overview/enums/audiotype/","title":"AudioType","text":"<p>You can play sounds in ONB using <code>Engine.play_audio</code>. You will mostly use it with  sound effects that are in your mods, but you can also access the sound effects  bundled with the engine by using the AudioType enum.</p> <p>AudioType has the following indexes:</p> <ul> <li>CounterBonus</li> <li>DirTile</li> <li>Fanfare</li> <li>Appear</li> <li>AreaGrab</li> <li>AreaGrabTouchdown</li> <li>BusterPea</li> <li>BusterCharged</li> <li>BusterCharging</li> <li>BubblePop</li> <li>BubbleSpawn</li> <li>GuardHit</li> <li>Cannon</li> <li>Counter</li> <li>Wind</li> <li>ChipCancel</li> <li>ChipChoose</li> <li>ChipConfirm</li> <li>ChipDesc</li> <li>ChipDescClose</li> <li>ChipError</li> <li>CustomBarFull</li> <li>CustomScreenOpen</li> <li>ItemGet</li> <li>Deleted</li> <li>Explode</li> <li>Gun</li> <li>Hurt</li> <li>HurtCharacter</li> <li>HurtObstacle</li> <li>PanelCrack</li> <li>PanelReturn</li> <li>Pause</li> <li>PreBattle</li> <li>Recover</li> <li>Spreader</li> <li>SwordSwing</li> <li>TossItem</li> <li>TossItemLite</li> <li>Wave</li> <li>Thunder</li> <li>ElecPulse</li> <li>Invisible</li> <li>ProgramAdvance</li> <li>LowHP</li> <li>DarkCard</li> <li>PointSFX</li> <li>NewGame</li> <li>Text</li> <li>Shine</li> <li>TimeFreeze</li> <li>Meteor</li> <li>Deform</li> </ul>"},{"location":"onb_overview/enums/audiotype/#usage","title":"Usage","text":"<p>You can use an AudioType in the same place you would use an audio handle in  a call to <code>Engine.play_audio</code>.</p> <pre><code>Engine.play_audio(AudioType.Shine, AudioPriority.Low)\n</code></pre> <p>It's possible that these sound files may change quality or volume in the future,  or may be removed or swapped for other sounds.</p>"},{"location":"onb_overview/enums/blocks/","title":"Blocks","text":"<p>The <code>Blocks</code> enum contains indexes representing the supported NaviCust block  colors. This includes the following:</p> <ul> <li>White</li> <li>Red</li> <li>Green</li> <li>Blue</li> <li>Pink</li> <li>Yellow</li> </ul> <p>Only colors from BN6 are included. </p>"},{"location":"onb_overview/enums/blocks/#usage","title":"Usage","text":"<p>You will use this enum to set the color of blocks in your Block packages.</p> <pre><code>function package_init(block)\n    block:set_color(Blocks.White)\n    -- Omitted the rest of package_init for example\nend\n</code></pre> <p>If no color is set, a default of <code>Blocks.White</code> will be used.</p>"},{"location":"onb_overview/enums/cardclass/","title":"CardClass","text":"<p><code>CardClass</code> indexes describe a card's class. A card's preview color  changes with the CardClass, and certain effects may target certain classes. </p> <p>The following CardClass indexes are available:</p> <ul> <li>Standard</li> <li>Mega</li> <li>Giga</li> <li>Dark</li> </ul> <p>By default, <code>CardClass.Standard</code> is used.</p>"},{"location":"onb_overview/enums/cardclass/#usage","title":"Usage","text":"<p>A CardClass can be set on a CardProperties object's <code>card_class</code> index. Usually, this is  set in the <code>package_init</code> of a card mod.</p> <pre><code>function package_init(package) \n    local props = package:get_card_props()\n    props.card_class = CardClass.Standard\n    -- Omitted the rest of the package_init for the example\nend\n</code></pre>"},{"location":"onb_overview/enums/cardclass/#copy-limits","title":"Copy Limits","text":"<p>In the official games, each class would have an associated limit within your folder. For  example, in Battle Network 6, you could only have up to 5 Mega chips in your folder, and  only 1 Giga chip without additional modifiers.</p> <p>Currently, ONB does not enforce these limits. However, in the future, expect to see user- created servers that do, or that may control limits in other ways based on their CardClass.</p>"},{"location":"onb_overview/enums/cardclass/#effects","title":"Effects","text":"<p>A card's CardClass can be read by code in certain places. Nothing in the engine does, but  user-created mods might change behavior based on them. For an official example, see the  Beat NaviCust Part, which will activate when the opponent uses a Mega or Giga class chip. </p> <p>Currently in ONB, we can only reasonably act on the CardClass in the <code>filter_hand_step</code>.  This would allow, for example, an effect like GaiaSword that only consumes Standard chips  in your hand.</p>"},{"location":"onb_overview/enums/cardclass/#dark","title":"Dark","text":"<p>Dark chips only appeared in a meaningful capacity in BN4 and BN5. ONB takes more of a BN5  approach with Dark chips, as they can be put into your folder. </p> <p>Currently, ONB replicates the following Dark chip behavior:</p> <ul> <li>Hovering a Dark chip in the Custom window will dim the screen, lower music volume,  and play a sound</li> <li>A Dark chip appearing in the Custom window will cause the cursor to jump to it  when Custom is opened</li> </ul> <p>Music Volume</p> <p>If you leave a battle using the Esc key while the cursor is on a Dark chip, the music  volume will not return to its original volume.</p> <p>A few more behaviors may be replicated in future versions.</p>"},{"location":"onb_overview/enums/cardclass/#expectations","title":"Expectations","text":"<p>In the official games, Dark chips inflict the user with a bug, and may also inflict whatever  they hit with a bug as well, under certain conditions. Using any during a battle will also make you permanently lose 1 max HP when the battle ends, up to some maximum. </p> <p>Due to the nature of ONB, you shouldn't necessarily expect either of those to be true. All  card mods are made by modders, so it's up to them to add bugs and so on. What a card mod  can't do is reduce max HP, which you should especially expect from the nature of ONB. But  a server might be able to track that you have used a Dark chip while on the server and do  something, such as lowering max HP, based on it. That would only apply to that server, and  the server must be programmed to do such things.</p>"},{"location":"onb_overview/enums/colormode/","title":"ColorMode","text":"<p>The <code>ColorMode</code> enum values determine the way a Color will be applied to  a Sprite.</p> <p>The available ColorMode indexes are:</p> <ul> <li>Multiply</li> <li>Additive</li> </ul> <p>The default is usually <code>ColorMode.Additive</code>. Descendent Sprites may sometimes  be <code>ColorMode.Multiply</code> by default instead.</p> <p>Missing Info</p> <p>This notice will be removed once I've confirmed exactly when descendents  use Multiply as a default.</p>"},{"location":"onb_overview/enums/colormode/#usage","title":"Usage","text":"<p>You can use <code>Sprite.set_color_mode</code> to change a Sprite's ColorMode.</p> <pre><code>local artifact = Battle.Artifact.new()\nlocal sprite = artifact:sprite()\nsprite:set_color_mode(ColorMode.Multiply)\n</code></pre> <p>Doing that alone may cause the color of the Sprite to sharply change. You will  usually follow a call to <code>set_color_mode</code> with a call to <code>set_color</code>.</p> <pre><code>sprite:set_color_mode(ColorMode.Multiply)\n\nlocal red = Color.new(255, 0, 0, 255)\nsprite:set_color(red)\n</code></pre>"},{"location":"onb_overview/enums/colormode/#additive","title":"Additive","text":"<p><code>ColorMode.Additive</code> will cause Colors to increase RGBA values. Generally, this  is used to make a Sprite appear brighter. <code>Color.new(0, 0, 0, 255)</code> represents  no change, and <code>Color.new(255, 255, 255, 255)</code> represents white.</p>"},{"location":"onb_overview/enums/colormode/#multiply","title":"Multiply","text":"<p><code>ColorMode.Multiply</code> will cause Colors to multiply RGBA values. Generally, this  is used to make a Sprite appear darker. <code>Color.new(255, 255, 255, 255)</code> represents  no change, and <code>Color.new(0, 0, 0, 255)</code> represents black.</p>"},{"location":"onb_overview/enums/defenseorder/","title":"DefenseOrder","text":"<p>The <code>DefenseOrder</code> enum is used when creating a DefenseRule, and describes the time  at which the DefenseRule will be checked against an attack.</p> <p>It has the following indexes:</p> <ul> <li>Always</li> <li>CollisionOnly</li> </ul>"},{"location":"onb_overview/enums/defenseorder/#usage","title":"Usage","text":"<p>You must pass in a <code>DefenseOrder</code> when creating a DefenseRule.</p> <pre><code>local defense = Battle.DefenseRule.new(1, DefenseOrder.Always)\n</code></pre> <p>No DefenseRules react to an attack which could never hit the Entity, such as if the  attack and the Entity are not Team.Other and not on the same Team, or if the Entity's  hitbox is toggled off.</p>"},{"location":"onb_overview/enums/defenseorder/#always","title":"Always","text":"<p>DefenseRules with the <code>DefenseOrder.Always</code> DefenseOrder will always run for an attack  that is able to hit. These will run before <code>DefenseOrder.CollisionOnly</code>, and will run  even if the Entity is intangible.</p>"},{"location":"onb_overview/enums/defenseorder/#collisiononly","title":"CollisionOnly","text":"<p>DefenseRules with the <code>DefenseOrder.CollisionOnly</code> DefenseOrder will only run for attacks  that collide. This means it will not run if the Entity is intangible.</p> <p>An attack's <code>collision_func</code> will run just before these DefenseRules are checked.</p>"},{"location":"onb_overview/enums/direction/","title":"Direction","text":"<p>The Direction enum has values for each direction. It also has a few  useful functions for manipulating them.</p> <p>It has the following indexes:</p> <ul> <li>None</li> <li>Up</li> <li>UpRight</li> <li>Right</li> <li>DownRight</li> <li>Down</li> <li>DownLeft</li> <li>Left</li> <li>UpLeft</li> </ul> <p>Additionally, the following indexes have function values:</p> <ul> <li>join</li> <li>reverse</li> <li>flip_x</li> <li>flip_y</li> <li>unit_vector</li> </ul>"},{"location":"onb_overview/enums/direction/#usage","title":"Usage","text":"<p>The actual directions on Direction will mostly be used for an Entity's facing  direction, the direction for something to move in, or the direction to pivot  from a Tile when calling <code>Entity.get_tile</code> or <code>Tile.get_tile</code>.</p> <pre><code>-- Tile to the right of the player\nlocal tile = player:get_tile(Direction.Right, 1)\n</code></pre> <p>It's less common to refer to exactly Left or Right, because those directions may mean different things for player 1 and player 2. Try to keep Left/Right references  relative.</p> <pre><code>local facing = player:get_facing()\n-- Tile in front of the player\nlocal tile = player:get_tile(facing, 1)\n</code></pre>"},{"location":"onb_overview/enums/direction/#join","title":"join","text":"<p><code>Direction.join</code> will return the combination of two input Directions. Up and  Right becomes UpRight, for example.</p> <p><code>Direction.join</code> can help when using relative directions. If you want to get  the Tile that's in front of the player and one up, for example, you can do this:</p> <pre><code>local facing = player:get_facing()\nlocal joined_direction = Direction.join(facing, Direction.Up)\nlocal tile = player:get_tile(joined_direction, 1)\n</code></pre> <p>Note that it is called with a period instead of a colon.</p> <p>The alternative is to travel across two different Tiles, which also necessitates a  check for <code>nil</code> on the first <code>get_tile</code> call.</p>"},{"location":"onb_overview/enums/direction/#reverse","title":"reverse","text":"<p><code>Direction.reverse</code> will reverse an input Direction, returning its opposite. Left  becomes Right, Up becomes Down, and so on.</p> <p><code>Direction.reverse</code> can help when using relative directions. If you want to get the  Tile that's behind the user, for example, you can do this:</p> <pre><code>local facing = player:get_facing()\nlocal reverse_facing = Direction.reverse(facing)\nlocal tile = player:get_tile(reverse_facing, 1)\n</code></pre> <p>Note that it is called with a period instead of a colon.</p> <p>Also remember that the above intention can also be done using <code>Entity.get_facing_away</code> and skipping the reverse. Regardless, it'll be a useful tool, like when you don't have  an Entity to get the facing direction of.</p>"},{"location":"onb_overview/enums/direction/#flip_x","title":"flip_x","text":"<p><code>Direction.flip_x</code> will flip the horizontal part of a Direction and return the result. </p> <pre><code>local flip = Direction.flip_x(Direction.UpRight)\n</code></pre> <p><code>flip</code> in the above code will equal <code>Direction.UpLeft</code>.</p> <p>Note that it is called with a period instead of a colon.</p> <p>You can and likely will mostly use <code>Direction.reverse</code> for this, because most of the time  when you want to flip a facing Direction, you can use <code>Direction.reverse</code>. An Entity can  only face left or right, so there usually won't be a diagonal that you may only want to  flip the horizontal on.</p>"},{"location":"onb_overview/enums/direction/#flip_y","title":"flip_y","text":"<p><code>Direction.flip_y</code> will flip the vertical part of a Direction and return the result. </p> <pre><code>local flip = Direction.flip_y(Direction.UpRight)\n</code></pre> <p><code>flip</code> in the above code will equal <code>Direction.DownRight</code>.</p> <p>Note that it is called with a period instead of a colon.</p> <p>You can and likely will mostly use <code>Direction.reverse</code> for this, because most of the time  when you want to flip a facing Direction, you can use <code>Direction.reverse</code>. An Entity can  only face left or right, so there usually won't be a diagonal that you may only want to  flip the vertical on.</p>"},{"location":"onb_overview/enums/direction/#unit_vector","title":"unit_vector","text":"<p><code>Direction.unit_vector</code> will return a Vector representation of an input Direction.  Right becomes (1, 0), UpRight becomes approximately (0.707, -0.707), Left becomes (-1, 0),  and so on.</p> <p>You are unlikely to use this very often.</p>"},{"location":"onb_overview/enums/direction/#bitwise-operations","title":"Bitwise Operations","text":"<p>The number values in the indexes on Direction are powers of 2 in the source code. This  means you can treat them like flags, where all of them can be \"set\". However, doing so  with this set of values accomplishes nothing. The engine specifically expects exact values,  and does not use any bitwise operations when checking these values. Additionally, with  values like these, you might expect <code>Direction.UpRight</code> to equal <code>Direction.Up | Direction.Right</code>,  but this is not the case.</p>"},{"location":"onb_overview/enums/element/","title":"Element","text":"<p>Entities and HitProps have Elements. They determine what Entities take bonus  damage from, what HitProps deal bonus damage to, and what special interactions  on a Tile the HitProps might have.</p> <p>Card mod packages separately can have an Element set to display an icon. This  can be programmed to be a different Element than the damage dealt by an attack,  and sometimes is in official games.</p> <p>The Elements available in v2.1 match the ones you'll find in BN6:</p> <ul> <li>None</li> <li>Fire</li> <li>Aqua</li> <li>Elec</li> <li>Wood</li> <li>Sword</li> <li>Break</li> <li>Cursor</li> <li>Wind</li> <li>Summon</li> <li>Plus</li> </ul> <p>A few more will be added in the future.</p> <p>Typically, you would say a Navi that is Fire Element is, or has, FireBody. An attack  that has the Fire Element can be said to deal Fire damaga. I'll be using that wording  throughout these docs.</p> <p>The None element is often referred to as Null. I'll mostly do the same.</p>"},{"location":"onb_overview/enums/element/#interactions","title":"Interactions","text":""},{"location":"onb_overview/enums/element/#none","title":"None","text":"<p>An Entity with NullBody has no special interactions and does not take additional damage  from attacks of any other element.</p> <p>An attack that deals Null damage has no special interactions.</p>"},{"location":"onb_overview/enums/element/#fire","title":"Fire","text":"<p>An Entity with FireBody takes bonus damage from Aqua attacks and does not trigger damage  from Lava Tiles. They also take damage while standing on Sea Tiles, as if it was poison.</p> <p>An attack that deals Fire damage will deal bonus damage to WoodBody Entities. If the Tile  an Entity is standing when they get hit is in the Grass TileState, they will take bonus damage. Attacks made on Tiles in the Grass TileState will cause the Tile to revert to <code>TileState.None</code>.</p>"},{"location":"onb_overview/enums/element/#aqua","title":"Aqua","text":"<p>An Entity with AquaBody takes bonus damage from Elec attacks. Additionally, an Entity with  AquaBody will not slip when moving to a Tile that is in the Ice TileState.</p> <p>An attack that deals Aqua damage will deal bonus damage to FireBody Entities. If the Tile  an Entity is standing when they get hit is in the Ice TileState, the TileState will be set  to <code>TileState.None</code>, and they will be frozen. If the attack passes over a Tile in the  <code>TileState.Volcano</code> state, the Tile will revert to <code>TileState.None</code></p> <p>Lava</p> <p>In the official games, an Aqua attack passing over Lava and Volcano Tiles will set  them to normal. This does not happen in v2.1, but will in the future.</p> <p>Sea</p> <p>Contrary to popular belief, it is not true that all AquaBody Characters submerge  themselves in Sea Tiles as if they were under the Mole or PopUp chip effect.  This is an ability of ToadSoul and certain viruses, not AquaBody.</p>"},{"location":"onb_overview/enums/element/#elec","title":"Elec","text":"<p>An Entity with ElecBody takes bonus damage from Wood attacks. </p> <p>An attack that deals Elec damage will deal bonus damage to AquaBody Entities and Entities  under the Bubble status. If the Tile an Entity is standing when they get hit is in the  Sea TileState, they will take bonus damage.</p>"},{"location":"onb_overview/enums/element/#wood","title":"Wood","text":"<p>An Entity with WoodBody takes bonus damage from Fire attacks. If the Entity is a  Character, they will also heal over time while standing on Grass Tiles. This healing  is 1 HP per 20 frames, but slows down to 1 HP per 180 frames if the Character has  less than 10 HP left.</p> <p>An attack that deals Wood damage will deal bonus damage to ElecBody Entities. </p>"},{"location":"onb_overview/enums/element/#sword","title":"Sword","text":"<p>An Entity with SwordBody takes bonus damage from Break attacks.</p> <p>An attack that deals Sword damage will deal bonus damage to WindBody Entities. </p>"},{"location":"onb_overview/enums/element/#break","title":"Break","text":"<p>An Entity with BreakBody takes bonus damage from Cursor attacks.</p> <p>An attack that deals Break damage will deal bonus damage to SwordBody Entities. </p> <p>Pierce Guard and Freeze Break</p> <p>A common misconception is that the Break element is what allows an attack to  go through shields, break objects, or deal bonus damage to a frozen target. This  is not the case. It's a certain hitflag that acts as a signal for this to happen.</p> <p>All Break element attacks in the official games happen to have this flag, but  many other attacks also do.</p>"},{"location":"onb_overview/enums/element/#cursor","title":"Cursor","text":"<p>An Entity with CursorBody takes bonus damage from Wind attacks.</p> <p>An attack that deals Cursor damage will deal bonus damage to BreakBody Entities. </p> <p>Breaking Traps</p> <p>In BN6, Cursor element attacks also remove active traps set by the target.  This is not an automatic effect in ONB, since traps are UGC. When making traps,  it's recommended to keep this interaction intact.</p>"},{"location":"onb_overview/enums/element/#wind","title":"Wind","text":"<p>An Entity with WindBody takes bonus damage from Sword attacks.</p> <p>An attack that deals Wind damage will deal bonus damage to CursorBody Entities. </p> <p>Barriers/Auras</p> <p>In BN6, any Wind element attack will remove a Barrier or Aura. This is not an  automatic effect in ONB, since they are UGC. When making Barrier or Aura effects,  it's recommended to keep this interaction intact.</p>"},{"location":"onb_overview/enums/element/#summon-and-plus","title":"Summon and Plus","text":"<p>The Summon and Plus Elements do nothing as a Body or attack damage.</p> <p>As a consequence of Element appearing in multiple contexts, the engine allows you to  set these as the Element of an Entity or as a damage Element. Regardless, I will recommend  here and elsewhere to never do that. </p> <p>The official games use these Elements only for its icon on a chip, which you can do separately with the mod package. If you use this in other places, mods aiming for accuracy to the source  material might have unexpected conditions.</p> <p>Mechanically, they are essentially a Null that isn't actually Null.</p>"},{"location":"onb_overview/enums/entitystatus/","title":"EntityStatus","text":"<p>The <code>EntityStatus</code> enum is a status returned by calls to <code>Field.spawn</code> to describe  the results of the spawn.</p> <p>It has the following values:</p> <ul> <li>Queued</li> <li>Added</li> <li>Failed</li> </ul>"},{"location":"onb_overview/enums/entitystatus/#usage","title":"Usage","text":"<p>You can inspect the return value of <code>Field.spawn</code>.</p> <pre><code>local spell = Battle.Spell.new(player:get_team())\nlocal status = player:get_field():spawn(spell, 3, 1)\n\n-- true\nprint(status == EntityStatus.Queued)\n</code></pre> <p>You are unlikely to use this value very often, because it won't give useful information  in most use cases. You should structure your code such that you know whether or not  the Entity will successfully spawn, such as ensuring you don't pass in nonsensical  coordinates.</p>"},{"location":"onb_overview/enums/entitystatus/#queued","title":"Queued","text":"<p><code>Field.spawn</code> returns <code>EntityStatus.Queued</code> if the call was made while the Field  was updating. Nearly all of your spawn calls will return this one.</p>"},{"location":"onb_overview/enums/entitystatus/#added","title":"Added","text":"<p><code>Field.spawn</code> returns <code>EntityStatus.Added</code> if the call was made while the Field  was not updating and the Entity to spawn was successfully added.</p>"},{"location":"onb_overview/enums/entitystatus/#failed","title":"Failed","text":"<p><code>Field.spawn</code> returns <code>EntityStatus.Added</code> if the call was made while the Field  was not updating and the Entity to spawn was not successfully added. This happens  if the coordinates to spawn at did not match an existing Tile, for example:</p> <p><pre><code>local spell = Battle.Spell.new(player:get_team())\nlocal status = player:get_field():spawn(spell, 100, 1)\n</code></pre> The <code>status</code> value would be <code>EntityStatus.Queued</code> if called during the update, or  <code>EntityStatus.Failed</code> otherwise.</p>"},{"location":"onb_overview/enums/highlight/","title":"Highlight","text":"<p>The <code>Highlight</code> enum describes the way a Tile should highlight.</p> <p>The following indexes are available: </p> <ul> <li>Solid</li> <li>Flash</li> <li>None</li> </ul>"},{"location":"onb_overview/enums/highlight/#usage","title":"Usage","text":"<p>Most commonly, you will call <code>Tile.highlight</code> and pass in a Highlight.</p> <pre><code>player:get_current_tile():highlight(Highlight.Solid)\n</code></pre> <p>This will cause the Tile to highlight for one frame. For a highlight that  lasts longer, you will need to call it multiple frames in a row. Because of  this, it's common to do it in some <code>update_func</code>.</p> <p>You can also call <code>Spell.highlight_tile</code> and pass in a Highlight to cause the  Spell's current Tile to be highlighted according to the Highlight every frame  automatically.</p>"},{"location":"onb_overview/enums/highlight/#solid","title":"Solid","text":"<p><code>Highlight.Solid</code> keeps the Tile lit up for every frame that it is called.</p>"},{"location":"onb_overview/enums/highlight/#flash","title":"Flash","text":"<p><code>Highlight.Flash</code> works on a global timer, so using this Highlight for only one  frame may often not light the Tile up at all. The Tile will light up for 4 frames,  then stay normal for 4 frames, and repeat.</p> <p>Because the flash highlight is on a global timer, you may start trying to highlight  in the middle of the 4-on-4-off sequence.</p> <p>If you need to have two different Flash highlights that are asynchronous, you will  need to use <code>Highlight.Solid</code> with your own timer to determine when the highlight  should be on and off.</p>"},{"location":"onb_overview/enums/highlight/#none","title":"None","text":"<p><code>Highlight.None</code> will cause there to be no highlight on the Tile.</p>"},{"location":"onb_overview/enums/highlight/#hidden-tile","title":"Hidden Tile","text":"<p>Tiles with <code>TileState.Hidden</code> as their state will never highlight.</p>"},{"location":"onb_overview/enums/highlight/#priority","title":"Priority","text":"<p>Calls to <code>Tile.set_highlight</code> for a particular Tile act as a request. If multiple  requests are made in one frame, priority is given to the largest. The highest  priority is <code>Highlight.None</code>, and the lowest is <code>Highlight.Solid</code>.</p>"},{"location":"onb_overview/enums/hit/","title":"Hit","text":"<p>The <code>Hit</code> enum makes up what I'll be calling \"hitflags\", values that are  used as signals, or flags, that certain behavior should happen on a hit. </p> <p>It contains the following values:</p> <ul> <li>None</li> <li>Flinch</li> <li>Flash</li> <li>Stun</li> <li>Root</li> <li>Impact</li> <li>Shake</li> <li>Pierce</li> <li>Retangible</li> <li>Breaking</li> <li>Freeze</li> <li>Drag</li> <li>Blind</li> <li>Confuse</li> <li>Bubble</li> <li>NoCounter</li> <li>Cancel</li> </ul> <p>Impact and Cancel are flags with extra special behavior. Be sure to read their sections.</p> <p>Statuses</p> <p>Many of the flags here inflict statuses. In the future, I may split  some of the information here to another page for statuses.</p> <p>Statuses and certain reactions to hitflags are only applied when the  attack passes all DefenseRules without being blocked. If their  <code>attack_func</code> plays, then the flags have been fully applied.</p>"},{"location":"onb_overview/enums/hit/#bits","title":"Bits","text":"<p><code>Hit</code> values are set up so that they can be used as bit flags. This means you  can use bitwise operations on them. Some of the following sections will show  some examples of using these.</p>"},{"location":"onb_overview/enums/hit/#usage","title":"Usage","text":"<p>When creating a <code>HitProps</code>, use functions with the names of the flags to add them.</p> <p><pre><code>local hit_props = HitProps.new()\n    :dmg(10)\n    :impact()\n    :from(player:get_context())\n</code></pre> (With the exception of <code>drag</code>, which actually uses the function name <code>drg</code>.)</p> <p>Or, equivalently with the the old constructor, use <code>Hit</code> enum values when setting its <code>flags</code>  field.</p> <pre><code>local hitprops = HitProps.new(\n    -- damage\n    10,\n    -- flags\n    Hit.Impact,\n    -- element\n    Element.None,\n    -- context\n    player:get_context(),\n    -- Drag\n    Drag.None\n)\n</code></pre>"},{"location":"onb_overview/enums/hit/#multiple-flags","title":"Multiple Flags","text":"<p>You will often use <code>|</code> to combine multiple flags. This is done mostly in the old  HitProps constructor, or when accessing the <code>HitProps.flags</code> field.</p> <pre><code>local hitprops = HitProps.new(\n    10,\n    Hit.Impact | Hit.Flinch | Hit.Flash,\n    Element.None,\n    player:get_context(),\n    Drag.None\n)\n</code></pre> <p>With the new <code>HitProps</code> constructor and its builder pattern, you can represent  the above as  <pre><code>local hit_props = HitProps.new()\n    :dmg(10)\n    :impact()\n    :flinch()\n    :flash()\n    :from(player:get_context())\n</code></pre></p> <p>The above HitProps will make impact, cause the hit target to flinch, and also  cause them to flash.</p>"},{"location":"onb_overview/enums/hit/#status-durations","title":"Status Durations","text":"<p>Some statuses can have a duration set. You can do this using functions from the  builder pattern: <pre><code>local hit_props = HitProps.new()\n    :dmg(10)\n    :impact()\n    :flinch()\n    :flash()\n    :stun(frames(150))\n    :from(player:get_context())\n</code></pre></p> <p>The statuses that can have a duration set, along with their defaults if none is provided,  are:</p> <ul> <li>stun (default 120 frames)</li> <li>freeze (default 150 frames)</li> <li>flash (default 120 frames)</li> <li>root (default 120 frames)</li> <li>blind (default 300 frames)</li> <li>confuse (default 110 frames)</li> <li>bubble (default 150 frames)</li> </ul>"},{"location":"onb_overview/enums/hit/#checking-for-flags","title":"Checking For Flags","text":"<p>You can use bitwise operations to inspect and manipulate hitflags.</p> <pre><code>local flags = Hit.Impact | Hit.Flinch | Hit.Flash\n\n-- If flags has Hit.Flash\nif flags &amp; Hit.Flash == Hit.Flash then\n    -- Remove Hit.Flinch\n    flags = flags &amp; ~Hit.Flinch\nend\n\n-- Another way to check if flags has Hit.Flash\nif flags | Hit.Flash == flags then \n\nend\n</code></pre>"},{"location":"onb_overview/enums/hit/#values","title":"Values","text":""},{"location":"onb_overview/enums/hit/#none","title":"None","text":"<p><code>Hit.None</code> is the <code>0</code> value. It has no other behavior. Think of this  as the absence of all other flags.</p> <p>This also means you never have to explicitly use <code>Hit.None</code> if you have  multiple flags.</p> <pre><code>-- true\nprint((Hit.None | Hit.Impact) == Hit.Impact)\n</code></pre>"},{"location":"onb_overview/enums/hit/#impact","title":"Impact","text":"<p><code>Hit.Impact</code> is an extremely important flag. When in doubt, add it! It determines a few crucial properties of an attack and how other things  tend to react to it. </p> <p>Because everything is user-generated, things may not match exactly. I'll  describe what it does in the official games as a frame of reference:</p> <p>With Impact:</p> <ul> <li>Attacks will cause the target to flash white when hit</li> <li>Damage sounds will play</li> <li>Barriers will block the attack</li> <li>Shields will play a block sound and spawn a graphic, and reflect if able</li> <li>Damage dealt will be tallied for the Damage Judge to determine a winner when  the round's time runs out</li> </ul> <p>Put another way, Impact is used for attacks that really hit someone. Swords,  fire attacks, bombs, etc. all use Impact. They may be blocked by defenses.</p> <p>Attacks without Impact are often things that act as \"HP drains\". Anubis and  GunDelSol are examples of these. Shield still blocks them, but they go through  AntiDamage and Barriers.</p> <p>When creating mods that react to damage, take care in checking for <code>Hit.Impact</code>  where appropriate.</p>"},{"location":"onb_overview/enums/hit/#flinch","title":"Flinch","text":"<p><code>Hit.Flinch</code> causes Players to enter their \"PLAYER_HIT\" animation state. Many  attacks use this, but not all. It's common to strip it away using the SuperArmor  NaviCust Part in the official games.</p> <p>Missing Info</p> <p>This notice will be removed once I check what the duration of the flinch animation is. It's somewhere around 18-24f.</p>"},{"location":"onb_overview/enums/hit/#flinching-enemies","title":"Flinching Enemies","text":"<p>Characters that are not Players do not inherently have any reaction to <code>Hit.Flinch</code>. When programming enemies which should flinch, such as Navi bosses, you will need  to handle flinching yourself.</p>"},{"location":"onb_overview/enums/hit/#flash","title":"Flash","text":"<p><code>Hit.Flash</code> causes the hit Entity to become intangible for some time, while their  sprite flickers between visible and invisible. Viruses and objects in the official  games often strip this flag when hit.</p> <p>While an Entity is intangible because of this flag, we say that they are \"flashing\". The default duration is 120 frames, but can use custom durations.</p> <p>While flashing, an Entity is intangible. Attacks will not make collision unless they  have the <code>Hit.Pierce</code> flag. If they don't collide, the attack's <code>collision_func</code> will  not play and no damage will be done. DefenseRules with the <code>CollisionOnly</code> DefenseOrder also will not have their <code>can_block_func</code> play.</p>"},{"location":"onb_overview/enums/hit/#stun","title":"Stun","text":"<p><code>Hit.Stun</code> causes the hit Entity to become stunned. This will prevent them from making  actions for a period of time, and their sprite will flash yellow. CardActions that are  currently in use will immediately end, and any which are queued will be discarded. Objects in the official games strip this flag when hit.</p> <p>Stun lasts 120 frames by default, but can use custom durations. </p> <p>Stun can be cancelled early by an attack that flinches and flashes, or by an attack that  adds Freeze or Confuse. If Drag is active, being hit by another Drag attack will end Stun.</p> <p>Counter</p> <p>Being counterhit will also stun. Being stunned in this way will have a duration  of 150 frames instead, no matter what the original attack had as the duration.</p> <p>Stun Duration</p> <p>In the official games, stuns often have different durations. For example, Thunder  stuns for 90 frames, JudgeMan stuns for 120 frames, and FlashBomb2 stuns for 150  frames. </p>"},{"location":"onb_overview/enums/hit/#root","title":"Root","text":"<p><code>Hit.Root</code> causes the hit Entity to become rooted to the spot. This will prevent them  from moving, and their sprite will flash black. Objects in the official games strip this flag when hit. Another name used for the inflicted status is \"immobilze\", but I will be  using \"Root\" to match the code.</p> <p>Root lasts 120 frames by default, but can use custom durations. It will be cancelled early if the  Entity is intangible, such as after being hit by an attack that flashes.</p> <p>Root Over Holes</p> <p>In the official games, the Root status cannot be applied to an Entity whose Tile is a hole. This is not the case in v2.1. </p> <p>Missing Info</p> <p>This notice will be removed when I confirm exactly how Root interacts with  MoveEvents. Do they fail to queue, or only fail to update? What happens if  you are rooted mid-movement?</p>"},{"location":"onb_overview/enums/hit/#shake","title":"Shake","text":"<p><code>Hit.Shake</code> causes a hit Entity's sprite to shake quickly. In the official games,  this is seen whenever damage is dealt while time is frozen.</p> <p>Shake is automatically applied to hits that happen during time freeze. If aiming  for official game accuracy, this flag should never be manually applied by your  code.</p>"},{"location":"onb_overview/enums/hit/#pierce","title":"Pierce","text":"<p><code>Hit.Pierce</code> signals that an attack should pierce intangibility. This bypasses the  intangibility granted by the flashing status and allows a collision and damage.</p> <p>Because it's just a flag, be sure to check for it when you make certain intangible effects. For example, a recreation of the Invis chip from the official games should allow attacks  with <code>Hit.Pierce</code> to deal damage.</p> <p>Other Pierces</p> <p>There are other forms of intangibility found across the BN series. PopUp, from BN3,  should be pierced by a flag different from the one that pierces Invis and flashing.  This is not handled in v2.1. Future versions will have more flags and renamed flags  for more clarity.</p>"},{"location":"onb_overview/enums/hit/#retangible","title":"Retangible","text":"<p><code>Hit.Retangible</code> signals that an attack should remove intangibility. This will typically  be paired with <code>Hit.Pierce</code>. This will remove the flashing status.</p> <p>When an attack has <code>Hit.Retangible</code> and <code>Hit.Flash</code>, expect intangible effects to end  and then for the flashing status to be applied after.</p> <p>Because it's just a flag, be sure to check for it when you make certain intangible effects. For example, a recreation of the Invis chip from the official games should end its effect  when hit by a Retangible attack.</p>"},{"location":"onb_overview/enums/hit/#breaking","title":"Breaking","text":"<p><code>Hit.Breaking</code> signals that an attach should go through certain guards, destroy certain  objects, and deal additional damage to a frozen Entity.</p> <p>Following official games, every attack with the Break element should have this flag. Many  objects are destroyed instantly, but not necessarily all of them, and some have special  reactions to it. When in doubt, you will likely want to allow them to be destroyed by the  Breaking flag.</p> <p>Because it's just a flag, be sure to check for it based on the mod. A recreation of the  Reflect chip from the official games should not block attacks with this flag, and a recreation  of RockCube should be instantly destroyed by an attack with this flag. </p> <p>Breaking Vs. Break</p> <p>A common misconception is that the Break element has the properties described above. In reality, the Break element on its own has no extra behavior; all Break element  attacks just so happen to have the <code>Hit.Breaking</code> flag.</p> <p>Many other attacks in the series have this flag while not being Break element. See  Sensor (Elec), EraseMan (Cursor), the charge shot used by ChargeCross (Fire), the  DustMan chip (Null), and more.</p>"},{"location":"onb_overview/enums/hit/#freeze","title":"Freeze","text":"<p><code>Hit.Freeze</code> causes an attack to inflict the Freeze status. This will prevent the target  from taking actions, and their Sprite will be lightened and have ice fragments overlaid.  CardActions that are currently in use will immediately end, and any which are queued will  be discarded.</p> <p>The Freeze status lasts for 150 frames by default, but can use custom durations. It will  be ended early when being hit by an attack with the <code>Hit.Breaking</code> flag, or an attack which  flinches and flashes. It will also end early if it is replaced by the Stun, Bubble, Drag or  Confuse statuses. Objects in the official games are immune to this status.</p> <p>If an attack would Freeze, it will not cause Flashing.</p> <p>This flag is rarely, if ever, used on attacks in the official games. ElementMan Ice and FreezeBomb,  from BN2, may be the only possible examples, though BN2 treated the status differently. When deciding to use it or not, keep in mind that the Freeze status is a very powerful  one, and much stronger than Stun.</p> <p>Ice Panel Freeze</p> <p>The Freeze status can also be inflicted on an Entity if they take damage from an Aqua  attack while standing on an Ice panel. When freeze is inflicted in this way, it  does so by adding the <code>Hit.Freeze</code> flag to the attack.</p>"},{"location":"onb_overview/enums/hit/#drag","title":"Drag","text":"<p><code>Hit.Drag</code> causes the hit Entity to be forced into movement. This also inflicts the  Drag status. Their current CardAction, if any, will immediately end, and any that are  queued will be discarded.</p> <p>If a <code>Drag</code> is not defined in the <code>HitProps</code>, this flag will effectively do nothing.  Using a <code>Drag</code> with <code>Direction.None</code>, including <code>Drag.None</code>, as its movement direction will  not cause any of the above described behavior. Negative distances will be treated as positive.</p> <p>While under the Drag status, other statuses and reactions to certain hit flags will be continually requeued, only finally applying properly once the status ends. For example,  if a Character is under the Drag status, they can be hit by an attack with the Flinch,  Flash, and Stun flags, and they will not flinch, start flashing, or be stunned until the  Drag finishes.</p> <p>Drag will continue to last several frames after movement stops. This means there is still  time after movement stops where statuses are queued and not yet taking effect, and the  Entity still cannot move or attack.</p> <p>If Freeze or Bubble are applied at the same time as Drag, they will not apply, even after  Drag ends. If Freeze, Bubble, or Stun are queued during Drag, but on a different frame than  the Drag attack, they can be unqeueued by a Drag attack landing before the first Drag ends.</p>"},{"location":"onb_overview/enums/hit/#drag-movement","title":"Drag Movement","text":"<p>The way Drag moves an Entity is described by the final parameter of <code>HitProps</code>, the  <code>Drag</code>. If an attack will not do any movement, <code>Drag.None</code> can be used. Otherwise,  use <code>Drag.new</code> and pass in a Direction to move in and a number of Tiles  to travel. Movement will be extended if an Entity slides onto an Ice Tile.</p> <p><pre><code>local facing = player:get_facing()\nlocal hit_props = HitProps.new()\n    :dmg(10)\n    :impact()\n    :flinch()\n    :flash()\n    -- Push 1 Tile in the direction of `facing`\n    :drg(Drag.new(facing, 1))\n    :from(player:get_context())\n</code></pre> Or, equivalently with the old constructor,  <pre><code>local hitprops = HitProps.new(\n    10,\n    Hit.Impact | Hit.Flinch | Hit.Flash,\n    Element.None,\n    player:get_context(),\n    -- Push 1 Tile in the direction of `facing`\n    Drag.new(facing, 1)\n)\n</code></pre></p> <p>Typically, you will use the facing Direction of the one creating the attack. Prefer using  relative Directions like this, as in other places. If <code>Direction.None</code> is used, or the distance  to travel is 0, no movement will occur and the <code>Hit.Drag</code> flag will effectively do nothing. Negative distances will be treated as positive.</p> <p>The movement from Drag is a MoveEvent which completes in 4 frames, using <code>ActionOrder.Immediate</code>.  Another movement will be made until the entire distance has been travelled or the next Tile cannot be  moved to, at which point the endlag begins.</p>"},{"location":"onb_overview/enums/hit/#common-distances","title":"Common Distances","text":"<p>In the official games, only two Drag distances are used: 1 panel, or the entire field. The Field  considers itself 6 Tiles long, and because movement ends when the Entity can no longer move, and  an Entity usually cannot move off onto the edges, something like the below code will do fine  to push across the entire Field, but it may leave something to be desired.</p> <pre><code>local facing = player:get_facing()\nDrag.new(facing, 6)\n</code></pre> <p>Suppose, someday, the Field in ONB is allowed to be longer than 6 Tiles. Then the above code will  not hold up. Instead, you should consider using <code>Field.width</code> to determine how far to push.</p> <pre><code>local facing = player:get_facing()\nlocal field = player:get_field()\nDrag.new(facing, field:width())\n</code></pre>"},{"location":"onb_overview/enums/hit/#interactions-with-objects","title":"Interactions with Objects","text":"<p>In the official games, Drag has a number of special interactions when hitting objects. Here are  some examples:</p> <ul> <li>RockCube will slide until it can't move to the next panel even if the Drag would normally  only move 1 space. See AirShot hitting RockCube.</li> <li>The big rock, which spawns on some fields, will not be moved at all by Drag.</li> <li>RockCube does not take damage from attacks that Drag, while something like BlkBomb does.</li> </ul>"},{"location":"onb_overview/enums/hit/#blind","title":"Blind","text":"<p><code>Hit.Blind</code> causes the hit Entity to become blinded. An icon will be drawn over them. Players who are Blind will be unable to see Obstacles and Characters which are not on  their Team. </p> <p>The Blind status lasts 300 frames by default, but can use custom durations. </p> <p>Blind Enemies</p> <p>In official games, enemies with the Blind status behave differently than normal. Another page will have information on how the games tend to handle this.</p> <p>In ONB, naturally, we need to check for a Blind status and change logic based on it  to have this behavior. This can be done using <code>Entity.is_blind</code>.</p> <p>Missing Info</p> <p>This notice will be removed once I have confirmed where the Blind icon is drawn. Is it  on the \"head\" point of an animation frame, or around the height set by <code>Entity.set_height</code>?</p>"},{"location":"onb_overview/enums/hit/#confuse","title":"Confuse","text":"<p><code>Hit.Confuse</code> causes the hit Entity to become Confused. An swirling duck animation will be drawn  over them. Players who are confused will have their movement directions reversed.</p> <p>The Confuse status lasts 110 frames by default, but can use custom durations.</p> <p>If Confuse is applied, it will end Stun, Freeze, or Bubble. These statuses will also overwrite  Confuse if they are applied while Confuse is active. If Confuse is applied at the same time  as any of these statuses, Confuse will not be applied.</p> <p>Confused Enemies</p> <p>In official games,enemies with the Confuse status behave different than normal. Another page will have information on how the games tend to handle this.</p> <p>In ONB, naturally, we need to check for a Confuse status and change logic based on it  to have this behavior. This can be done using <code>Entity.is_confused</code>.</p> <p>Missing Info</p> <p>This notice will be removed once I have confirmed where the Confuse animation is drawn. Is it  on the \"head\" point of an animation frame, or around the height set by <code>Entity.set_height</code>?</p>"},{"location":"onb_overview/enums/hit/#bubble","title":"Bubble","text":"<p><code>Hit.Bubble</code> causes the hit Entity to become Bubbled. The Entity will have a bubble drawn around  them, and they will float up and down. Players will play their first Flinch animation frame for  the duration.</p> <p>The Bubble status lasts for 150 frames by default, but can use custom durations. It will be  ended early by any attack with the <code>Hit.Impact</code> flag. If an <code>Element.Elec</code> attack hits an  Entity while it is Bubbled, the attack will do bonus damage.</p> <p>If Stun, Freeze, or Drag are applied at the same time, Bubble will not be applied.</p> <p>Odd BubbleStar</p> <p>BubbleStar behaves very oddly in the original games, where, when hitting on ice, it will  cause Bubble status only if hitting pointblank. Otherwise, it will freeze instead of bubbling.</p> <p>BubbleWrap</p> <p>The BubbleWrap chip in the original games has a similar weakness to Bubble, and can stack  with the Elec weakness. Capcom was smart and made it so BubbleWrap would stop ticking its  regeneration counter if you were Bubbled, to likely prevent cases where the BubbleWrap could come back and cause you to take extraordinary damage while Bubbled.</p> <p>This can be replicated in ONB by using <code>Entity.is_bubbled</code> to decide whether or not to tick  the regeneration counter.</p>"},{"location":"onb_overview/enums/hit/#nocounter","title":"NoCounter","text":"<p><code>Hit.NoCounter</code> makes an attack unable to counterhit. </p> <p>This flag is automatically added to attacks made during time freeze, and to attacks made by a  Player performing their <code>charged_attack_func</code> or <code>normal_attack_func</code>.</p>"},{"location":"onb_overview/enums/hit/#cancel","title":"Cancel","text":"<p><code>Hit.Cancel</code> is a special flag, not intended to be used by attacks (but if you do add it to your  attacks, there will be no change). The flag is automatically added during to an attack's HitProps  during hit checks, and the original HitProps are restored after hit checks. </p> <p>If the <code>Hit.Cancel</code> flag is still present after defenses, and the attack will apply Stun, Freeze,  Bubble, Drag, or Flinch, the Cancel is allowed to process. Otherwise, it will be dropped.</p> <p>In the case <code>Hit.Cancel</code> processes, the hurt Entity's CardActions, action queue, and movement will  be cleared and cancelled. </p> <p>This is completely normal for Players and Navi-like enemies, and you don't have to do anything about  it. But for enemies like viruses, which don't flinch or get their attacks interrupted by any of these  flags in the original games, you may want to have a DefenseRule that strips the <code>Hit.Cancel</code> flag. The <code>DefenseVirusBody</code> Defense, created by <code>Battle.DefenseVirusBody.new()</code>, will strip the <code>Hit.Cancel</code>  flag, but any DefenseRule can.</p>"},{"location":"onb_overview/enums/input/","title":"Input","text":"<p>There are three sets of Input values:</p> <ol> <li>Pressed</li> <li>Held</li> <li>Released</li> </ol> <p>The following indexes are on each of them:</p> <ul> <li>Use</li> <li>Shoot</li> <li>Special</li> <li>Left</li> <li>Right</li> <li>Up</li> <li>Down</li> <li>Left_Shoulder</li> <li>Right_Shoulder</li> </ul> <p>Access by using Input, one of the three types, and then one of the inputs.</p> <pre><code>Input.Pressed.Use\nInput.Held.Shoot\nInput.Released.Special\n</code></pre>"},{"location":"onb_overview/enums/input/#usage","title":"Usage","text":"<p>Input enum values are only used as the parameter for <code>Player.input_has</code>.  Its usage is described on the Player page.</p>"},{"location":"onb_overview/enums/lifetimes/","title":"Lifetimes","text":"<p>The <code>Lifetimes</code> enum is used as a specifier for the update behavior of a  Component. Specifically, they decide the battle state required in order  for it to update, as well as the moment within a game frame that it will update.</p> <p>It has the following values:</p> <ul> <li>Local</li> <li>Battlestep</li> <li>Scene</li> </ul>"},{"location":"onb_overview/enums/lifetimes/#usage","title":"Usage","text":"<p>A <code>Lifetimes</code> is used when creating a Component.</p> <pre><code>local component = Battle.Component.new(player, Lifetimes.Local)\n\nplayer:register_component(component)\n</code></pre> <p>When talking about a Component, I will often say that it is a Local  Component, or a Battlestep Component, etc., indicating which <code>Lifetimes</code>  was used in its creation.</p>"},{"location":"onb_overview/enums/lifetimes/#differences","title":"Differences","text":""},{"location":"onb_overview/enums/lifetimes/#local","title":"Local","text":"<p>A Local Component's <code>update_func</code> runs during an Entity's update steps,  after their <code>update_func</code> runs. If the Entity will not update that frame,  such as when time is frozen, neither will the Component.</p> <p>Usually, an Entity will only update during the battle startup period (before the Custom Screen opens) and during the turn while time is not  frozen.</p> <p>Note that an Entity's <code>update_func</code> will not be called while the Entity  is stunned, but a Local Component will still be updated on that frame.</p>"},{"location":"onb_overview/enums/lifetimes/#battlestep","title":"Battlestep","text":"<p>A Battlestep Component's <code>update_func</code> runs near the end of the game frame,  after all Entities and Tiles on the Field have updated. The <code>update_func</code>  will only be called during the turn, while time is not frozen.</p> <p>Battlestep Components are updated in tandem with Scene Components, so a  Battlestep Component registered before a Scene Component will update first,  and vice versa.</p>"},{"location":"onb_overview/enums/lifetimes/#scene","title":"Scene","text":"<p>A Scene Component's <code>update_func</code> runs near the end of the game frame,  after all Entities and Tiles on the Field have updated. The <code>update_func</code>  will be called every frame. Scene Components are the only Components that  always update.</p>"},{"location":"onb_overview/enums/lifetimes/#choosing","title":"Choosing","text":"<p>Choose the <code>Lifetimes</code> to use taking into account the effect you want to  achieve. You should think of this in terms of when the update will happen,  and if that timing is appropriate for the effect.</p>"},{"location":"onb_overview/enums/lifetimes/#local-vs-battlestep","title":"Local vs. Battlestep","text":"<p>A lot of the ideas you think of that could fit a Local Component might also  fit a Battlestep Component, and vice versa. Even if the logic may play out  similarly, there could be subtle differences in practical behavior based  on which you choose. Below are some examples that highlight these.</p>"},{"location":"onb_overview/enums/lifetimes/#example-field-checks","title":"Example: Field Checks","text":"<p>You may want to use a Component to check for certain Entities, or maybe  TileStates, on the Field. </p> <p>With a Local Component, the update may be running before some other Entities  have updated, and before other logic during the frame has completed. By using  a BattleStep Component instead, the update will run closer to the end of the  frame and would be more likely to pick up on more changes that happened during  the frame.</p> <p>Say you wanted to do something similar to ColonelSoul's ability in BN5, which  causes objects to turn into soldiers. This would require you to observe the Field,  remove certain Entities, and spawn new ones.</p> <p>With a Local Component, the soldiers would spawn on the same frame you checked  the Field, but any objects that spawned on the same frame would not have spawned  in time for you to catch them in a Field check. With a Battlestep Component, you  can catch the objects that were spawned that frame, but your new spawns will not  appear until the end of the next frame.</p>"},{"location":"onb_overview/enums/lifetimes/#example-hp-bug","title":"Example: HP Bug","text":"<p>Effects like an HP Bug could be a Local or Battlestep Component, because then  HP wouldn't drop during Custom or time freeze. </p> <p>Recall that HP Bugs in the official games do not delete you, but stop draining  when you are at 1 HP. Here's a scenario where it can be game-changing to do  this using a Local or Battlestep Component, due to the difference in when  during the frame they update:</p> <ul> <li>You are at 2 HP, and when you update this frame your HP will drop to 1.</li> <li>A Spell's update this frame will attack your Tile.</li> </ul> <p>With a Local Component, you will update, drop to 1 HP, then get hit by the Spell  and be deleted. With a Battlestep Component, you will update, get hit by the Spell  and possibly fall to 1 HP (if you had UnderShirt installed, or the attack did 1 damage),  and then the Component updates and does not drop HP because you are at 1 HP. You  survive.</p> <p>Disclaimer</p> <p>I don't know how this scenario will end in the official games. You will need to do  extra research to get things like this right, if you are aiming for accuracy.</p>"},{"location":"onb_overview/enums/lifetimes/#scene_1","title":"Scene","text":"<p>Scene Components are not used as often, because most effects' logic should not  run all the time. </p> <p>Somewhere you might use a Scene Component comes from a special case with Barriers. Barriers animate during time freeze. Since the graphic should be added as a  SpriteNode, it would only animate during time freeze if its animation update was handled by a Scene Component's update.</p> <p>Because Scene Components also update during Custom and the Barrier should not  animate during Custom (except the first Custom screen), a few extra updates  using other Components or Entities can be used to determine that Custom is open  and avoid updating the animation.</p>"},{"location":"onb_overview/enums/locktype/","title":"LockType","text":"<p>The <code>LockType</code> enum describes the condition under which a CardAction will be  considered complete. </p> <p>It has the following indexes:</p> <ul> <li>Animation</li> <li>Async</li> <li>Sequence</li> </ul> <p>The default is <code>LockType.Animation</code>.</p>"},{"location":"onb_overview/enums/locktype/#usage","title":"Usage","text":"<p>You will never use the LockType enum on its own. Instead, you will use a  series of related functions to set the type on the CardAction. These  functions refer to these types as a \"lockout\", but don't confuse them with  another enum, <code>Lockout</code>.</p>"},{"location":"onb_overview/enums/locktype/#animation","title":"Animation","text":"<p>The CardAction will end when the associated Animation ends. This is the  default, so you are unlikely to ever set this. But if you wanted to, you  can use <code>make_animation_lockout</code>.</p> <pre><code>local action = Battle.CardAction.new(player, \"PLAYER_IDLE\")\naction:set_lockout(make_animation_lockout())\n</code></pre>"},{"location":"onb_overview/enums/locktype/#async","title":"Async","text":"<p>The CardAction will do cleanup, free the user, and call its <code>CardAction.action_end_func</code>  when the associated Animation ends, but it will continue calling its <code>CardAction.update_func</code>  until a specified amount of time passes based on the value given to the Async lockout.</p> <p>For example, see the code below:</p> <pre><code>local action = Battle.CardAction.new(player, \"PLAYER_IDLE\")\naction:set_lockout(make_async_lockout(0.5))\n</code></pre> <p><code>make_async_lockout</code> is called with a time in milliseconds. The above code gives 0.5 (30 frames).</p> <p>Once the <code>PLAYER_IDLE</code> animation finishes, <code>action</code> will continue updating for 30 frames.</p>"},{"location":"onb_overview/enums/locktype/#lockout","title":"Lockout","text":"<p>The Async LockType's timer has an additional effect. Until it expires, CardActions of the associated  LockoutGroup will not be performed.</p> <p>Missing Info</p> <p>This notice will be removed once I figure out if the CardAction is still queued or if it will  only be discarded once it should begin waiting to execute.</p>"},{"location":"onb_overview/enums/locktype/#sequence","title":"Sequence","text":"<p>Instead of ending when the animation ends, the CardAction will end when all  of its Steps have completed. </p> <pre><code>local action = Battle.CardAction.new(player, \"PLAYER_IDLE\")\naction:set_lockout(make_sequence_lockout())\n</code></pre> <p>You should add Steps afterwards. </p> <pre><code>local step = Battle.Step.new()\nstep.update_func = function(self)\n    self:complete_step()\nend\n\naction:add_step(step)\n</code></pre> <p>The above Step will complete itself on its first update. In this example, because  it's the only Step, the CardAction will then end. If another Step had been added,  that Step would begin updating on the next frame.</p> <p>Action Immediately Ends</p> <p>If you set a Sequence lockout but didn't add any Steps, the CardAction  will end immediately. This is a common mistake when setting up Sequence  lockout actions.</p>"},{"location":"onb_overview/enums/playback/","title":"Playback","text":"<p><code>Playback</code> enum values describe how an Animation should play. </p> <p>It has the following indexes:</p> <ul> <li>Once</li> <li>Loop</li> <li>Bounce</li> <li>Reverse</li> </ul> <p>The default for an Animation is <code>Playback.Once</code>. </p>"},{"location":"onb_overview/enums/playback/#usage","title":"Usage","text":"<p>You can set an Animation's Playback type using <code>Animation.set_playback</code>.</p> <pre><code>local artifact = Battle.Artifact.new()\nlocal anim = artifact:get_animation()\nanim:set_playback(Playback.Loop)\n</code></pre> <p>Calling <code>Animation.set_state</code> will revert any Playback setting back to <code>Playback.Once</code>. If you want to set state and set Playback, be sure to call <code>Animation.set_state</code> before  <code>Animation.set_playback</code>.</p>"},{"location":"onb_overview/enums/playback/#once","title":"Once","text":"<p>The default Playback for an Animation is <code>Playback.Once</code>. With this, an Animation  will play once and then stop.</p> <p>Completion callbacks will run on the game frame that the animation's last keyframe  finishes its duration.</p>"},{"location":"onb_overview/enums/playback/#loop","title":"Loop","text":"<p><code>Playback.Loop</code> will cause an Animation to restart once it reaches its end.</p> <p>Completion callbacks run at a similar time to <code>Playback.Once</code>, but will play again  at the end of each loop. <code>on_frame</code> callbacks will also run again each loop, unless  <code>Animation.on_frame</code> was called with <code>true</code> as the last parameter.</p> <p>Repeated Callbacks</p> <p>While looping, completion callbacks may run an additional time one game frame after  it runs. <code>on_frame</code> callbacks may also run again all at once when the loop happens.</p> <p>Extra Callbacks</p> <p>While looping, an <code>on_frame</code> callback set for the keyframe number that is one higher  than the Animation's final keyframe may run when the loop happens.</p> <p>Duplicate Frames</p> <p>If you have two callbacks registered for the same frame, the second one may run  on a different game frame than the first.</p>"},{"location":"onb_overview/enums/playback/#bounce","title":"Bounce","text":"<p><code>Playback.Bounce</code> will cause an Animation to play until its end, then start playing in  reverse.</p> <p>No Bounce</p> <p><code>Playback.Bounce</code> may not function properly in v2.1.</p>"},{"location":"onb_overview/enums/playback/#reverse","title":"Reverse","text":"<p><code>Playback.Reverse</code> will cause an Animation to start on its last frame and play until  it reaches the first frame, and then stop.</p> <p>When using this Playback, <code>on_frame</code> callbacks will not play in reverse. In other words,  the first frame to play will still call the <code>on_frame</code> callbacks for frame 1. The Animation  still proceeds from frame 1 to frame 2, but frame 1 is the last animation frame, and frame 2  is the second to last animation frame, and so on.</p> <p>Completion callbacks will run on the game frame that the animation's last keyframe  finishes its duration.</p>"},{"location":"onb_overview/enums/rank/","title":"Rank","text":"<p>The Rank enum is used when creating a Character. These mostly cover the  \"versions\" you see in the official games:</p> <ul> <li>V1</li> <li>V2</li> <li>V3</li> <li>SP</li> <li>EX</li> <li>Rare1</li> <li>Rare2</li> <li>NM</li> </ul> <p>NM is an original Rank, which stands for \"Nightmare\". Future engine versions  will add more Ranks.</p> <p>Despite \"EX\" having a higher number than \"SP\", remember that SP is a higher  rank in the official games.</p>"},{"location":"onb_overview/enums/rank/#usage","title":"Usage","text":"<p>Rank does nothing on its own, but can be read from the <code>package_init</code> of a  Character to branch logic, which can be helpful for setting different stats,  palettes, behavior, etc.</p> <pre><code>function package_init(character)\n    local rank = character:get_rank()\n\n    --[[\n        Adds a \"damage\" index on `character`, which this code will \n        read later when creating HitProps.\n    ]] \n    if rank == Rank.V1 then \n        character:set_health(40)\n        character.damage = 10\n    elseif rank == Rank.V2 then \n        character:set_health(60)\n        character.damage = 20\n    else\n        print(\"Unhandled Rank: \"..rank)\n        character:set_health(1)\n        character.damage = 10\n    end\nend\n</code></pre> <p>Make sure your Character has stats set for any Rank. The above code does  it with an <code>else</code> as a catch-all, but you can also set stats earlier in the  code and then change them with each Rank.</p> <p>If you don't set health, the Character may not appear in battle.</p> <p>I will also reiterate that the <code>damage</code> index in the above code is not an  official convention or supported index that does anything on its own. If  you add one, you would need to read it later when you write other logic.</p>"},{"location":"onb_overview/enums/shadow/","title":"Shadow","text":"<p>Entities can have a shadow appear under them. Often this is done by having  the shadow be part of the spritesheet, but ONB also supports setting a different  one using <code>Entity.set_shadow</code>, which will stay on the ground when you change the  Entity's elevation.</p> <p>Using the <code>Shadow</code> enum, you can access shadow textures that are included in the  engine, or remove one you have set. This includes the following:</p> <ul> <li>None</li> <li>Small</li> <li>Big</li> </ul> <p>By default, <code>Shadow.None</code> is used.</p>"},{"location":"onb_overview/enums/shadow/#usage","title":"Usage","text":"<p>Set a shadow by giving a Shadow value to <code>Entity.set_shadow</code>, and then call  <code>Entity.show_shadow</code> with a value of <code>true</code> to see it.</p> <pre><code>local artifact = Battle.Artifact.new()\nartifact:set_shadow(Shadow.Small)\nartifact:show_shadow(true)\n</code></pre>"},{"location":"onb_overview/enums/team/","title":"Team","text":"<p>All Entities have a Team, which decides what they can be attacked by  and what they can attack.</p> <p>There are three indexes:</p> <ul> <li>Red</li> <li>Blue</li> <li>Other</li> </ul>"},{"location":"onb_overview/enums/team/#usage","title":"Usage","text":"<p>You will usually pass a Team in when creating an Entity.</p> <pre><code>local spell = Battle.Spell.new(Team.Other)\n</code></pre> <p>It's uncommon to refer to a direct value. Similar to Direction, you  will usually want to use a Team relative to another Entity's Team. For  example:</p> <pre><code>function create_spell(player)\n    local spell = Battle.Spell.new(player:get_team())\n    spell:set_facing(player:get_facing())\nend\n</code></pre> <p>This function will create a Spell that can hit <code>player</code>'s enemies (Characters  and Obstacles not on the same Team).</p> <p>Another common use is to find Entities which are not on a certain Team.</p> <pre><code>local field = player:get_field()\nlocal team = player:get_team()\n\nlocal all_enemies = field:find_characters(function(ent)\n    return ent:get_team() ~= team\nend)\n</code></pre>"},{"location":"onb_overview/enums/tilestate/","title":"TileState","text":"<p><code>TileState</code> describes the state a Tile is in, and also affects its behavior  and other Entities' and attacks' interactions with it.</p> <p>The following TileStates are available:</p> <ul> <li>Broken</li> <li>Cracked</li> <li>DirectionDown</li> <li>DirectionLeft</li> <li>DirectionRight</li> <li>DirectionUp</li> <li>Empty</li> <li>Grass</li> <li>Hidden</li> <li>Holy</li> <li>Ice</li> <li>Lava</li> <li>Normal</li> <li>Poison</li> <li>Volcano</li> <li>Sea</li> <li>Sand</li> <li>Metal</li> </ul> <p>The default TileState is <code>TileState.Normal</code>.</p>"},{"location":"onb_overview/enums/tilestate/#usage","title":"Usage","text":"<p>You can change a Tile's state using <code>Tile.set_state</code>. </p> <p><pre><code>local tile = player:get_current_tile()\ntile:set_state(TileState.Ice)\n</code></pre> You can inspect the current state of a Tile using <code>Tile.get_state</code>.</p> <pre><code>print(player:get_current_tile():get_state() == TileState.Normal)\n</code></pre> <p>Edge Tiles cannot have their state set. </p>"},{"location":"onb_overview/enums/tilestate/#broken","title":"Broken","text":"<p>A Tile with the <code>TileState.Broken</code> state cannot be stepped on by Players  who do not have AirShoes. </p> <p>A Broken Tile will revert to <code>TileState.Normal</code> after 10 seconds (600 frames).  Setting <code>TileState.Broken</code> on a Tile that is already broken will refresh its timer.</p> <p>Trying to set <code>TileState.Broken</code> on a Tile which has Obstacles or Characters on it  will fail. </p>"},{"location":"onb_overview/enums/tilestate/#cracked","title":"Cracked","text":"<p>A Tile with the <code>TileState.Cracked</code> state will change to <code>TileState.Broken</code> when  a Character which does not have FloatShoes steps off it.</p> <p>AirShoes</p> <p>In v2.1, a Character which has AirShoes will also prevent the Tile from breaking. This will not be the case in future versions.</p> <p>Missing Info</p> <p>Obstacles may be affected as well. This notice will be removed once I have confirmed.</p> <p>A Tile that is in the <code>TileState.Broken</code> or <code>TileState.Empty</code> states cannot be set to  Cracked.</p>"},{"location":"onb_overview/enums/tilestate/#directions","title":"Directions","text":"<p>Tiles with <code>TileState.DirectionDown</code>, <code>TileState.DirectionLeft</code>, <code>TileState.DirectionRight</code>, or <code>TileState.DirectionUp</code> states will move an Obstacle or Character in that direction when it  steps onto it. Having FloatShoes will exempt the Entity from this movement.</p> <p>AirShoes</p> <p>In v2.1, having AirShoes will also prevent the movement. This will not be the case in  future versions.</p> <p>The movement is an Involuntary MoveEvent that completes in 3 frames.</p> <p>These types of Tiles might also be called \"conveyor panels\" by some BN players. They're created  by ComingRoad and GoingRoad in BN6.</p>"},{"location":"onb_overview/enums/tilestate/#empty","title":"Empty","text":"<p>Tiles with <code>TileState.Empty</code> are simliar to <code>TileState.Broken</code> in effect, with the exception  that it does not revert to <code>TileState.Normal</code>. </p> <p>These types of Tiles might also be called \"perma-holes\" by some BN players, because they are always a hole. Traditionally, these Tiles cannot be taken by the other Team, and they can never  be set to a different TileState. This is not the case in ONB. If you want to make your mods  feel more like BN, you should often check for this TileState.</p>"},{"location":"onb_overview/enums/tilestate/#grass","title":"Grass","text":"<p>Tiles with <code>TileState.Grass</code> will add damage after a Fire element attack hits an Entity on that  Tile. If a Fire element attack is made on the Tile, the Tile will revert to <code>TileState.Normal</code>,  regardless of whether or not the attack dealt damage. </p> <p>A WoodBody Character will heal slowly over time while standing on a Grass Tile. The speed of healing is 1 HP per 20 frames, or 1 HP per 180 frames while the Character has less than 10 HP.</p>"},{"location":"onb_overview/enums/tilestate/#hidden","title":"Hidden","text":"<p>A Tile with <code>TileState.Hidden</code> will not be drawn. You can see this in the official games during  the fights with Duo, Nebula Gray, and Falzar.</p> <p>Hidden Tiles are not walkable. They cannot change Team, and a Tile with <code>TileState.Hidden</code> cannot  change states to any other state. They will be Hidden forever. They also cannot be highlighted.</p>"},{"location":"onb_overview/enums/tilestate/#holy","title":"Holy","text":"<p>Entities standing on Tiles with the <code>TileState.Holy</code> state will take reduced damage from attacks.</p> <p>Damage is halved and rounded up after all DefenseRules have run their <code>can_block_func</code>.</p> <p>Damage and Impact</p> <p>Typically, attacks that lack the <code>Hit.Impact</code> flag will not have their damage reduced by  Holy Tiles. In v2.1, they will still have their damage reduced.</p> <p>'Holy Aura' Strategy</p> <p>A well-known strategy in the official games involves using a LifeAura combined with a  Holy panel to require a very high damage value to destroy the Aura. This behavior will  typically not be seen in ONB mods as of v2.1 because of the timing of damage reduction from Holy Tiles.</p>"},{"location":"onb_overview/enums/tilestate/#ice","title":"Ice","text":"<p>Tiles with the <code>TileState.Ice</code> state will move any Entity when they step onto it in the same  direction that they were moving in. For example, if the Entity moved to the right to step  onto it, they would continue sliding right. The Entity will continue to slide until they  land on a Tile with a different state, or the next Tile is inaccessible according to their  <code>can_move_to_func</code>.</p> <p>Entities that have FloatShoes or are AquaBody will not slide.</p> <p>The slide is a MoveEvent that takes 4 frames to complete.</p> <p>If an attack hits an Ice Tile, it will have <code>Hit.Freeze</code> added to it.</p>"},{"location":"onb_overview/enums/tilestate/#lava","title":"Lava","text":"<p>A Character or Obstacle that stands on a Tile with the <code>TileState.Lava</code> state will be damaged,  and then the Tile will revert to <code>TileState.Normal</code>. </p> <p>If the Entity has FloatShoes or is FireBody, the Lava will not attack it. Because it does not attack,  it also does not revert.</p> <p>The attack does 50 Fire damage with the Hit.Flash flag.</p> <p>Obstacles on Lava</p> <p>In v2.1, Obstacles have FloatShoes by default. This means they will not be hit by Lava unless  they have their FloatShoes removed. In the future, Obstacles will be able to be hit by Lava by  default.</p>"},{"location":"onb_overview/enums/tilestate/#normal","title":"Normal","text":"<p>Tiles in the <code>TileState.Normal</code> TileState have no special effects.</p>"},{"location":"onb_overview/enums/tilestate/#poison","title":"Poison","text":"<p>Tiles in the <code>TileState.Poison</code> TileState will damage Characters standing on them. This  uses a global counter, which counts for all Tiles even while in different TileStates.  Every 7 frames on this counter, damage will be dealt.</p> <p>An Entity with Floatshoes will not be attacked.</p> <p>The attack does 1 Null damage with the Hit.Pierce flag.</p> <p>Damage Timing</p> <p>The damage timing in v2.1 does not match the official games. This will be made more  accurate in future versions.</p>"},{"location":"onb_overview/enums/tilestate/#volcano","title":"Volcano","text":"<p>Tiles in the <code>TileState.Volcano</code> TileState will attack once in a while on a global  timer.</p> <p>Every 2 seconds (120f), the Volcano will change animation states to flicker just before  erupting. It will flicker for about 33f before attacking, at which point the 2 second timer restarts and the attack is spawned.</p> <p>The attack lasts as long as the erupted lava is visible, which is approximately 38f. It  does 50 Null damage, with the Hit.Impact and Hit.Flinch flags.</p> <p>Volcano Timing</p> <p>In v2.1, the timing may be different from the original games. It also uses the same  time for each Team's Volcano Tiles, which will change in future versions. </p>"},{"location":"onb_overview/enums/tilestate/#sea","title":"Sea","text":"<p>Tiles in the <code>TileState.Sea</code> state will cause Characters that step onto them to be afflicted  with the Root status for 20 frames. If the Entity is AquaBody or has FloatShoes, they will  not be affected by this. Obstacles will also not be affected by this.</p> <p>Elec element attacks on a Sea Tile will do bonus damage. </p> <p>Cards with the Aqua element will gain +30 damage if used on a Sea Tile. Afterwards, the  Tile will revert to <code>TileState.Normal</code>.</p> <p>FireBody Characters standing on Sea Tiles will take damage over time, as if they were standing  on a Poison Tile. The damage is 1 HP per 7 frames, and can be avoided if the Entity has  FloatShoes.</p> <p>Sea Tiles expire and revert to <code>TileState.Normal</code> after 16 seconds (960 frames).</p> <p>ToadSoul</p> <p>Contrary to popular belief, there is no innate ability for AquaBody Entities to submerge  in Sea Tiles, like ToadSoul does. This is a special ability of ToadSoul.</p>"},{"location":"onb_overview/enums/tilestate/#sand","title":"Sand","text":"<p>Tiles in the <code>TileState.Sand</code> state will cause Characters that step onto them to be afflicted  by the Root status for 20 frames. Obstacles are immune to this.</p> <p>!!! \"Wind Bonus Damage\"     In v2.1, a Wind attack that hits a Sand Tile will revert the Tile to <code>TileState.Normal</code>,     as well as deal bonus damage. The bonus damage may be incorrectly added, and should not      apply to Sand, but rather the SandPit from BN4. This will be corrected in a later version      if so.</p>"},{"location":"onb_overview/enums/tilestate/#metal","title":"Metal","text":"<p>Tiles in the <code>TileState.Metal</code> state cannot be Cracked or Borken. This means calls like  <code>tile:set_state(TileState.Cracked)</code> or <code>tile:set_state(TileState.Broken)</code> will do  nothing if the current state is <code>TileState.Metal</code>. </p> <p>See Breaking Metal Tiles for cases where you may want to Crack  a Tile that is Metal anyway, and official examples where this happens.</p>"},{"location":"onb_overview/enums/tilestate/#usage-tips","title":"Usage Tips","text":""},{"location":"onb_overview/enums/tilestate/#walkable-tiles","title":"Walkable Tiles","text":"<p>It's common to check for certain states when creating attacks that travel along  the ground and would make sense to be stopped by holes, such as the Shockwave  or WaveArm chips from the official games, or when creating enemies or Obstacles  that should avoid holes. </p> <p>Because there are serveral other similar states, you should instead check <code>Tile.is_walkable()</code>. It will return <code>false</code> if the Tile's TileState is Hidden, Broken, or Empty, or if  the Tile is an edge Tile.</p>"},{"location":"onb_overview/enums/tilestate/#breaking-tiles","title":"Breaking Tiles","text":"<p>Common behavior of attacks that crack Tiles is to break a Tile if it's already cracked.  This isn't always the case, but it does happen sometimes. For example, the GutsMan  chip in BN3 will crack panels as shockwaves pass over them, but it will break panels  that are already cracked. The ElecCross Beast chip charge in BN6 will crack panels, but  will not break cracked panels.</p> <p>If you want to break cracked panels, check if the Tile is already cracked, and then  break it if so.</p> <p>ONB will reset the broken Tile timer if you set the state again, which is unlike effects  seen in the games. Remember to check if the Tile was already broken before trying, so you  don't reset the timer.</p>"},{"location":"onb_overview/enums/tilestate/#breaking-metal-tiles","title":"Breaking Metal Tiles","text":"<p>The Metal TileState prevents cracking and breaking a Tile. This means calls like  <code>tile:set_state(TileState.Cracked)</code> or <code>tile:set_state(TileState.Broken)</code> will do  nothing if the current state is <code>TileState.Metal</code>. </p> <p>Some effects intend to overwrite Tiles, which is different flavor from breaking  them. For example, in BN3, MetalMan, GutsMan, and BassGS don't affect Metal Tiles,  but Geddon1 and Geddon2 do. Geddon1 cracks all Tiles, including Metal Tiles; Geddon2  turns all Tiles into holes, but Metal Tiles are instead cracked. If you intend for  this sort of behavior, you can change the Tile to <code>TileState.Normal</code> and then crack  and break it, or only crack if it was Metal beforehand. </p>"},{"location":"onb_overview/enums/tilestate/#making-holes","title":"Making Holes","text":"<p>Some attacks and effects might skip cracking a Tile and go straight to breaking it.  These effects often crack a Tile if it couldn't break, for example if something was  standing on the Tile. To cover for this case, you can set the state to Cracked, and then  on the next line set it to Broken.</p>"},{"location":"v2.1/breaking_changes/","title":"Breaking Changes","text":"<p>There are very few breaking changes in v2.1. Some behavior changes may cause your mods to  misbehave, but still ideally function. See Recommended Upgrades.</p> <p>The changes on this page are known to cause runtime or loading errors every time, or to  cause some code to simply do nothing at all. You'll want to fix them.</p>"},{"location":"v2.1/breaking_changes/#charge-time","title":"Charge Time","text":"<p>In v2.0, the <code>Player.charged_time_table_func</code> or <code>PlayerForm.calculate_charge_time_func</code>  could be used to affect charge times. These two functions have been renamed, and their  parameters were changed to now pass in the Player and the charge level, rather than just  the level. You will need to make the following changes:</p> <ul> <li>Rename <code>charged_time_table_func</code> to <code>charge_time_func</code>, no <code>d</code>!</li> <li>Change the parameters to <code>(self, level)</code>, e.g. <code>player.charge_time_func = function(self, level)</code></li> <li>Rename <code>calculate_charge_time_func</code> to <code>charge_time_func</code>, same as Player</li> <li>Change the parameters to <code>(player, level)</code>, e.g. <code>form.charge_time_func = function(player, level)</code></li> </ul> <p>Before: <pre><code>local form = player:create_form()\nplayer.charged_time_table_func = function(level)\n    return frames(100 - 10 * level)\nend\n\nform.calculate_charge_time_func = function(level)\n    return frames(80 - 5 * level)\nend\n</code></pre></p> <p>After: <pre><code>local form = player:create_form()\n-- No more 'd' in name or 'table', extra parameter\nplayer.charge_time_func = function(self, level)\n    return frames(100 - 10 * level)\nend\n\n-- Name matches Player's function, extra parameter\nform.charge_time_func = function(player, level)\n    return frames(80 - 5 * level)\nend\n</code></pre></p> <p>For other examples using these functions, see Custom Charge Times.</p>"},{"location":"v2.1/breaking_changes/#obstacles-delete-at-0-health","title":"Obstacles Delete at 0 Health","text":"<p>In v2.0, some mods attempted to set the health of an Obstacle to 0, outside of any combat  events. As of v2.1, setting health to 0 immediatelly calls <code>delete</code> on the Obstacle. This  is to allow Obstacles to correctly be deleted during time freeze.</p> <p>This means the following v2.1 code <pre><code>local obstacle = Battle.Obstacle.new(Team.Other)\nobstacle:set_health(0)\n</code></pre> is now essentially equal to doing this in v2.0: <pre><code>local obstacle = Battle.Obstacle.new(Team.Other)\nobstacle:set_health(0)\nobstacle:delete()\n</code></pre></p>"},{"location":"v2.1/breaking_changes/#reasons-mods-may-have-done-this-and-fixes","title":"Reasons Mods May Have Done This, and Fixes","text":"<p>Some mods may have done this to avoid hit detection for their Obstacle. Obstacles have  0 health by default, however, so this may not have done anything. You can remove the line and it will likely work as intended. If it does not, consider using <code>Obstacle.toggle_hitbox</code> to remove its hitbox. In v2.5, this will also cause the Obstacle to be unsearchable on the Field,  however, which could be unintended. You can use other methods to track and search the Obstacle if  you need.</p> <p>Other mods may have set their own Obstacle's health to 0 to achieve some behavior. For example,  the <code>BlkBomb</code> chip may have been implemented using a DefenseRule that set its health to 0 immediately  when hit by a Fire attack. This isn't exactly accurate behavior, however, because it would cause  the bomb to explode during time freeze if your logic is related to deletion. Consider instead flagging  that the bomb has been hit by Fire, blocking all further damage if it has been, and handling the deletion  and explosion on the bomb's following update.</p>"},{"location":"v2.1/changelog/","title":"Changelog","text":"<ul> <li>Folder and pack can be sorted using the Pause button (default Enter) </li> <li>Folders can be copied with <code>CTRL+C</code> while editing</li> <li>Sea, Metal, and Sand TileStates added<ul> <li>Sea boosts damage of Aqua cards used on them, doubles Elec damage taken while on one, and roots Entities that step on them</li> <li>Metal cannot be cracked or broken</li> <li>Sand roots Entities that step on them and doubles Wind damage taken while on one</li> </ul> </li> <li>Charge times are recalculated even without flinching<ul> <li><code>Player.charge_time_func</code> and <code>PlayerForm.charge_time_func</code> can be used reliably as a result</li> </ul> </li> <li>Changed parameters and names of charge time functions, see Breaking Change: Charge Time</li> <li>Wood element Entities will heal over time while standing on a Grass Tile</li> <li>Fire element Entities will not take damage from Lava</li> <li>Elec damage is no longer doubled on Ice</li> <li>Grass Tiles are now removed by Fire, even if damage was not dealt to any Entities</li> <li>Holy Panel damage rounds up</li> <li>Bonus damage from weakness no longer combines multipicatively with other engine-handled sources of bonus damage<ul> <li>E.g. a Fire attack on a Wood Entity standing on Grass used to do x4 damage, but now correctly does +200% damage (x3)<ul> <li>This is accurate to later games in the series</li> </ul> </li> </ul> </li> <li>Movement no longer acts as if endlag is 1 frame when it's 0 frames</li> <li>Player animation for movement is 1f faster, which matches the actual move action<ul> <li>This should fix cases where the move animation started looping during a time freeze action</li> </ul> </li> <li>Drag lasts the correct amount of time now</li> <li>Hit.Bubble no longer crashes, applies Bubble for 150 frames by default</li> <li>Pressing inputs during Stun, Freeze, and Bubble will cause them to end more quickly</li> <li>Status interactions with each other are overall more accurate<ul> <li>Some may cancel others, and will do so correctly</li> </ul> </li> <li>Form changing will cancel various statuses</li> <li>Flinching can no longer be cancelled by using a card</li> <li>TFC cannot be performed until 10 frames into time freeze</li> <li>Charge is no longer used up when performing TFC</li> <li>Anger/FullSync now only consumed by boostable cards</li> <li>Time freeze actions show damage and modifiers</li> <li>Health turns red at low HP</li> <li>Mugshots no longer bounce</li> <li>Freedom battles always send data to the server, and turns can no longer end while the last enemy is dying</li> <li>Freedom battles read input during time freeze</li> <li>Card long descriptions are prioritized over short descriptions in battle</li> <li>Time Freeze actions can be marked uncounterable</li> <li>Time Freeze actions now call action_end_func</li> <li><code>Field.find_nearest_characters</code> returns an ordered table</li> <li><code>Battle.AlertSymbol.new</code> is available</li> <li>Access to <code>Left_Shoulder</code> and <code>Right_Shoulder</code> inputs</li> <li><code>Hit.NoCounter</code> hitflag, prevents attack from countering</li> <li><code>Hit.Confuse</code> hitflag, adds Confuse for 110 frames</li> <li>All Entities can use <code>battle_start_func</code> and <code>battle_end_func</code></li> <li>Access to <code>Character.can_attack</code></li> <li>Access to <code>Entity.set_counter_frame_range</code></li> <li>Access to Entity. <code>is_stunned</code>, <code>is_frozen</code>, <code>is_rooted</code>, <code>is_blind</code>, <code>is_confused</code>, <code>is_bubbled</code>, and <code>is_dragged</code></li> <li>Access to <code>Player.is_charging</code></li> <li>Default turn duration is now correctly 512 frames (~8.5 seconds, down from 10 seconds)</li> <li>Access to <code>Battle.get_turn_count</code>, which returns the current turn number. 0.0 initially, then increases by 1.0 every Battle Start banner</li> <li>Access to many functions related to Custom Gauge manipulation <ul> <li>See Recommended Upgrades: CustGauge Manipulation</li> </ul> </li> <li>Form changing resets emotions</li> <li>New HitProps constructor and builder pattern<ul> <li>See Recommended Mod Upgrades: New HitProps Constructor</li> </ul> </li> <li>HitProps builder pattern allows custom durations for Stun, Freeze, Bubble, Blind, Root, Confuse, and Flash</li> <li>HitProps can have a second element, <code>element2</code></li> <li>Mob can skip rewards screen with <code>Mob:no_rewards()</code></li> <li>Obstacles are now deleted immediately when their health reaches 0, even during time freeze<ul> <li>This may break a few mods. See Breaking Changes: Obstacles Delete At 0 Health</li> </ul> </li> <li>Entity can register new <code>Battle.UIComponent</code>, which acts as a SpriteNode<ul> <li>Add child nodes to draw to the screen in battle, anchored at 0,0 screen coordinates</li> <li>Position is absolute and does not get flipped by perspective flip</li> </ul> </li> <li><code>Esc</code> behavior is now the Panic sequence, which is activated by pressing <code>Esc</code> three times<ul> <li>This means exiting battle is now three <code>Esc</code> presses instead of one</li> </ul> </li> <li>Panic can be used to disconnect from a server</li> <li>The engine can now play SFX when dealing damage<ul> <li>See Recommended Upgrades: Let Engine Handle Hit Sounds</li> </ul> </li> <li>DefenseFrameStateJudge can suggest whether or not to spawn hit GFX<ul> <li>See Recommended Upgrades: Suggest GFX Spawn</li> </ul> </li> <li>Hitbox/Spell <code>attack_func</code> and <code>collision_func</code> now receive an optional last parameter DefenseFrameStateJudge object, mainly for use with the above two features</li> <li>Obstacles can now be affected by Lava, but you must remove their FloatShoes, which are added by default</li> <li>Blocks are now sorted when loaded, which fixes a desync where the order of blocks could be wrong when sent to a remote player</li> </ul> <p>There are also new server-related features. </p> <ul> <li>Battle rewards can be granted, with limited functionality around card rewards</li> <li>HUD can be swapped with the PET icon</li> <li>Can send email to clients</li> <li>Can play PET ring SFX</li> <li>New Sprite API lets servers draw sprites on the client's screen</li> <li>Can assert asset type when providing assets</li> <li>Card mod packages received by client are added to mod partition for the duration of the session</li> <li>Battle results no longer have <code>runaway</code> bool, now use <code>reason</code> enum</li> </ul>"},{"location":"v2.1/overview/","title":"v2.1","text":"<p>v2.1 pulls some fixes, changes, and features from ahead in the repo's history, and even from  Jamesking's work on the upcoming v2.5, with extra help from James in devising and revising  the new systems in play that weren't in v2.5 yet.</p> <p>This is a mostly non-breaking update. Very, very few mods should be broken, but some behavior has been affected, and new behavior is now possible that you may want to implement.  Read the changelog, then see Recommended Mod Upgrades. Even if you don't have any mods to upgrade, that page also has usage suggestions and examples  for new features.</p> <p>There are just a couple breaking changes, which affect features or behavior used by extremely  few mods. See breaking changes for more info.</p> <p>If any mods have broken or have unexpected changed behavior unrelated to the ones documented here, ping me (Alrysc) on Discord and I can help you diagnose.</p>"},{"location":"v2.1/recommended_upgrades/","title":"Recommended Mod Upgrades","text":"<p>The vast majority of mods do not need upgrades to work in the new version. However, there  are many new features available that modders will want to use to improve their mods, including  things that were previously impossible. </p> <p>Some of these recommendations are to warn about behavioral changes, which may affect how a mod  works, but most likely leave it working. Other recommendations are for new things that can be added  to mods to either make certain logic safer, or improve mods with new functionality. These  are separated by section.</p> <p>This page also covers usage suggestions and examples for new features.</p>"},{"location":"v2.1/recommended_upgrades/#new-feature-possibilities","title":"New Feature Possibilities","text":""},{"location":"v2.1/recommended_upgrades/#let-engine-handle-hit-sounds","title":"Let Engine Handle Hit Sounds","text":"<p>v2.1 allows many mods to remove the hit sounds included in their mods. This has technically  always been true because of the <code>AudioType</code> enum, but  now the engine can take full control and even play different hit sounds depending on what  an attack hit.</p> <p>For most people, this means you don't have to provide hit sounds in most of your mods anymore,  or handle playing them, unless you specifically want a custom hit SFX different from the default.</p> <p>Note that the SFX will only play when the attack is not blocked, it does more than 0 damage,  and it has the <code>Hit.Impact</code> flag. This should not be concerning and is likely what is intended  by all mods regardless, as hit sounds act like this in Battle Network, too. If you want to play a  hit sound and you know it doesn't fall under these situations, you may still want to call  <code>Engine.play_audio</code>. Otherwise, you should be able to safely remove it and associated audio  files from your mods.</p>"},{"location":"v2.1/recommended_upgrades/#default-hurt-sounds","title":"Default Hurt Sounds","text":"<p>This is all because Entities now have \"default hurt sounds\", which will play after the <code>Spell.attack_func</code> runs, if damage from an attack was not blocked, was &gt; 0, and the attack had the <code>Hit.Impact flag</code>.  There are three different defaults:</p> <ul> <li>The sound you hear when damaging an Obstacle in BN (default for all Obstacles)</li> <li>The sound you hear when damaging an enemy in BN (default for all other Entities)</li> <li>The sound you hear when the player is damaged in BN (default for only the local Player)</li> </ul> <p>This means that, in PvP, you will hear a different sound when you get damage than you hear when  you damage the enemy player.</p>"},{"location":"v2.1/recommended_upgrades/#change-default-sound","title":"Change Default Sound","text":"<p>You can change the default hurt sound for an Entity. This requires two function calls: one to  set the new sound to use, and one to toggle whether or not your custom sound should be used.</p> <p><pre><code>local my_hurt_sfx = Engine.load_audio(_folderpath..\"hurt.ogg\")\nfunction player_init(player)\n    player:use_default_hurt_sfx(false)\n    player:set_hurt_sfx(my_hurt_sfx)\nend\n</code></pre> This also works with the <code>AudioType</code> enum. <pre><code>function player_init(player)\n    player:use_default_hurt_sfx(false)\n    -- Player will play the Explode sound whenever damaged\n    player:set_hurt_sfx(AudioType.Explode)\nend\n</code></pre></p> <p>You can also use <code>nil</code> as the hurt SFX to play no sound.</p>"},{"location":"v2.1/recommended_upgrades/#override-damage-sound-for-defense","title":"Override Damage Sound For Defense","text":"<p>Sometimes, you may want a DefenseRule to play a sound when the Entity gets hit. Often  a hit sound won't play, because a DefenseRule usually blocks attacks, but this isn't  always the case. Maybe your DefenseRule allows the user to still be damaged, but it creates  some extra effect and you want a different hurt sound. </p> <p>This can be done using the judge's new <code>set_hit_sfx</code> function. This can override the  sound that the Entity has set for their hurt SFX to play your own.</p> <p><pre><code>local my_hit_sfx = Engine.load_audio(_folderpath..\"hit.ogg\")\nlocal defense = Battle.DefenseRule.new(10, DefenseOrder.CollisionOnly)\ndefense.can_block_func = function(judge, attacker, defender)\n    judge:set_hit_sfx(my_hit_sfx)\nend\n\nplayer:add_defense_rule(defense)\n</code></pre> The above DefenseRule will override the SFX to play after damage, so that instead of using  the hurt Entity's set SFX, it will use the one set here. An <code>AudioType</code> enum value also works. <pre><code>local defense = Battle.DefenseRule.new(10, DefenseOrder.CollisionOnly)\ndefense.can_block_func = function(judge, attacker, defender)\n    judge:set_hit_sfx(AudioType.Explode)\nend\n\nplayer:add_defense_rule(defense)\n</code></pre> You can also use a value of <code>nil</code> to prevent any sound from playing. </p> <p>A DefenseRule that runs after yours may set the SFX again, which will overwrite your change.  The attacker has the final say in the damage sound, however. </p> <p>'hit' vs. 'hurt'</p> <p>Make sure to notice that <code>Entity</code> uses <code>hurt</code> in <code>Entity.use_default_hurt_sfx</code> and  <code>Entity.set_hurt_sfx</code>, but <code>DefenseFrameStateJudge</code> uses <code>hit</code> in <code>DefenseFrameStateJudge.set_hit_sfx</code>.</p>"},{"location":"v2.1/recommended_upgrades/#override-damage-sound-for-attack","title":"Override Damage Sound For Attack","text":"<p>Sometimes, you may want an attack you make to play a different sound. You can still call  <code>Engine.play_audio</code> in your <code>attack_func</code>, but this will play the sound at the same time as the  enemy hit sound. </p> <p>Attacks have the final say in what SFX will play, since they can run logic after every other  possible change was made. Because the <code>DefenseFrameStateJudge</code> is now passed into the <code>attack_func</code>  and <code>collision_func</code> of Spells and other hitboxes, you can use its new <code>set_hit_sfx</code> function to  determine what sound will play when damage is dealt. For example,  <pre><code>local my_hit_sfx = Engine.load_audio(_folderpath..\"hit.ogg\")\nspell.attack_func = function(self, other, judge)\n    judge:set_hit_sfx(my_hit_sfx)\nend\n</code></pre> The above code will cause your own SFX to play. You can similarly use an <code>AudioType</code> enum value instead. <pre><code>spell.attack_func = function(self, other, judge)\n    -- Play the explosion sound\n    judge:set_hit_sfx(AudioType.Explosion)\nend\n</code></pre></p> <p><code>nil</code> is also a valid value and will cause no sound to play. You might use this also in cases where you want your non-Impact attack to make a hit sound, so you used <code>Engine.play_audio</code>, and want to  ensure no other sound plays at the same time.</p> <p>'hit' vs. 'hurt'</p> <p>Make sure to notice that <code>Entity</code> uses <code>hurt</code> in <code>Entity.use_default_hurt_sfx</code> and  <code>Entity.set_hurt_sfx</code>, but <code>DefenseFrameStateJudge</code> uses <code>hit</code> in <code>DefenseFrameStateJudge.set_hit_sfx</code>.</p>"},{"location":"v2.1/recommended_upgrades/#custom-charge-times","title":"Custom Charge Times","text":"<p>v2.1 fixes charge time calculation, which means Player mods are free to have unique  charge times. If you do not add one, the mod will continue to use the default  provided by the engine.</p> <p>This is done using the <code>charge_time_func</code>, both on Players and on PlayerForms. The <code>charge_time_func</code> is passed a reference to the Player, and a number <code>level</code>  representing the current Charge level, and expects a <code>frametime</code> to be returned.  The <code>level</code> will be a number from 1 to 5, inclusive. Be sure to cover all cases.</p> <pre><code>local form = player:create_form()\nplayer.charge_time_func = function(self, level)\n    if level == 1 then\n        return frames(50)\n    end\n\n    if level == 2 then \n        return frames(40)\n    end\n\n    -- etc.\nend\n\n-- Note that the form receives the Player, not itself, in the parameters, \n-- so standard practice of using `self` as the first parameter is incorrect.\nform.charge_time_func = function(player, level)\n    if level == 1 then\n        return frames(100)\n    end\n\n    if level == 2 then \n        return frames(90)\n    end\n\n    -- etc.\nend\n</code></pre> <p>Some tips for determining charge times:</p> <ul> <li>The default charge time is 90 frames at level 1, 80 at level 2, 70 at level 3, 60 at level 4, and 50 and level 5.</li> <li>If your charge time can be based on a formula, use one<ul> <li>For exmaple, the ONB default can be replicated in one line with <code>return frames(100 - 10 * level)</code></li> </ul> </li> <li>The official games often do not use linear charge times. For example, HeatCross in BN6 has times   60, 50, 40, 35, 30, for levels 1-5. Notice how having more levels past 3 has lesser effect.</li> <li>The returned time is applied after holding the Shoot button for 10 frames (when the graphic appears)<ul> <li>This means returning <code>frames(10)</code> actually means you need to hold B for 20 frames total to be fully charged</li> <li>Sources on charge times for the official games may or may not count the 10 frames before holding Shoot.  Take this into consideration when taking data from other sources. </li> </ul> </li> </ul> <p>If your mod changes the <code>Player.charged_attack_func</code>, consider also changing the <code>Player.charge_time_func</code>.</p>"},{"location":"v2.1/recommended_upgrades/#suggest-gfx-spawn","title":"Suggest GFX Spawn","text":"<p>In the original games, there are some Defenses which allow graphical effects to spawn even though  the attack was blocked, and others that don't. Spells can simply spawn graphics wherever and whenever  they want, but you can now have your DefenseRules suggest that they don't spawn a graphic. This is  not foolproof, as mods needs to read this and decide to listen, but it allows for the option. </p> <p>This comes from <code>DefenseFrameStateJudge.hint_spawn_gfx</code>. If called, it will return <code>true</code> or <code>false</code>,  based on whether or not it has been suggested that GFX should or shouldn't spawn. If called by passing  in a boolean instead, it will set the return value to be given later.</p> <p><pre><code>local defense = Battle.DefenseRule.new(10, DefenseOrder.CollisionOnly)\ndefense.can_block_func = function(judge, attacker, defender)\n    -- Ask attackers to not spawn GFX\n    judge:hint_spawn_gfx(false)\nend\n\nplayer:add_defense_rule(defense)\n</code></pre> With this DefenseRule, you might have an attacker like so: <pre><code>spell.collision_func = function(self, other, judge)\n    -- Stop if the judge has asked not to spawn GFX\n    if not judge:hint_spawn_gfx() then return end\n\n    -- Put code for spawning hit effect here\nend\n</code></pre></p> <p>It's recommended to have your attacks listen to the DefenseFrameStateJudge.</p>"},{"location":"v2.1/recommended_upgrades/#access-to-shoulder-buttons","title":"Access to Shoulder Buttons","text":"<p>v2.1 adds the <code>Right_Shoulder</code> and <code>Left_Shoulder</code> inputs to be read by mods. You  can perform some logic based on these, and you might have some mods that were getting  especially crowded using only the Special button. </p> <p>Note that the shoulders are typically used to open the Custom screen. Your logic may  be performed at the same time the Custom screen opens if the Custom Gauge is full.</p>"},{"location":"v2.1/recommended_upgrades/#safer-card_action_event","title":"Safer card_action_event","text":"<p>In v2.0, if you used <code>Character.card_action_event</code>, you had no way of knowing whether  or not the Card would be added or would execute, or even could execute. You might  have queued the action multiple times, causing it to happen more times than intended.  With v2.1, this can be made somewhat safer because we can check whether or not the  Character is available to perform an action using <code>Character.can_attack</code>.</p> <p><code>Character.can_attack</code> returns false if the Character already has a CardAction, or  is flinching, stunned, frozen, or in the middle of Drag. By combining this with a  check for <code>Entity.is_moving</code>, you can more consistently avoid queueing the action  multiple times, since the frame after you queue the action <code>Character.can_attack</code> will  return false until the action has either finished or been discarded.</p> <p><pre><code>player.update_func = function(self)\n    local can_act = player:can_attack() and not player:is_moving()\n    if can_act and player:input_has(Input.Pressed.Left_Shoulder) then \n        player:card_action_event(make_my_action(), ActionOrder.Voluntary)\n    end \nend\n</code></pre> If the above code did not make those checks, a player could repeatedly press the left shoulder button and queue the action multiple times, or could even press it while stunned and have the  action happen immediately when stun ends. Guarding the <code>card_action_event</code> with <code>can_attack</code>  and <code>is_moving</code> prevents this.</p>"},{"location":"v2.1/recommended_upgrades/#hitnocounter","title":"Hit.NoCounter","text":"<p>You can now make attacks that can never counterhit. In v2.0, this was able to be done using  the raw value of the enum (2048), but now the enum value is accessible using <code>Hit.NoCounter</code>.  If you used <code>2048</code>, consider updating to use the enum value, which is guaranteed to always  work in the future.</p>"},{"location":"v2.1/recommended_upgrades/#check-confusion-and-blind","title":"Check Confusion and Blind","text":"<p>In the original games, enemies would often act differently than normal if they were blind  or confused. Modders can now check for these conditions with <code>Entity.is_confused</code> and  <code>Entity.is_blind</code>.</p> <p>According to K1rbyat1na, confused enemies in BN3/EXE3 acted the same as if they were rooted,  so their movements will not happen. But in later games, confused enemies act the same as  if they were blinded, which means, quoted: \" 1. They have a longer idle delay. 2. They can't choose the correct tile for an attack and choose it randomly (e.g., StarMan using Star Arrow). 3. They skip attacks that require moving to a specific tile (e.g., StarMan using Moon Dance).</p> <p>Some bosses have unique features in the Blind state. For example, Blinded Forte always excludes tiles  containing the player when using Shooting Buster so he never hits them. \"</p> <p>You might consider following this for your mods to be closer to the source material.</p>"},{"location":"v2.1/recommended_upgrades/#battle_end_func-and-battle_start_func","title":"<code>battle_end_func</code> and <code>battle_start_func</code>","text":"<p>All Entities can use the <code>battle_start_func</code> and <code>battle_end_func</code> now. This is most likely  to come up where modders have wanted to remove Spells from the Field when battle ends, or  prevent enemies from spawning new attacks, which is common for official game behavior. </p>"},{"location":"v2.1/recommended_upgrades/#timefreeze-action_end_func","title":"TimeFreeze action_end_func","text":"<p>In v2.0, time freeze CardActions did not call their <code>action_end_func</code>. This has been fixed.  If your mods had certain cleanup that must be performed at the end, this could be a good  place to move things.</p>"},{"location":"v2.1/recommended_upgrades/#timefreeze-uncounterable","title":"TimeFreeze Uncounterable","text":"<p>Time freeze actions can now be marked as uncounterable, using <code>CardMeta.counterable = false</code>.</p> <p>Try not to abuse it too much. This is typically used for time freezes that happen as a  result of some condition, like Guardian being hit, or an elemental attack appearing  on the field and triggering ElementTrap, or a boss changing phases. Mods that have these  sorts of actions likely already wanted to be uncounterable, and now they can be. Generally  recommended to go with <code>skip_time_freeze_intro</code> being true.</p>"},{"location":"v2.1/recommended_upgrades/#set_counter_frame_range","title":"set_counter_frame_range","text":"<p>Instead of toggling counter on and off, you can now set a range of animation keyframes for which an Entity will be counterable. This is based on the current animation.</p> <pre><code>action.execute_func = function(self, actor)\n    actor:set_counter_frame_range(1, 4)\nend\n</code></pre> <p>The above code is equivalent to  <pre><code>action.execute_func = function(self, actor)\n    action:add_anim_action(1, function()\n        actor:toggle_counter(true)\n    end)\n\n    action:add_anim_action(4, function()\n        actor:toggle_counter(false)\n    end)\nend\n</code></pre> Note that this example is done specifically in the <code>execute_func</code>, which is the first time the  user has entered the action animation, but you can still do this elsewhere. Don't forget to  treat the incoming <code>user</code> for the <code>card_create_action</code> as if it may be different from the <code>actor</code>. You should be targeting the <code>actor</code>, given in the parameters for the <code>execute_func</code> or returned  from <code>CardAction.get_actor</code>.</p>"},{"location":"v2.1/recommended_upgrades/#breaking-metal-tiles","title":"Breaking Metal Tiles","text":"<p>The Metal TileState prevents cracking and breaking a Tile. This means calls like  <code>tile:set_state(TileState.Cracked)</code> or <code>tile:set_state(TileState.Broken)</code> will do  nothing if the current state is <code>TileState.Metal</code>. </p> <p>Some effects intend to overwrite Tiles, which is different flavor from breaking  them. For example, in BN3, MetalMan, GutsMan, and BassGS don't affect Metal Tiles,  but Geddon1 and Geddon2 do. Geddon1 cracks all Tiles, including Metal Tiles; Geddon2  turns all Tiles into holes, but Metal Tiles are instead cracked. If you intend for  this sort of behavior, you can change the Tile to <code>TileState.Normal</code> and then crack  and break it, or only crack if it was Metal beforehand. </p>"},{"location":"v2.1/recommended_upgrades/#engine-alert-symbol","title":"Engine Alert Symbol","text":"<p>v2.1 adds access to <code>Battle.AlertSymbol.new()</code>, which creates an alert symbol, the  double exclamation point icon that appears when taking weakness damage or performing  TFC. If your mods have created one for themselves, you may consider using this instead. </p>"},{"location":"v2.1/recommended_upgrades/#turn-counting","title":"Turn Counting","text":"<p>In v2.0, some mods tried to create attacks or special effects that activated only  once per turn. This can now be done much more easily and with fewer holes by the  new <code>Battle.get_turn_count</code>.</p> <p><code>Battle.get_turn_count</code> returns the current turn of the battle. It will return <code>0.0</code> before the first turn, then <code>1.0</code> more every time the \"Battle Start!\" banner appears  after exiting card select.</p> <pre><code>player.last_known_turn = 0.0\nplayer.allow_special_attack = true\n\n-- Set allow_special_component true if it's a new turn\nlocal special_component = Battle.Component.new(player, Lifetimes.Scene)\nspecial_component.update_func = function()\n    local turn = Battle.get_turn_count()\n    if turn ~= player.last_known_turn then\n        player.last_known_turn = turn\n        player.allow_special_attack = true\n    end\nend\nplayer:register_component(special_component)\n\n-- Do nothing if allow_special_attack is false\n-- Otherwise, return special attack and set \n-- allow_special_attack false\nplayer.special_attack_func = function(self)\n    if not self.allow_special_attack then \n        return \n    end\n\n    local action = Battle.CardAction.new(self, \"PLAYER_IDLE\")\n\n    action.excute_func = function()\n        self.allow_special_attack = false\n    end\n\n    return action\nend\n</code></pre>"},{"location":"v2.1/recommended_upgrades/#new-hitprops-constructor","title":"New HitProps Constructor","text":"<p>HitProps can now be constructed and modified using a builder pattern. This is best done using the new constructors, <code>HitProps.new()</code> or  <code>HitProps.new(context)</code>.</p> <p>Before: <pre><code>local hit_props = HitProps.new(\n    props.damage,\n    Hit.Impact | Hit.Flinch | Hit.Stun,\n    props.element,\n    user:get_context(),\n    Drag.None\n)\n</code></pre> Now: <pre><code>local hit_props = HitProps.new()\n    :dmg(props.damage)\n    :impact()\n    :flinch()\n    :stun()\n    :elem(props.element)\n    :from(user:get_context())\n</code></pre> You no longer need to remember the order of values to give to the constructor,  and don't have to specify that you will have no Drag. If your attack did have  Drag, you can decide to do <pre><code>hit_props:drg(Drag.new(user:get_facing(), 1))\n</code></pre></p>"},{"location":"v2.1/recommended_upgrades/#use-element2","title":"Use element2","text":"<p>With the new HitProps builder pattern, you can now  add secondary elements.</p> <p><pre><code>local hit_props = HitProps.new()\n    :dmg(props.damage)\n    :impact()\n    :flinch()\n    :stun()\n    :elem(props.element)\n    :elem2(Element.Sword)\n    :from(user:get_context())\n</code></pre> This can be read with <code>hit_props.element2</code>.</p> <p>Be sure to take <code>element2</code> into account in your DefenseRules, which should react the same  to primary and secondary element.</p>"},{"location":"v2.1/recommended_upgrades/#use-status-durations","title":"Use Status Durations","text":"<p>With the new HitProps builder pattern, you can now  add durations to certain statuses.</p> <p><pre><code>local hit_props = HitProps.new()\n    :dmg(props.damage)\n    :impact()\n    :flinch()\n    :stun(frames(90))\n    :elem(props.element)\n    :from(user:get_context())\n</code></pre> Note that a status generally needs at least two frames of duration to take effect. </p> <p>The following statuses can be given durations in this way:</p> <ul> <li>stun (default 120 frames)</li> <li>freeze (default 150 frames)</li> <li>flash (default 120 frames)</li> <li>root (default 120 frames)</li> <li>blind (default 300 frames)</li> <li>confuse (default 110 frames)</li> <li>bubble (default 150 frames)</li> </ul>"},{"location":"v2.1/recommended_upgrades/#custgauge-manipulation","title":"CustGauge Manipulation","text":"<p>It's now possible to read and change the Custom Gauge's duration and speed.</p> <ul> <li><code>Battle.get_cust_gauge_value</code>, which returns a double with value <code>0.0</code> at empty gauge and <code>1.0</code> or higher at full, as a percentage completion of the gauge</li> <li><code>Battle.get_cust_gauge_time</code>, which returns a number in frames for the current gauge time (e.g. 256.0 when gauge is half full with default duration)</li> <li><code>Battle.get_cust_gauge_max_time</code>, which returns a number in frames for the current max gauge time (e.g. 512.0 for default time)</li> <li><code>Battle.get_default_cust_gauge_max_time</code>, which returns the default gauge time, 512.0 frames</li> <li><code>Battle.set_cust_gauge_time</code>, takes in a frametime (like <code>frames(256)</code>) to set current gauge time to</li> <li><code>Battle.set_cust_gauge_max_time</code>, takes in frametime to set max time to (current time is automatically readjusted to match the percentage of total time it had before, e.g. max time 512 and current time 256 will have current time 100 if you set max time to 200)</li> <li><code>Battle.reset_cust_gauge_to_default</code>, sets max time to default time</li> </ul>"},{"location":"v2.1/recommended_upgrades/#behavior-changes-be-aware","title":"Behavior Changes (Be Aware)","text":""},{"location":"v2.1/recommended_upgrades/#using-hitdrag","title":"Using Hit.Drag","text":"<p>v2.1 makes Drag interactions much closer to source material. This reveals some  possible mistakes modders have made with Drag attacks. Below are some nuances that  may have been unknown before, and that modders should reconsider for attacks that  inflict Drag: 1. Drag makes the hit Entity totally unable to act for over 20 frames after movement stops 2. Drag and Freeze are fully incompatible. If any attacks have Hit.Freeze and Hit.Drag, they     will never cause Freeze. If you have done this, consider removing Hit.Freeze.</p>"},{"location":"v2.1/recommended_upgrades/#drag-endlag","title":"Drag Endlag","text":"<p>The Drag status now properly keeps Entities from acting for over 20 frames after movement  stops. This is the Drag endlag, during which <code>Entity.is_moving</code> and <code>Entity.is_sliding</code>  will return false, which was not the case in v2.0.</p> <p>See safer card_action_event.</p>"},{"location":"v2.1/recommended_upgrades/#movement-endlag","title":"Movement Endlag","text":"<p>In v2.0, all movement had at least one frame of endlag. Endlag of <code>frames(0)</code> and  <code>frames(1)</code> were identical. With v2.1, this is no longer the case. </p> <p>This will affect any MoveEvent that was using <code>frames(0)</code> for its endlag, which  is most sliding Spells. There is no actual fix necessary, because modders likely  intended their 0 frame endlag to really be 0 frames, but modders should be aware  that projectiles may appear to move slightly more quickly. </p> <p>The actual effect on speed has to do with how long it takes to reach mutiple Tiles  away. Things that moved two Tiles will reach the second Tile 1 frame faster now that  the endlag isn't there. Moving three Tiles will reach the third Tile 2 frames faster,  etc.</p> <p>If you intended to have an extra frame on each Tile, you can use <code>frames(1)</code> as the  endlag to replicate how <code>frames(0)</code> looked and moved in v2.0.</p>"},{"location":"v2.1/recommended_upgrades/#spawning-hit-effects","title":"Spawning Hit Effects","text":"<p>Some Spells will spawn hit effects in their <code>collision_func</code> or <code>attack_func</code>. Some  mods spawn the effect on the Spell's Tile; others spawn on the hit Entity's Tile.  Spawning on the Spell's Tile has always been less correct, because the Spell is moving  and may have already reached the next Tile before the effect was spawned. This could  mean the effect spawns behind the hit Entity, for example. </p> <p>Because of the movement endlag change, this may be more noticeable (but it could have happened in v2.0, too). If a mod spawned the hit effect on the target's Tile, no change is necessary. If they  spawned on the Spell's Tile, consider changing this.</p>"},{"location":"v2.1/recommended_upgrades/#deleting-moving-attacks","title":"Deleting Moving Attacks","text":"<p>Some Spells will delete themselves in their <code>collision_func</code>. If the Spell is moving,  it may have changed Tiles before the <code>collision_func</code> ran. This means it could have  been drawn on the next Tile even though it hit on the previous Tile, because Entities  still draw on the frame <code>Entity:delete()</code> is called.</p> <p>This draw error could happen in v2.0, but is likely more noticeable now because of the  movement endlag change.</p> <p>If you call <code>erase</code> in your <code>delete_func</code>, or if you called <code>erase</code> intead of <code>delete</code>,  or if you call <code>hide</code> when you called <code>delete</code>, or if you call <code>hide</code> in the <code>delete_func</code>,  this will never happen to your Spells. If you do not do any of these, consider adding one. My recommendation is to call <code>Entity.hide</code> in your <code>delete_func</code>.</p>"},{"location":"v2.1/recommended_upgrades/#find_nearest_characters-fix","title":"find_nearest_characters Fix","text":"<p>In v2.0, <code>Field.find_nearest_characters</code> did not actually return an ordered list, so the  first item was not necessarily the nearest Character. This is fixed by v2.1. </p> <p>If you have used <code>find_nearest_characters</code> and intended to target the nearest Character,  no change is needed; you may notice that you are now actually getting the nearest Character.</p> <p>If you have avoided <code>find_nearest_characters</code> to use your own solution, or because it did  not work as expected, consider updating to now use it.</p>"},{"location":"v2.1/recommended_upgrades/#fire-and-grass","title":"Fire and Grass","text":"<p>Fire element attacks now remove Grass even if they did not hit an Entity. Mods that  handled this interaction on their own in v2.0 can now remove their implementation, as the engine will handle it.</p>"},{"location":"v2.1/recommended_upgrades/#grass-lava-effects","title":"Grass, Lava Effects","text":"<p>Grass now heals Wood Entities. If your Player mods have implemented a sort of grass heal,  you can now remove this and rely on the engine's. If you do not, your healing effect will stack with the engine's.</p> <p>Fire Entities are no longer harmed by Lava Tiles. If you have added FloatShoes to your  Player mods only to recreate this interaction in v2.0, you can now remove the FloatShoes  and remain immune to Lava.</p>"},{"location":"v2.1/recommended_upgrades/#new-tilestates","title":"New TileStates","text":"<p>Because of the new TileStates (Sea, Metal, Sand), mods that attempted to change Tiles  on the Field to any TileState (e.g. a mod that picks random TileStates each time)  may want to be updated to support the additions.</p> <p>Servers that send data for encounters tend to use hardcoded values based on the TileState  enum (ezencounters does this). Any use of <code>TileState.Hidden</code> on your server encounters  may now appear as Sea Tiles. See the repo for new values to adjust to.</p>"},{"location":"v2.1/recommended_upgrades/#double-hit-sound","title":"Double Hit Sound","text":"<p>Because the engine now plays default SFX when damage is dealt,  mods that called <code>Engine.play_audio</code> in their attacks' <code>attack_func</code>s are likely playing  a second sound on top of the default. </p> <p>If you have a special sound to play that won't be used by the engine by default, use the  DefenseFrameStateJudge that's now passed into the <code>attack_func</code> to set the sound with  <code>DefenseFrameStateJudge.set_hit_sfx</code>, and remove the <code>play_audio</code> call.</p> <p>Otherwise, if your sound is the sound that the engine will play anyway, remove your  <code>play_audio</code> call. You can also remove the SFX audio file from the mod if it's not used  elsewhere.</p>"}]}