# v2.1
v2.1 pulls some fixes, changes, and features from ahead in the repo's history, and even from 
Jamesking's work on the upcoming v2.5, with extra help from James in devising and revising 
the new systems in play that weren't in v2.5 yet.

This is a non-breaking update. No mods should be broken, but some behavior has
been affected, and new behavior is now possible that you may want to implement. 
Read the changelog, then see [Recommended Mod Upgrades](#recommended-mod-upgrades).

If any mods have broken, ping me (Alrysc) on Discord and I'll see about patching. 

## Changelog
* Folder and pack can be sorted using the Pause button (default Enter) 
* Folders can be copied with CTRL+C while editing
* Sea, Metal, and Sand TileStates added
    * Sea boosts damage of Aqua cards used on them, doubles Elec damage taken while on one, and roots Entities that step on them
    * Metal cannot be cracked or broken
    * Sand roots Entities that step on them and doubles Wind damage taken while on one
* Charge times are recalculated even without flinching
    * Player.charged_time_table_func and PlayerForm.charged_time_table_func can be used reliably as a result
* Wood element Entities will heal over time while standing on a Grass Tile
* Fire element Entities will not take damage from Lava
* Elec damage is no longer doubled on Ice
* Grass Tiles are now removed by Fire, even if damage was not dealt to any Entities
* Holy Panel damage rounds up
* Movement no longer acts as if endlag is 1 frame when it's 0 frames
* Drag lasts the correct amount of time now
* Pressing inputs during Stun and Freeze will cause them to end more quickly
* Status interactions with each other are overall more accurate
    * Some may cancel others, and will do so correctly
* Form changing will cancel various statuses
* Flinching can no longer be cancelled by using a card
* TFC cannot be performed until 10 frames into time freeze
* Charge is no longer used up when performing TFC
* Anger/FullSync now only consumed by boostable cards
* Time freeze actions show damage and modifiers
* Health turns red at low HP
* Mugshots no longer bounce
* Freedom battles always send data to the server, and turns can no longer end while the last enemy is dying
* Freedom battles read input during time freeze
* Card long descriptions are prioritized over short descriptions in battle
* Time Freeze actions can be marked uncounterable
* Time Freeze actions now call action_end_func
* Field.find_nearest_characters returns an ordered table
* Battle.AlertSymbol.new is available
* Access to Left_Shoulder and Right_Shoulder inputs
* Hit.NoCounter hitflag, prevents attack from countering
* All Entities can use battle_start_func and battle_end_func
* Access to Character.can_attack
* Access to Entity.set_counter_frame_range
* Access to Entity. is_stunned, is_frozen, is_rooted, and is_blind

## Recommended Mod Upgrades
No mods should be broken by this update, but modders now have an opportunity to 
add more to their mods. Some of these recommendations are to warn about behavioral 
changes, but mod updates are not necessarily required.

Other recommendations are for new things that can be added to mods to either make 
certain logic safer, or improve mods with new functionality.

### New Things You May Want To Add

#### Custom Charge Times
v2.1 fixes charge time calculation, which means Player mods are free to have unique 
charge times. If you do not add one, the mod will continue to use the default 
provided by the engine.

This is done using the `charged_time_table_func`, both on Players and on PlayerForms.
The `charged_time_table_func` is passed a number `level` representing the current 
Charge level, and expects a `frametime` to be returned. The `level` will be a number 
from 1 to 5, inclusive. Be sure to cover all cases.

```lua
local form = player:create_form()
player.charged_time_func = function(level)
    if level == 1 then
        return frames(50)
    end

    if level == 2 then 
        return frames(40)
    end

    -- etc.
end

form.charged_time_func = function(level)
    if level == 1 then
        return frames(100)
    end

    if level == 2 then 
        return frames(90)
    end

    -- etc.
end
```

Some tips for determining charge times:

* The default charge time is 90 frames at level 1, 80 at level 2, 70 at level 3, 60 at level 4, and 50 and level 5.
* If your charge time can be based on a formula, use one
    * For exmaple, the ONB default can be replicated in one line with `return frames(100 - 10 * level)`
* The official games often do not use linear charge times. For example, HeatCross in BN6 has times 
 60, 50, 40, 35, 30, for levels 1-5. Notice how having more levels past 3 has lesser effect.
* The returned time is applied *after* holding the Shoot button for 10 frames (when the graphic appears)
    * This means returning `frames(10)` actually means you need to hold B for 20 frames total to be fully charged
    * Sources on charge times for the official games may or may not count the 10 frames before holding Shoot. 
    Take this into consideration when taking data from other sources. 

If your mod changes the `Player.charged_attack_func`, consider also changing the `Player.charged_time_func` 
to go with it. If you do change the `charged_time_func`, remember that it will not be run when set. 
To recalculate time with the new function, you can set your charge level, for example by doing 
`player:set_charge_level(player:get_charge_level())`.

#### Access to Shoulder Buttons
v2.1 adds the `right_shoulder` and `left_shoulder` inputs to be read by mods. You 
can perform some logic based on these, and you might have some mods that were getting 
especially crowded using only the Special button. 

Note that the shoulders are typically used to open the Custom screen. Your logic may 
be performed at the same time the Custom screen opens if the Custom Gauge is full.

#### Safer card_action_event
In v2.0, if you used `Character.card_action_event`, you had no way of knowing whether 
or not the Card would be added or would execute, or even could execute. You might 
have queued the action multiple times, causing it to happen more times than intended. 
With v2.1, this can be made somewhat safer because we can check whether or not the 
Character is available to perform an action using `Character.can_attack`.

`Character.can_attack` returns false if the Character already has a CardAction, or 
is flinching, stunned, frozen, or in the middle of Drag. By combining this with a 
check for `Entity.is_moving`, you can more consistently avoid queueing the action 
multiple times, since the frame after you queue the action `Character.can_attack` will 
return false until the action has either finished or been discarded.

```lua
player.update_func = function(self)
    local can_act = player:can_attack() and not player:is_moving()
    if can_act and player:input_has(Input.Pressed.Left_Shoulder) then 
        player:card_action_event(make_my_action(), ActionOrder.Voluntary)
    end 
end
```
If the above code did not make those checks, a player could repeatedly press the left shoulder
button and queue the action multiple times, or could even press it while stunned and have the 
action happen immediately when stun ends. Guarding the `card_action_event` with `can_attack` 
and `is_moving` prevents this.

#### Hit.no_counter
You can now make attacks that can never counterhit. In v2.0, this was able to be done using 
the raw value of the enum (2048), but now the enum value is accessible using `Hit.no_counter`. 
If you used `2048`, consider updating to use the enum value, which is guaranteed to always 
work in the future.

#### `battle_end_func` and `battle_start_func`
All Entities can use the `battle_start_func` and `battle_end_func` now. This is most likely 
to come up where modders have wanted to remove Spells from the Field when battle ends, or 
prevent enemies from spawning new attacks, which is common for official game behavior. 

#### TimeFreeze action_end_func
In v2.0, time freeze CardActions did not call their `action_end_func`. This has been fixed. 
If your mods had certain cleanup that must be performed at the end, this could be a good 
place to move things.

#### set_counter_frame_range
Instead of toggling counter on and off, you can now set a range of frames for which an 
Entity will be counterable. This is based on the current animation.

In the official games, almost every counterable action has counter frames for the first 
15 or 16 frames (to be determined). If you wanted your scripted action to be conuterable 
for this frame, you can do

```lua
action.execute_func = function(self, actor)
    -- TODO: This could be (1, 16), or (1, 15), or (2, 16), or (2, 15)
    actor:set_counter_frame_range(1, 16)
end
```
Note that this is done specifically in the `execute_func`, which is the first time the 
user has entered the action animation.

#### Engine Alert Symbol
v2.1 adds access to `Battle.AlertSymbol.new()`, which creates an alert symbol, the 
double exclamation point icon that appears when taking weakness damage or performing 
TFC. If your mods have created one for themselves, you may consider using this instead. 

### Behavior Changes (Be Aware)

#### Using Hit.Drag
v2.1 makes Drag interactions much closer to source material. This reveals some 
possible mistakes modders have made with Drag attacks. Below are some nuances that 
may have been unknown before, and that modders should reconsider for attacks that 
inflict Drag:
1. Drag makes the hit Entity totally unable to act for over 20 frames after movement stops
2. Attacks that Drag and Flinch will cause the hit Entity to also play their Flinch animation **after Drag ends**,
   which means they are unable to act for even longer than point 1. suggests. If not intentional, 
   you may want to remove Hit.Flinch from any attacks that also have Hit.Drag.
3. Drag and Freeze are fully incompatible. If any attacks have Hit.Freeze and Hit.Drag, they 
   will never cause Freeze. If you have done this, consider removing Hit.Freeze.

#### Movement Endlag
In v2.0, all movement had at least one frame of endlag. Endlag of `frames(0)` and 
`frames(1)` were identical. With v2.1, this is no longer the case. 

This will affect any MoveEvent that was using `frames(0)` for its endlag, which 
is most sliding Spells. There is no actual fix necessary, because modders likely 
intended their 0 frame endlag to really be 0 frames, but modders should be aware 
that projectiles may appear to move slightly more quickly. 

The actual effect on speed has to do with how long it takes to reach mutiple Tiles 
away. Things that moved two Tiles will reach the second Tile 1 frame faster now that 
the endlag isn't there. Moving three Tiles will reach the third Tile 2 frames faster, 
etc.

If you intended to have an extra frame on each Tile, you can use `frames(1)` as the 
endlag to replicate how `frames(0)` looked and moved in v2.0.

#### Spawning Hit Effects
Some Spells will spawn hit effects in their `collision_func` or `attack_func`. Some 
mods spawn the effect on the Spell's Tile; others spawn on the hit Entity's Tile. 
Spawning on the Spell's Tile has always been less correct, because the Spell is moving 
and may have already reached the next Tile before the effect was spawned. This could 
mean the effect spawns behind the hit Entity, for example. 

Because of the [movement endlag change](#movement-endlag), this may be more noticeable
(but it could have happened in v2.0, too).
If a mod spawned the hit effect on the target's Tile, no change is necessary. If they 
spawned on the Spell's Tile, consider changing this.

#### Deleting Moving Attacks
Some Spells will delete themselves in their `collision_func`. If the Spell is moving, 
it may have changed Tiles before the `collision_func` ran. This means it could have 
been drawn on the next Tile even though it hit on the previous Tile, because Entities 
still draw on the frame `Entity:delete()` is called.

This draw error could happen in v2.0, but is likely more noticeable now because of the 
[movement endlag change](#movement-endlag).

If you call `erase` in your `delete_func`, or if you called `erase` intead of `delete`, 
or if you call `hide` when you called `delete`, or if you call `hide` in the `delete_func`, 
this will never happen to your Spells. If you do not do any of these, consider adding one.
My recommendation is to call `Entity.hide` in your `delete_func`.

#### find_nearest_characters Fix
In v2.0, `Field.find_nearest_characters` did not actually return an ordered list, so the 
first item was not necessarily the nearest Character. This is fixed by v2.1. 

If you have used `find_nearest_characters` and intended to target the nearest Character, 
no change is needed; you may notice that you are now actually getting the nearest Character.

If you have avoided `find_nearest_characters` to use your own solution, or because it did 
not work as expected, consider updating to now use it.

#### Fire and Grass
Fire element attacks now remove Grass even if they did not hit an Entity. Mods that 
handled this interaction on their own in v2.0 can now remove their implementation, as
the engine will handle it.

#### Grass, Lava Effects
Grass now heals Wood Entities. If your Player mods have implemented a sort of grass heal, 
you can now remove this and rely on the engine's. If you do not, your healing effect will
stack with the engine's.

Fire Entities are no longer harmed by Lava Tiles. If you have added FloatShoes to your 
Player mods only to recreate this interaction in v2.0, you can now remove the FloatShoes 
and remain immune to Lava.

#### New TileStates
Because of the new TileStates (Sea, Metal, Sand), mods that attempted to change Tiles 
on the Field to any TileState (e.g. a mod that picks random TileStates each time) 
may want to be updated to support the additions.

Servers that send data for encounters tend to use hardcoded values based on the TileState 
enum (ezencounters does this). Any use of `TileState.Hidden` on your server encounters 
may now appear as Sea Tiles. See the repo for new values to adjust to.