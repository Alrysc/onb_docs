{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Open Net Battle","text":"<p>These docs contain information on creating mods for the Open Net Battle (ONB) engine,  an engine recreating the mechanics of MegaMan Battle Network 6 where all content  is user generated.</p> <p>The current version of Open Net Battle is v2.0a (specifically, the fifth patch). Whenever  I write something that says it's about v2.0, I mean the latest version. Certain things may  be different in the next large engine update, and I'll be updating information here to  reflect changes when they happen. </p>"},{"location":"#topics-covered","title":"Topics Covered","text":"<p>These docs are in the early stages. So far, you'll find:</p> <ol> <li>A summary of Lua features in the Lua Primer tab</li> <li>Small usage tips for Entity class objects and summaries of their notable functions</li> <li>Overviews of some of the C++ enums that have Lua bindings</li> </ol> <p>I still plan to add at least:</p> <ol> <li>Pages on the rest of the engine C++ objects that have Lua bindings, similar to  the Entity pages</li> <li>Pages on the rest of the values of engine enums</li> <li>Overviews of the mod package types</li> <li>Sections that cover setting up a new mod of each type</li> <li>Sections dedicated to other tools that can help certain parts of modding and how to use them</li> <li>Sections covering common desired behavior, like making attacks that move</li> <li>Sections that warn of logical pitfalls that could cause code to act in unexpected,  less noticed ways</li> <li>Sections on specific engine details, like the order of logic in a frame</li> <li>Sections on details and behavior from the official games, to help make mods feel more authentic (things like the typical number of chip codes, or how much each charge  level tends to speed up charging)</li> </ol>"},{"location":"#other-help","title":"Other Help","text":"<p>You most likely got here through the official Discord server. If you didn't, I  recommend you join it. You'll be around for updates, other players, the latest  tools as the develop, and, most importantly, other modders like me who can help  you figure stuff out. </p>"},{"location":"changelog/","title":"Changelog","text":"<p>Here you'll find a record of changes made to these docs. I won't mention smaller changes  much, so expect to mostly see new pages and the dates they were added.</p> <p>This is also partially here so readers can see the date of the last update. When the  next engine update arrives, check here to see if I've updated the docs yet to reflect  new changes or new information.</p>"},{"location":"changelog/#july-13th-2025","title":"July 13th, 2025","text":"<ul> <li>Added Hit enum page</li> </ul>"},{"location":"changelog/#july-2nd-2025","title":"July 2nd, 2025","text":"<ul> <li>Added Lifetimes enum page</li> </ul>"},{"location":"changelog/#june-2025","title":"June 2025","text":"<ul> <li>First Launch</li> <li>Added Enums section and some pages<ul> <li>Element</li> <li>Direction</li> <li>Team</li> <li>Input</li> <li>Rank</li> <li>AudioPriority</li> <li>AudioType</li> <li>Highlight</li> <li>Shadow</li> <li>ColorMode</li> <li>Playback</li> <li>CardClass</li> <li>Blocks</li> <li>EntityStatus</li> <li>TileState enum</li> <li>DefenseOrder</li> <li>LockType </li> </ul> </li> </ul>"},{"location":"lua/","title":"Overview","text":"<p>All mods are written in the Lua programming language. The goal of this section is not to teach you Lua, especially as  your first programming language, but to highlight basic usage and differences from other languages, as well as important features. I will try to cover the bare minimum in order to understand the code examples and logic behind other guides in these  docs.</p> <p>Sometimes I can't help myself and might make a few suggestions on how to or how not to use things. If you're new to coding, I  (with some bias) recommend reading them. If you're already familiar with other languages, they probably won't add anything.</p> <p>I may also sometimes have short sections that relate to usage in ONB. I'll reiterate on these in other places in documentation  specifically for ONB, so don't worry about skipping.</p> <p>You can also follow along some of the sections here using some Lua interpreter. Some can be found online and used from your  browser, such as https://onecompiler.com/lua/.</p>"},{"location":"lua/#learning","title":"Learning","text":"<p>Programming in Lua (PiL) does a much better job going over language features than I  do. If you want to seriously learn the language, give it and the official Lua manual and documentation a read. If you want a second opinion, more examples, or similar information in different words, feel free to read from here  and those links.</p> <p>Don't let either those or these few pages be the end, either. There are plenty of Lua tutorials you can find even on  YouTube. Look for them.</p>"},{"location":"lua/#lua-features-we-dont-get","title":"Lua Features We Don't Get","text":"<p>While covered in the manual and other Lua learning resources, there are parts of the language we cannot use in ONB mods. Some are mentioned here, but this is not an exhaustive list:</p> <ol> <li>The String library<ul> <li>No checking for substrings, pattern matching, characters at a position, or indexing a String</li> </ul> </li> <li>Coroutines</li> <li>Checking the date or time<ul> <li>If you could, you would likely desync whenever you did, anyway</li> </ul> </li> <li>File system access</li> </ol>"},{"location":"lua/boolean_expressions/","title":"Boolean Expressions","text":"<p>Like a math expression, which uses numbers, a boolean expression uses  booleans. And, like a math expression, you can solve one down to a  single value (\"resolve\" it).</p> <pre><code>1. 2 + 4 + 8\n    - Add the 2 and 4\n2. 6 + 8\n    - Add the 6 and 8\n3. 14\n    - Final value\n</code></pre> <pre><code>1. false or false or true\n    - OR the `false` and `false`\n2. false or true\n    - OR the `false` and `true`\n3. true\n    - Final value\n</code></pre>"},{"location":"lua/boolean_expressions/#other-values","title":"Other Values","text":"<p>Booleans are not the only types that can be used in a boolean expression.</p> <p>A value of any type, except for if the value is <code>nil</code> or <code>false</code>, will  resolve to <code>true</code>. Both <code>nil</code> and <code>false</code> are treated as <code>false</code>.</p> <pre><code>-- true\nprint(1 and true)\n\n-- true\nprint(0 and true)\n\nlocal x = -1\n\n-- true\nprint(x and \"\")\n\n-- false\nprint(nil or false)\n</code></pre> <p>My code examples will often use this feature as a shorthand in conditions,  but remember to check if something is explicitly == false if your logic  should consider <code>nil</code> as a separate case.</p>"},{"location":"lua/boolean_expressions/#short-circuit","title":"Short Circuit","text":"<p>Boolean expressions can be short circuited. This is when the program skips part  of the evaluation because it knows the result of the expression is already determined. </p> <p>For example, </p> <p><pre><code>local x = true and false and true\n</code></pre> When executing this statement, the logic is more like</p> <pre><code>1. true and false and true\n    - AND `true and `false`\n2. false and --\n    - It doesn't matter what is on the other side of the `and`.\n    `false` ANDed with anything is `false`, so it doesn't check.\n3. false\n    - Final result\n</code></pre> <p>This is more obvious in more complex expressions.</p> <pre><code>--[[\n    Return true if a and b are both greater than 0 \n    and a is greater than b.\n]]\nfunction greater_above_zero(a, b)\n    print(\"Check zero.\")\n    if a &lt; 0 or b &lt; 0 then \n        return false\n    end\n\n    return a &gt; b\nend\n\nlocal check = greater_above_zero(1, 2) and greater_above_zero(2, 1)\n\nprint(check)\n</code></pre> <p>In the above code, when <code>greater_above_zero</code> is called, we expect a <code>print</code> call  as well. <code>greater_above_zero</code> is called twice, so you might expect it to appear  twice. However, if you run this, you will see</p> <pre><code>Check zero.\nfalse\n</code></pre> <p>It only appeared once. Here's how the resolution looked:</p> <pre><code>1. greater_above_zero(1, 2) and greater_above_zero(2, 1)\n    - Call greater_above_zero with 1 and 2, run that function.\n    It printed and returned false.\n\n2. false and --\n    - The other side of the `and` is ignored because anything\n    ANDed with `false` is `false`.\n</code></pre>"},{"location":"lua/boolean_expressions/#avoid-expensive-calls","title":"Avoid Expensive Calls","text":"<p>An important aspect of short circuiting is that it can avoid more expensive, or additional,  calls when they aren't necessary. Take the following code:</p> <pre><code>--[[\n    Compare all elements in t1 to all elements in t2. \n\n    Returns true if they each contain exactly the same elements \n    as the other.\n]]\nfunction deep_compare_table(t1, t2)\n    -- Implementation omitted for example\nend\n\n\nif player:get_element() == Element.None \n    and player:get_health() &gt; 1000\n    and deep_compare_table(player.t1, player.t2)\nthen\n    print(\"All satisfied\")\nend\n</code></pre> <p>We only want that statement to <code>print</code> if the player's element is None, they have more than  1000 health, and two tables contain the same elements. The latter operation is obviously  much more expensive and can take many more computations than the former two. </p> <p>Because of short circuiting, that comparison is never even attempted if the element is not  None, or if their health is not above 1000.</p> <p>The code above can similarly be written as</p> <p><pre><code>function deep_compare_table(t1, t2)\n    -- Implementation omitted for example\nend\n\n\nif player:get_element() == Element.None then\n    if player:get_health() &gt; 1000 then \n        if deep_compare_table(player.t1, player.t2) then\n            print(\"All satisfied\")\n        end\n    end\nend\n</code></pre> You can see why you might prefer to short circuit in one boolean expression instead.</p>"},{"location":"lua/boolean_expressions/#avoid-erroneous-calls","title":"Avoid Erroneous Calls","text":"<p>Short circuiting can also be a useful technique for writing code that avoids making calls  that would otherwise result in an error. In the ONB sections of these docs, you will see  me use it often when checking Tiles.</p> <p><pre><code>--[[\n    Return true if a &lt; b. \n\n    a and b both must be numbers.\n]]\nfunction check_lesser(a, b)\n    return a &lt; b\nend\n\n--[[[\n    Roll a random number between 1 and 2.\n\n    If the number is 1, returns nil.\n    If the number is 2, returns 2.\n]]\nfunction get_number()\n    local r = math.random(1, 2)\n\n    if r == 1 then \n        return nil\n    end\n\n    return r\nend\n\nlocal maybe_r = get_number()\n\nlocal lesser = maybe_r and check_lesser(maybe_r, 4)\n\nprint(lesser)\n</code></pre> In the above code, the result returned from <code>get_number</code> may be <code>nil</code>. It would be an error to call  <code>check_greater</code> with <code>nil</code>, because you cannot compare a number to <code>nil</code>. </p> <p>In order to avoid this, I check first check if <code>maybe_r</code> is <code>nil</code>, and AND that with the result  of <code>check_greater</code>. Recall that <code>nil</code> evaluates to <code>false</code>, and any other value that isn't <code>false</code>  evaluates to <code>true</code>. Then, the resolution of this expression might look like:</p> <pre><code>1. maybe_r and check_greater(maybe_r, 4)\n    - Substitute in the variable value\n2. 2 and check_greater(2, 4)\n    - Check boolean value of `2`\n3. true and check_greater(2, 4)\n    - Resolve the check_greater call\n4. true and true\n5. true\n</code></pre> <p>Or</p> <pre><code>1. maybe_r and check_greater(maybe_r, 4)\n    - Substitute in the variable value\n2. nil and check_greater(nil, 4)\n    - Check boolean value of `nil`\n3. false and --\n    - `false` ANDed with any other value is `false`, so \n    there is no need to check the other side.\n4. false\n</code></pre> <p>The order here matters. If the code was instead </p> <pre><code>local lesser = check_lesser(maybe_r, 4) and maybe_r\n</code></pre> <p><code>check_lesser</code> would have been called with <code>nil</code>, and an error would occur.</p>"},{"location":"lua/comments/","title":"Comments","text":"<p>You can, should, and will add comments to your code. </p> <p>A comment is some text you can have in your code that will not be read by the program.  That means you can leave notes for yourself or others who read your code, describe how  certain functions behave and how they expect to receive data, and so on. </p> <p>You can also \"comment out\" some code to leave it in your file, but prevent it from  being executed. This can be safer for you than deleting lines when testing.</p> <p>You will usually want to write your comment above the code it relates to. While you  can write it on the same line, your text will go off the screen faster that way,  and it could be harder to convert your comment to a multiline comment later or remove it.</p>"},{"location":"lua/comments/#single-line","title":"Single Line","text":"<p>Comments in Lua start with two hyphens <code>--</code>. Every character after that in the line  will not be read by the program.</p> <pre><code>-- x offset for the player\nlocal x = 0\n-- y offset for the player\nlocal y = 0\n\nlocal num = 20 -- 50\n\n-- Crashes if this is negative\nlocal countdown = 10\n</code></pre>"},{"location":"lua/comments/#multiple-lines","title":"Multiple Lines","text":"<p>You can comment multiple lines at once by surrounding a region of code with <code>--[[ ]]</code>.</p> <pre><code>--[[\n    Multiplies `x` and `y` and returns the result.\n\n    `x` and `y` both must be numbers.\n]]\nlocal function multiply(x, y)\n    return x * y\nend\n\n--[[\n\nThis is a different implementation of the multiply function\nthat would multiply all values in a table. \n\nI didn't finish it, but it might be useful someday. Come back \nto finish it later.\n\nlocal function multiply(number_table)\n\nend\n\n]]\n</code></pre>"},{"location":"lua/comments/#when-to-comment","title":"When To Comment","text":"<p>Different people might teach you to use comments more or less frequently, or for more  or less specific code. For example, I would tell you not to do something like:</p> <pre><code>-- This is the player's offset\nlocal player_offset = player:get_offset()\n-- This is the x offset of the player\nlocal x_off = player_offset.x\n-- This is the y offset of the player\nlocal y_off = player_offset.y\n</code></pre> <p>Very wordy, and the variable names already state what they are. A comment may not  add much insight. </p> <p>You might want to ask yourself a few questions, like</p> <ol> <li>Is the code simple enough that you can tell what it does by looking at it?</li> <li>Is there any special behavior or requirement to the code that isn't obvious?</li> <li>Will I forget what this does when I come back to fix a bug in a month?</li> </ol> <p>For your ONB mods, I would encourage leaving comments where appropriate. You might  just need to fix a bug and you've forgetten what the behavior should be. A new  modder might look to your mod for inspiration and try to read its code. You might  want to come back and update it with a new engine feature that makes the logic  much cleaner. Help yourself and everyone else.</p>"},{"location":"lua/comparisons/","title":"Comparisons","text":"<p>You can compare two values with comparison operators.</p> <ol> <li>&lt;    (less than)</li> <li>&lt;=   (less than or equal to)</li> <li>&gt;    (greater than)</li> <li>&gt;=   (greater than or equal to)</li> <li>==   (equal to)</li> <li>~=   (not equal to)</li> </ol> <p>Note that <code>~</code> is used for \"not equal to\" instead of <code>!</code> like other languages.</p> <p>The result of these operators will be a <code>boolean</code>.</p> <pre><code>-- false, because true is not false\nprint(true == false)\n\n-- true\nprint(\"Hello\" == \"Hello\")\n\n-- true\nprint(10 &gt; 2)\n\nlocal x = 10\nlocal y = 8\n\n-- true\nprint(x ~= y)\n\ny = y + 2\n\n-- false\nprint(x ~= y)\n</code></pre>"},{"location":"lua/control_structures/","title":"Control Structures","text":"<p>These are covered more succinctly in Programming in Lua. If you read only one source, choose that one over this.</p> <p>Each control structure involves some keywords, a boolean expression,  and usually an <code>end</code>. They create a new scope, or block, as their body.</p> <p>There are no switch statements.</p>"},{"location":"lua/control_structures/#if","title":"if","text":"<p>A <code>if</code> statement is made by the <code>if</code> keyword, a boolean expression, the <code>end</code> keyword,  the body logic, and is closed by the <code>end</code> keyword.</p> <pre><code>if true then \n    -- Body logic\nend\n</code></pre> <p>The code within the body will only run if the boolean expression resolves to <code>true</code>.</p> <p><pre><code>if 5 &lt; 2 then \n    print(\"Run 1\")\nend\n\nif 5 &gt; 2 then \n    print(\"Run 2\")\nend\n</code></pre> In the above code, the only output will be <code>Run 2</code>.</p> <p>Notice that there are no <code>{}</code> like other languages, and parentheses around the  boolean expression are not required.</p>"},{"location":"lua/control_structures/#else","title":"else","text":"<p>You can have a second body that will run only if the boolean expression resolves  to false. Use the keyword <code>else</code> in place of <code>end</code>, and move the <code>end</code> to the end  of the <code>else</code> body.</p> <p><pre><code>if 5 &lt; 2 then \n    print(\"Run 1\")\nelse\n    print(\"No Run 1\")\nend\n\nif 5 &gt; 2 then \n    print(\"Run 2\")\nelse\n    print(\"No Run 2\")\nend\n</code></pre> In the above code, the output will be:</p> <pre><code>No Run 1\nRun 2\n</code></pre>"},{"location":"lua/control_structures/#elseif","title":"elseif","text":"<p>You can have any number of extra blocks following an <code>if</code> that will only  run if the previous condition was <code>false</code> and a new condition is met.</p> <p>This can be done similar to <code>else</code>, but requires a <code>then</code> after.</p> <pre><code>if 5 &lt; 2 then \n    print(\"Run 1\")\nelseif 5 &gt; 2 then\n    print(\"Run 1 else\")\nelse\n    print(\"Default\")\nend\n\nif 5 &gt; 2 then \n    print(\"Run 2\")\nelseif 5 ~= 5 then \n    print(\"Run 2 else 1\")\nelseif 5 == 5 then\n    print(\"Run 2 else 2\")\nend\n</code></pre> <pre><code>Run 1 else\nRun 2\n</code></pre>"},{"location":"lua/control_structures/#while","title":"while","text":"<p>A <code>while</code> loop can be created by using the keyword <code>while</code>, a boolean expression,  the keyword <code>do</code>, and finally closing the body with <code>end</code>.</p> <p>Until the expression resolves to <code>false</code>, the body will run over and over. If  the expression resolves to <code>false</code> before running even once, the body will not  run.</p> <pre><code>local counter = 3\nwhile counter &gt; 0 do\n    print(counter)\n    counter = counter - 1\nend\n\nlocal x = 1\nwhile x ~= 1 do\n    print(\"Not 1\")\nend\n</code></pre> <p>The output of the above code will be</p> <pre><code>3\n2\n1\n</code></pre> <p>You can also use the keyword <code>break</code> to exit the loop early. If <code>break</code> is used,  the next line must be <code>end</code>.</p> <pre><code>local counter = 3\nwhile counter &gt; 0 do\n    print(counter)\n    if counter == 2 then \n        break\n    end\n\n    counter = counter - 1\nend\n</code></pre> <p>The output of the above code will be</p> <pre><code>3\n2\n</code></pre>"},{"location":"lua/control_structures/#repeat-until","title":"repeat-until","text":"<p>You can <code>repeat</code> some body <code>until</code> a condition is met. Use the keyword <code>repeat</code>,  followed by the body. Then close the body with the <code>until</code> keyword, followed by a  boolean expression. </p> <p>Note that there is no <code>do</code> or <code>end</code>, like other loops.</p> <p>Unlike <code>while</code>, <code>repeat-until</code> will always run the body at least once. The boolean expression  is checked after the body runs instead of before.</p> <pre><code>local counter = 3\nrepeat\n    print(counter)\n    counter = counter - 1\nuntil counter == 0\n\nlocal x = 1\nrepeat\n    print(\"Not 1\")\nuntil x == 1\n</code></pre> <p>The above code will have the following outupt:</p> <pre><code>3\n2\n1\nNot 1\n</code></pre> <p><code>break</code> can be used in the body in the same way as a <code>while</code> loop.</p> <pre><code>local counter = 3\nrepeat\n    print(counter)\n\n    if counter == 2 then \n        break\n    end\n\n    counter = counter - 1\nuntil counter == 0\n\nlocal x = 1\nrepeat\n    print(\"Not 1\")\nuntil x == 1\n</code></pre> <pre><code>3\n2\nNot 1\n</code></pre>"},{"location":"lua/control_structures/#for","title":"for","text":"<p>A <code>for</code> loop is used to loop over a block of code a specified number of times. You can create  a <code>for</code> loop by using the keyword <code>for</code>, defining a variable name and default value as the  iterator, a number where the iterator will stop at, optionally a number to increment by  after each iteration (the \"step\"), the keyword <code>do</code>, the body, and finally an <code>end</code>.</p> <p>Conventionally, the iterator will be named <code>i</code>. If you have multiple <code>for</code> loops nested, you  might move onto <code>j</code>, <code>k</code>, and other letters.</p> <p>This one will be easier to understand visually than through that text.</p> <pre><code>for i=1, 3, 1 do\n    print(\"Loop 1: \"..i)\nend\n\nprint(\"\")\n\nfor i=1, 3 do\n    print(\"Loop 2: \"..i)\nend\n\nprint(\"\")\n\nfor i=4, 0, -2 do\n    print(\"Loop 3: \"..i)\nend\n\nprint(i)\n</code></pre> <p>This outputs</p> <pre><code>Loop 1: 1\nLoop 1: 2\nLoop 1: 3\n\nLoop 2: 1\nLoop 2: 2\nLoop 2: 3\n\nLoop 3: 4\nLoop 3: 2\nLoop 3: 0\nnil\n</code></pre> <p>There are a few things to notice here:</p> <ol> <li>The variable name is not declared with <code>local</code>, but it is local to the loop body. The <code>nil</code> print at the end proves that.</li> <li>The default step is <code>1</code> when not provided.</li> <li>No boolean expression is given for the end of the loop, only a number to stop at.</li> <li>The loop ends when <code>i</code> is &gt; the limit for a positive step, and ends when <code>i</code>  is &lt; the limit for a negative step.</li> </ol> <p>The 4th point means the following code will run the body of the <code>for</code> loop once:</p> <pre><code>for i=1, 1 do\n    print(i)\nend\n</code></pre> <p>It also means that this loop's body will not run at all:</p> <pre><code>for i=1, -1 do\n    print(i)\nend\n</code></pre> <p>Separately, a step of <code>0</code> is considered an error.</p> <p>You can use <code>break</code> in a <code>for</code> loop.</p> <pre><code>for i=1, 3, 1 do\n    print(\"Loop: \"..i)\n    break\nend\n</code></pre> <p>This outputs</p> <pre><code>Loop: 1\n</code></pre>"},{"location":"lua/control_structures/#ipairs","title":"ipairs","text":"<p>You can iterate over a table's numerical indexes using special <code>for</code> loop syntax.  Instead of defining a incremented variable, a step, and so on, you give names for the  key and value of each pair, and pass the table into a call to <code>ipairs</code>.</p> <p>The <code>key</code> will be set to a key in the input table, and the <code>value</code> will be the value  at the <code>key</code> index in the table.</p> <p><pre><code>local my_table = {\n    2,\n    4,\n    8\n}\n\nfor k, v in ipairs(my_table) do\n    print(\"Key \"..k..\" has value \"..v)\nend\n</code></pre> This will output </p> <pre><code>Key 1 has value 2\nKey 2 has value 4\nKey 3 has value 8\n</code></pre> <p>When iterating with <code>ipairs</code>, the <code>key</code> will start at 1 and increase by 1 each iteration. Once a <code>nil</code> value is encountered as the value, the loop ends.</p> <p><pre><code>local my_table = {\n    2,\n    4,\n    nil,\n    8\n}\n\nfor k, v in ipairs(my_table) do\n    print(\"Key \"..k..\" has value \"..v)\nend\n</code></pre> This will output</p> <pre><code>Key 1 has value 2\nKey 2 has value 4\n</code></pre> <p>Because <code>nil</code> was found at <code>my_table[3]</code>, the loop broke.</p> <p>Note that, because only numerical indexes are visited, <code>ipairs</code> will never encounter  a value at any other type of index, like a String index.</p>"},{"location":"lua/control_structures/#pairs","title":"pairs","text":"<p>You can iterate over all of a table's indexes using special <code>for</code> loop syntax.  Instead of defining a incremented variable, a step, and so on, you give names for the  key and value of each pair, and pass the table into a call to <code>pairs</code>.</p> <p>Compare to <code>ipairs</code>.</p> <pre><code>local my_table = {\n    str = \"Hello\",\n    [-1] = -2,\n    2,\n    4,\n    nil,\n    8,\n    str_2 = \"World\"\n}\n\nmy_table.other_str = \"!\"\n\nfor k, v in pairs(my_table) do\n    print(\"Key \"..k..\" has value \"..v)\nend\n</code></pre> <pre><code>Key 1 has value 2\nKey 2 has value 4\nKey 4 has value 8\nKey -1 has value -2\nKey other_str has value !\nKey str_2 has value World\nKey str has value Hello\n</code></pre> <p>Notice that the order is not necessarily the same as the order in which key-value pairs were  added.</p>"},{"location":"lua/control_structures/#other","title":"Other","text":"<p>There's more information about these types of <code>for</code> loops, but I won't cover them here. See  the manual.</p>"},{"location":"lua/objects/","title":"Tables As Objects","text":"<p>Tables can be used to act much like objects in other object oriented languages. This is closely related to special syntax you can use for functions that are  in a table.</p> <p>Related reading: https://www.lua.org/pil/16.html</p>"},{"location":"lua/objects/#calling-functions","title":"Calling Functions","text":"<p>When a table has a function at some index, the function can be called in the  normal way, with a dot. But you can also call it using a colon <code>:</code> for extra  behavior.</p> <pre><code>local my_table = {\n    func = function()\n        print(\"Func call\")\n    end\n}\n\n-- Normal way\nmy_table.func()\n\n-- Other way\nmy_table:func()\n</code></pre> <p>When calling these functions with a colon, there is an impliict value passed into  the function, being the lefthand side of the colon.</p> <pre><code>function func(param)\n    print(param)\nend\n\nlocal my_table = {}\nmy_table.func = func\n\nmy_table.func()\nmy_table:func()\n</code></pre> <p>The above code outputs</p> <p><pre><code>nil\ntable: 0x55f82a449f40\n</code></pre> or similar.</p> <p>Despite putting nothing in the parentheses, the function call using the colon received the  table as input.</p>"},{"location":"lua/objects/#self","title":"self","text":"<p>When using the colon to call a function, you can say the table passes itself in.  self is the standard name to use for this first parameter. You might notice it  color differently in your code editor. </p> <p>Having itself passed in means we can safely modify members of the table.</p> <pre><code>--[[\n    Adds `a` to the `num` index\n]]\nfunction add_to_num(self, a)\n    self.num = self.num + a\nend\n\nlocal my_table = {\n    num = 0,\n    add_to_num = add_to_num\n}\n\n-- 0\nprint(my_table.num)\n\nmy_table:add_to_num(2)\n\n-- 2\nprint(my_table.num)\n\n-- Notice that the above call is identical to this.\nmy_table.add_to_num(my_table, 2)\n\n-- 4\nprint(my_table.num)\n</code></pre>"},{"location":"lua/objects/#defining-functions","title":"Defining Functions","text":"<p>There's special syntax for defining a function at some String index in a table.</p> <pre><code>local my_table = {\n    num = 0\n}\n\n-- Normal\nmy_table.func_1 = function(self, a)\n    self.num = self.num + a\nend\n\n-- Another way\nfunction my_table.func_2(self, a)\n    self.num = self.num + a\nend\n\n-- Another way that also implicitly has a \"self\" parameter\nfunction my_table:func_3(a)\n    self.num = self.num + a\nend\n\n-- 0\nprint(my_table.num)\n\nmy_table:func_1(1)\nmy_table:func_2(1)\nmy_table:func_3(1)\n\n-- 3\nprint(my_table.num)\n</code></pre>"},{"location":"lua/objects/#in-onb","title":"In ONB","text":"<p>In the ONB sections, you will often see <code>self</code> in example functions, and you  will nearly always call engine functions with a colon. When interacting with  the C++ objects the engine provides, you can nearly think of them the same  way as these tables.</p>"},{"location":"lua/scope/","title":"Scope","text":"<p>Your code can only access data if that data is within its scope. </p>"},{"location":"lua/scope/#indenting","title":"Indenting","text":"<p>While not required, please indent your code to indicate a new scope. It'll  make it easier to read for you and everyone else, and it'll make it easy to  identify each unique scope. You'll see plenty of examples of this through  the code examples here and everywhere else.</p>"},{"location":"lua/scope/#blocks","title":"Blocks","text":"<p>A block of code creates a new scope. A new block exists in the space between  something and its accompanying <code>end</code>. </p> <p>That's between:</p> <ul> <li>The parentheses and <code>end</code> of a function</li> <li>The <code>then</code> and <code>end</code> of a conditional</li> <li>The <code>do</code> and <code>end</code> of a <code>for</code> or <code>while</code> loop</li> <li>The <code>repeat</code> and <code>until</code> of a repeat-until</li> </ul> <pre><code>local y = nil\n\nif true then \n    --[[\n        This `x` only exists until this block closes.\n        When it stops existing, we say it \"went out of \n        scope\".\n    ]]\n    local x = 10\n\n    --[[\n        This is a new block within the other one, \n        so it can still access `x`.\n    ]]\n\n    local function func()\n        -- 10\n        print(x)\n    end\nend\n\n--[[\n    Both print `nil`, because they exist nested in \n    a different scope.\n]]\nprint(x)\nprint(func)\n</code></pre>"},{"location":"lua/scope/#other-files","title":"Other Files","text":"<p>Each working file is its own block, unable to access anything local to any block  of another file. </p> file1.lua<pre><code>local x = 10\n\ninclude(\"file2.lua\")\n\n-- nil\nprint(y)\n</code></pre> file2.lua<pre><code>local y = 20\n\n-- nil\nprint(x)\n</code></pre> <p>Here, even though <code>file2.lua</code> is read and executed by the program running <code>file1.lua</code>, and  you might think <code>file2.lua</code>'s block is inside <code>file1.lua</code>, neither has access to each other's  local variables.</p>"},{"location":"lua/useful_functions/","title":"Useful Functions","text":"<p>Useful Lua functions for use in ONB are highlighted here. They still exist  in other Lua environments, but this page will especially relate to their use  in ONB.</p> <p>Notice how some, specifically in the math and table libraries, are accessed as  if they are parts of a global table named <code>math</code> and <code>table</code>, respectively.</p>"},{"location":"lua/useful_functions/#print","title":"print","text":"<p>You will use the <code>print</code> function, not in finished code but as part of debugging.  It will print the input data to the console (black) window that opens with the  ONB executable.</p> <p><code>print</code> takes any type as parameter, and any number of inputs can be passed in. A newline is implicitly generated.</p> <pre><code>-- Hello World\nprint(\"Hello World\")\n\n-- 100\nprint(10 * 10)\n\n-- Hello World  10  Goodbye table: 0x561832bbdf90\nprint(\"Hello World\", 10, \"Goodbye\", {})\n</code></pre> <p>It can be relatively expensive to write to the console output, so you will want  to make sure no calls to <code>print</code> are left in finished code.</p>"},{"location":"lua/useful_functions/#the-math-library","title":"The math Library","text":"<p>The math library includes a few useful functions for us.</p>"},{"location":"lua/useful_functions/#mathmin","title":"math.min","text":"<p>Calling <code>math.min</code> will return the smaller of two numbers given as input.</p> <pre><code>local a = 10\nlocal b = 20\n\n-- 10\nprint(math.min(a, b))\n</code></pre>"},{"location":"lua/useful_functions/#mathmax","title":"math.max","text":"<p>Calling <code>math.max</code> will return the larger of two numbers given as input.</p> <pre><code>local a = 10\nlocal b = 20\n\n-- 20\nprint(math.max(a, b))\n</code></pre>"},{"location":"lua/useful_functions/#mathfloor","title":"math.floor","text":"<p><code>math.floor</code> will truncate the given input, returning the input number with the decimal  portion removed. In other words, it will round down to the nearest whole number.</p> <p>Importantly, this \"converts\" a double to an integer.</p> <pre><code>local a = 10\na = a / 3\n\n-- 3.333333...\nprint(a)\n\na = math.floor(a)\n\n-- 3\nprint(a)\n</code></pre> <p>For ONB mods, you may often use this to round down after division. You can't use a number  with a decimal as a damage value without an error, so a <code>math.floor</code> call will get you a  proper number.</p>"},{"location":"lua/useful_functions/#mathceil","title":"math.ceil","text":"<p><code>math.ceil</code> will take the given input and round it up to the nearest whole number, and  return the new number.</p> <p>Importantly, this \"converts\" a double to an integer.</p> <pre><code>local a = 10\na = a / 3\n\n-- 3.333333...\nprint(a)\n\na = math.ceil(a)\n\n-- 4\nprint(a)\n</code></pre>"},{"location":"lua/useful_functions/#mathrandom","title":"math.random","text":"<p><code>math.random</code> returns a random number. It can be called with either zero, one, or two inputs.</p> <p>ONB seeds the random number generator for us, so you will never need to call <code>math.randomseed</code>  (in fact, attempting to do so will fail),</p>"},{"location":"lua/useful_functions/#zero-inputs","title":"Zero Inputs","text":"<p>Giving zero inputs in the call will generate a real number between 0 and 1, including 0 but  not including 1.</p> <pre><code>local r = math.random()\n\n--[[\n    This may print 0, 0.3, 0.014, 0.999, etc.\n]]\nprint(r)\n</code></pre>"},{"location":"lua/useful_functions/#one-input","title":"One Input","text":"<p>Giving one input will generate an integer between 1 and the number given, inclusive.</p> <pre><code>local r = math.random(3)\n\n--[[\n    This may print 1, 2, or 3.\n]]\nprint(r)\n</code></pre> <p>Crash!</p> <p>In ONB v2.0, calling <code>math.random</code> with a single input will crash if the input  is <code>0</code>!</p> <p>Unexpected Behavior!</p> <p>In ONB v2.0, calling <code>math.random</code> with a single input when that input is negative will return numbers outside of the expected range.</p>"},{"location":"lua/useful_functions/#two-inputs","title":"Two Inputs","text":"<p>Giving two inputs will generate an integer between the first input and the second, inclusive.</p> <pre><code>local r = math.random(2, 4)\n\n--[[\n    This may print 2, 3, or 4.\n]]\nprint(r)\n</code></pre> <p>Crash!</p> <p>In ONB v2.0, calling <code>math.random</code> with two inputs will crash if the second input  is <code>0</code>!</p> <p>Unexpected Behavior!</p> <p>In ONB v2.0, calling <code>math.random</code> with two inputs when the second input is negative will return numbers outside of the expected range.</p>"},{"location":"lua/useful_functions/#trig-functions","title":"Trig Functions","text":"<p>Various trigonometry functions, such as <code>math.sin</code> are present, and return values in radians.  I will not cover them specifically here, since they have not seen much usage in ONB mods.</p>"},{"location":"lua/useful_functions/#the-table-library","title":"The table Library","text":"<p>There are a few functions on <code>table</code>. <code>table.insert</code> and <code>table.remove</code> are covered in the  section on adding data to tables and the  section on removing data, respectively.</p> <p>Other functions exist, but will not be covered here.</p>"},{"location":"lua/variables/","title":"Variables","text":"<p>We can store information in variables and read from them later. A variable can be created in the following ways:</p> <pre><code>local my_local_var\nlocal my_local_var_2 = 0\nmy_global_var = \"\"\n</code></pre> <p>Here, three variables have been declared. </p> <ol> <li> <p><code>my_local_var</code> is declared local, as you can see. This means that this variable can only be accessed within this scope.  More on what \"scope\" means later. </p> </li> <li> <p><code>my_local_var_2</code> is also declared <code>local</code>, but it is initialized with a value. That value is <code>0</code>, a number.</p> </li> <li> <p>Lastly, <code>my_global_var</code> is declared and initailized to a value of <code>\"\"</code> (an empty String), but has no <code>local</code> in front of it. This  variable is global and can be accessed anywhere in the file, no matter the scope. </p> </li> </ol> <p>Notice that the first variable here, <code>my_local_var</code>, is the only one declared and not given a value. It actually does have a value  implicitly: <code>nil</code>, a keyword in Lua. You can think of it as \"nothing\". We could have also written <code>local my_local_var = nil</code> for  the same effect. I recommend using <code>=</code> and explicitly assigning to <code>nil</code> if you do, for more consistency and to make sure you are  giving it no value with intent.</p> <p>You'll almost always be using <code>local</code> variables. They're easier to work with, generally, and also help you to avoid making mistakes  that are harder to debug. Even better, they help you avoid making mistakes that are hard to notice.</p> <p>Be wary of the scope a variable is defined in. Even if your variable is declared <code>local</code>, having it in the highest, broadest scope  will leave it almost no different from a global variable.</p>"},{"location":"lua/variables/#types","title":"Types","text":"<p>Lua is dynamically typed. Unlike some other languages, where a variable declaration must also declare the type of value it will  hold, a variable in Lua can contain any type of data the language supports. That includes the following:</p> <ol> <li>Numbers (Kind of integers and doubles)</li> <li>Strings</li> <li>Booleans</li> <li>Functions</li> <li>Tables</li> <li>Other userdata (in our case, C++ engine objects)</li> <li><code>nil</code></li> </ol> <p>Here's an example of a variable using each type: <pre><code>-- Initialized to nil, no value\nlocal var = nil\n\n-- Set to an integer\nvar = 1\n\n-- Divide the value in `var` and set `var` to new value.\n-- This gets 0.5, a double\nvar = var / 2\n\n-- Set to a String\nvar = \"Hello World\"\n\n-- Set to boolean value `true`\nvar = true\n\n-- Set to an empty table\nvar = {}\n\n-- Set to a function that does nothing\nvar = function()\n\nend\n\n-- Set to a new Artifact, one of ONB's types. More on that in another section.\nvar = Battle.Artifact.new()\n</code></pre></p> <p>Other sections go over specifics for each type, except for userdata.</p>"},{"location":"lua/variables/#naming-variables","title":"Naming Variables","text":"<p>Variables can be named almost anything, with some exception. They:</p> <ol> <li>Cannot start with a number (<code>1_var</code> is an invalid name)</li> <li>Cannot start with most special characters (<code>!var</code> is invalid, but <code>_var</code> is valid)</li> <li>Cannot be the same as a keyword</li> </ol> <p>Variables named with different casing are distinct.</p> <pre><code>local x = 1\nlocal X = 2\n\n--[[\n    1\n    2\n]]\nprint(x)\nprint(X)\n</code></pre> <p>Lua variable naming convention is to use snake_case, where every word in the name is  lowercase, and every word is separated by an underscore. I will be using snake case for most example code. A large majority  of mods also stick to snake case.</p> <p>You'll want to name your variables based on what they are and how they will be used. A billion <code>var_1</code>, <code>var_2</code> and so on isn't  helping anyone, and neither is a variable named <code>number</code> that's actually a String. </p> <p>Be concise and and be precise, but don't be afraid to be verbose if you need to. Leave comments if it helps to clarify.</p>"},{"location":"lua/variables/#shadowing","title":"Shadowing","text":"<p>If two variables in the same scope share a name, the variable in the smaller scope \"shadows\" the other.  Attempting to access the veriable by name will climb up the code and scopes until it finds a match, and  it'll find the closer match sooner.</p> <p><pre><code>local x = 10\n\nfunction my_func()\n    local x = 20\n\n    -- 20, because that definition is found first\n    print(x)\nend\n\nmy_func()\n\n--[[\n    10, because my_func's `x` is enclosed in an inaccessible \n    scope and the other `x` is still reachable and unaffected\n]]\nprint(x)\n</code></pre> The previous definition is still accessible by name up until the statement declaring the  new variable finishes. That means you can do this:</p> <pre><code>local x = 10\n\nfunction my_func()\n    -- The new `x` is initialize to a value based on the old `x`\n    local x = x - 2\n\n    -- 8\n    print(x)\nend\n\nmy_func()\n\n\n-- 10\nprint(x)\n</code></pre>"},{"location":"lua/variables/booleans/","title":"Booleans","text":"<p>Booleans have only two possible values: <code>true</code> and <code>false</code>.</p> <pre><code>local t = true\nlocal f = false\n</code></pre>"},{"location":"lua/variables/booleans/#operators","title":"Operators","text":""},{"location":"lua/variables/booleans/#and","title":"AND","text":"<p><code>and</code> will take a boolean on both sides and result in <code>true</code> if both inputs are <code>true</code>, or else  it will be <code>false</code>.</p> <p>We write the word, not <code>&amp;&amp;</code> like other languages.</p> <pre><code>-- true\nprint(true and true)\n-- false\nprint(true and false)\n-- false\nprint(false and true)\n-- false\nprint(false and false)\n</code></pre>"},{"location":"lua/variables/booleans/#or","title":"OR","text":"<p><code>or</code> will take a boolean on both sides and result in <code>true</code> if one input is <code>true</code>, or else  it will be <code>false</code>.</p> <p>We write the word, not <code>||</code> like other languages.</p> <pre><code>-- true\nprint(true and true)\n-- true\nprint(true and false)\n-- true\nprint(false and true)\n-- false\nprint(false and false)\n</code></pre>"},{"location":"lua/variables/booleans/#not","title":"NOT","text":"<p><code>not</code> will reverse a boolean in front of it.</p> <p>We write the word, not <code>!</code> like other languages.</p> <pre><code>-- false\nprint(not true)\n-- true\nprint(not false)\n</code></pre> <p>You can use multiple <code>not</code> in a row.</p> <pre><code>-- false\nprint(not not not true)\n</code></pre>"},{"location":"lua/variables/booleans/#operator-precedence","title":"Operator Precedence","text":"<p>Similar to the order of operations for math operators, boolean operators  also have an order in which they resolve.</p> <ol> <li>Parentheses</li> <li>not</li> <li>and</li> <li>or</li> </ol> <p>For their placement within all other operators, see the manual.</p> <pre><code>1. true and not true or false\n    - Apply the `not`\n2. true and false or false\n    - `and` the `true` and `false`\n3. false or false\n    - `or` the false and false\n4. false\n    - Final result\n</code></pre> <p>When in doubt, use parentheses. They can make the expression easier to read, too.</p> <pre><code>1. (true and not true) or false\n2. (true and false) or false\n3. true or false\n4. false\n</code></pre>"},{"location":"lua/variables/booleans/#boolean-expressions","title":"Boolean Expressions","text":"<p>Booleans can be used in expressions. There's a lot more to say on this, so they  are covered in a different section.</p>"},{"location":"lua/variables/functions/","title":"Functions","text":"<p>Functions are like reusable groups of code that can carry out a task. This is a more complicated  type, so I encourage doing more reading than only this page. See the manual.</p>"},{"location":"lua/variables/functions/#defining-a-function","title":"Defining a Function","text":"<p>Functions are defined by the keyword <code>function</code>, followed by the name of the function and a set  of parentheses. They are closed by the keyword <code>end</code>. </p> <p>Follow the same naming conventions as any other variable.</p> <p>No <code>{ }</code> here, like other languages.</p> <pre><code>function my_func()\n\nend\n</code></pre> <p>You can name incoming variables that are passed into the function with a comma separated list of  names in the parentheses. I'll be calling these parameters, arguments, and inputs interchangeably.</p> <pre><code>function my_func(var_1, var_2, var_3)\n\nend\n</code></pre> <p>No two functions can share the same name. It will be shadowed by the second same-name declaration,  similar to other variables.</p> <p>Note that this means there is no function overloading.</p>"},{"location":"lua/variables/functions/#global-and-local","title":"Global and Local","text":"<p>Like other variables, a function can also be global or local. The <code>local</code> keyword applies just the  same.</p> <pre><code>local function my_func()\n\nend\n</code></pre> <p>Typical behavior of local vs. global variables applies.</p>"},{"location":"lua/variables/functions/#usage","title":"Usage","text":"<p>You can call, or invoke, a function by using its name and a set of parentheses.</p> <pre><code>function my_func()\n\nend\n\nmy_func()\n</code></pre> <p>You can pass values in, which will be mapped, in order, to the parameters defined.</p> <pre><code>function my_func(var_1, var_2)\n    print(var_1)\n    print(var_2)\nend\n\n--[[\n    Prints\n\n    10\n    20\n]]\nmy_func(10, 20)\n</code></pre> <p>The <code>print</code> function that has been called in some examples is a global function that Lua provides  for us. </p> <p>If you pass in a different number of parameters than the function defines in its parentheses,  the function call will not fail. If you passed in more than defined, they will be ignored;  if you passed in fewer than defined, the remaining will have a value of <code>nil</code>.</p> <pre><code>function print_vals(a, b, c)\n    print(a)\n    print(b)\n    print(c)\nend\n\n--[[\n    nil\n    nil\n    nll\n]]\nprint_vals()\n\n--[[\n    1\n    2\n    nil\n]]\nprint_vals(1, 2)\n\n--[[\n    1\n    2\n    3\n]]\nprint_vals(1, 2, 3, 4, 5)\n</code></pre>"},{"location":"lua/variables/functions/#as-a-type","title":"As a Type","text":"<p>Functions are treated just like any other variable, and can be assigned to one.</p> <pre><code>function my_func()\n    print(\"Hello World\")\nend\n\nlocal func = my_func\n\n--[[\n    Hello World\n    Hello World\n]]\nmy_func()\nfunc()\n</code></pre> <p>Functions can also be created inline with the keyword <code>function</code> followed by parentheses,  which may contain parameters.</p> <p><pre><code>local my_func = function()\n    print(\"Hello World\")\nend\n\n-- Hello World\nmy_func()\n</code></pre> Whether they are <code>local</code> or not will depend on the variable declaration.</p>"},{"location":"lua/variables/functions/#return-value","title":"Return Value","text":"<p>Functions can have a return value. The function call will resolve to the return value. A value is returned by putting the keyword <code>return</code> before it. All code after the <code>return</code> within the function will not run, and  using <code>return</code> without having an <code>end</code> as the next line is considered an error.</p> <pre><code>function add(a, b)\n    return a + b\nend\n\nlocal sum = add(1, 3)\n\n-- 4\nprint(sum)\n</code></pre> <pre><code>--[[\n    Returns the sum of `a` and `b`.\n\n    If `a` or `b` are larger than 10, \n    returns nil.\n]] \nfunction add_small(a, b)\n    if a &gt; 10 or b &gt; 10 then \n        return\n    end\n\n    return a + b\nend\n\nlocal sum = add(1, 3)\nlocal sum_big = add(100, 300)\n\n-- 4\nprint(sum)\n-- nil\nprint(sum_big)\n</code></pre> <p>When a function has no return value, <code>nil</code> is returned. This can be if there is no <code>return</code> keyword  in the code path, or if there is a <code>return</code> with no value after it.</p>"},{"location":"lua/variables/functions/#closures","title":"Closures","text":"<p>Functions create closures. Basically, anything in their scope when defined can be accessed within  the function.</p> <pre><code>local x = 10\n\nfunction print_x()\n    print(x)\nend\n\nfunction print_y()\n    print(y)\nend\n\nlocal y = 20\n\n-- 10\nprint_x()\n\n-- nil, because `y` is local and defined after print_y\nprint_y()\n</code></pre>"},{"location":"lua/variables/functions/#passing-data","title":"Passing Data","text":"<p>Data may be passed by value or by reference, depending on the type.</p> <p>Primitive types, like numbers and booleans, will be passed by value.  The function receives a copy of the value and acts on it, leaving the  original unaffected.</p> <pre><code>function add_1(a)\n    a = a + 1\nend\n\nlocal a = 1\n\nadd_a(a)\n\n-- 1\nprint(a)\n</code></pre> <p>Tables and other objects are passed by reference. Anything done to it  inside the function will affect the original as well, because the function  body is acting on the original.</p> <pre><code>function set_str(t)\n    t.str = \"Hello\"\nend\n\nlocal my_table = {}\n\n-- nil\nprint(my_table.str)\n\nset_str(my_table)\n\n-- Hello\nprint(my_table.str)\n</code></pre> <p>If you want to pass around a primitive and have it be affected in multiple places  without making it global, this can be a way to achieve that.</p> <pre><code>--[[\n    Accesses the \"num\" index on `t` and adds 1 to it.\n]]\nfunction add_1(t)\n    t.num = t.num + 1\nend\n\n--[[\n    Accesses the \"num\" index on `t` and multiplies it by 10.\n]]\nfunction mult_10(t)\n    t.num = t.num + 1\nend\n\n\nlocal my_table = {\n    num = 0\n}\n\n-- 0\nprint(my_table.num)\n\nadd_1(my_table)\n\n-- 1\nprint(my_table.num)\n\nmult_10(my_table.num)\n\n-- 10\nprint(my_table.num)\n</code></pre>"},{"location":"lua/variables/numbers/","title":"Numbers","text":"<p>Lua uses integers and doubles as number values.</p> <p>Technically, Lua only has Numbers. Integers are represented through a double, but for our purposes,  it can be necessary to differentiate. Because of this, I will sometimes talk about integers and doubles  as if they are separate types.</p>"},{"location":"lua/variables/numbers/#integers","title":"Integers","text":"<p>An integer is a number, negative or positive, that does not have a decimal point. We can perform normal arithmetic operations on them.</p> <pre><code>local counter = 0\nlocal num = 100\n\ncounter = counter + 1\nnum = num * 2\n\nlocal p = num ^ counter\n\nlocal x = p % 10\n\nx = x / 2\n</code></pre> <p>Unfortunately, Lua does not have a shorthand increment. No <code>counter++</code> for us.</p>"},{"location":"lua/variables/numbers/#bitwise-operations","title":"Bitwise Operations","text":"<p>When a number value has no decimal point, it's valid for bitwise operations. </p> <pre><code>local counter = 1\n\n-- 3\ncounter = counter | 2\nprint(counter)\n\n-- 3\ncounter = counter | 2\nprint(counter)\n\n-- 1\ncounter = counter &amp; ~2\nprint(counter)\n</code></pre> <p>and so on. </p> <p>Note that <code>~</code> is used as NOT. It can also be used as XOR.</p> <p><pre><code>-- 0, 1, 1, 0\nprint(1 ~ 1)\nprint(1 ~ 0)\nprint(0 ~ 1)\nprint(0 ~ 0)\n</code></pre> Similar to the differencee between a negative number and subtraction, use a space.</p>"},{"location":"lua/variables/numbers/#doubles","title":"Doubles","text":"<p>You can think of a double as a decimal number. </p> <pre><code>local x = 1.7\nx = x * 3\nx = x + 2.34\n</code></pre> <p>If the decimal is <code>0</code>, it'll be treated as an integer.</p> <pre><code>-- No error\nlocal x = 1.0\nx = x | 2\n\n-- This gets an error\nx = 1.5\nx = x | 2\n</code></pre>"},{"location":"lua/variables/numbers/#conversions","title":"Conversions","text":"<p>If the result of an operation on an integer ends with a value that has a decimal, you'll  have a double. That could be adding a double to an integer, or dividing by a number that  doesn't divide perfectly.</p> <pre><code>local x = 5\nx = x | 2\nx = x + 1.2\n-- x has a decimal, so this will throw an error.\nx = x | 1\n</code></pre> <p>If you're unsure of the state of a number after doing some operations on it and you need  an integer, <code>math.floor</code> or <code>math.ceil</code> will cut off the decimal. Prefer <code>math.floor</code> for  calculations in your mods, since the original games would.</p> <pre><code>-- No error\nlocal x = 1.5\nx = math.floor(x) | 2\n</code></pre>"},{"location":"lua/variables/strings/","title":"Strings","text":"<p>Strings are words, letters, and so on. </p>"},{"location":"lua/variables/strings/#creating-a-string","title":"Creating a String","text":"<p>You can create a String by wrapping any characters in quotation marks or single quotes.</p> <pre><code>local str = \"Hello\"\nlocal str_2 = 'World'\nlocal num_str = \"123\"\n</code></pre> <p>You can also wrap the characters with double brackets, but I won't cover that here.</p>"},{"location":"lua/variables/strings/#string-concatenation","title":"String Concatenation","text":"<p>You can't use math operators on a String, but you can still \"add\" them together using the  concatenation operator, <code>..</code> (two dots).</p> <p>You can put spaces between the operator and the Strings. I usually won't in my code and  examples.</p> <pre><code>local player_name = player:get_name()\nlocal str = \"Player name is \"\n\nprint(str..player_name)\n</code></pre> <p>You can also concatenate numbers, which will automatically be converted to a String.</p> <pre><code>local hp = player:get_health()\n\nprint(\"Player has \"..hp..\" HP\")\n</code></pre>"},{"location":"lua/variables/strings/#escape","title":"Escape","text":"<p>You'll notice that you can't use quotation marks in your String if you define the String  using them. You can escape the character with a backslash to make it clear to the  program that you aren't ending the String yet, and are instead literally using that character.</p> <pre><code>-- Hello \"World\"\nlocal str = \"Hello \\\"World\\\"\"\n</code></pre>"},{"location":"lua/variables/strings/#escape-characters","title":"Escape Characters","text":"<p>Typical escape characters are also present. If you don't know what those are or what that means,  the only one you'll likely be using in your modding adventures is <code>\\n</code>.</p> <p><pre><code>local str = \"Hello\\nWorld\"\n</code></pre> If you printed out the above String, you would see <pre><code>Hello\nWorld\n</code></pre> <code>\\n</code> creates a newline at that place in the String. It can be useful for formatting some debug prints  in a way that's nicer to look at.</p> <pre><code>local hp = player:get_health()\nlocal new_hp = math.max(0, hp - 200)\n\nprint(\"HP before: \"..hp..\"\\nHP After: \"..new_hp)\n</code></pre> <pre><code>HP before: 1000\nHP after: 800\n</code></pre>"},{"location":"lua/variables/strings/#equality","title":"Equality","text":"<p>Strings are equal to another String with exactly the same characters in the same order.</p> <pre><code>local str = \"Hello \"\nlocal str_2 = \"Hello\"\nlocal str_3 = \"Hello \"\n\n-- false\nprint(str == str_2)\n-- true\nprint(str == str_3)\n</code></pre>"},{"location":"lua/variables/strings/#restrictions","title":"Restrictions","text":"<p>In ONB, we don't have access to the String library. You will not be able to check for specific  characters or their position, check for substrings or patterns, capitalize and lowercase, and  so on.</p>"},{"location":"lua/variables/strings/#warnings","title":"Warnings","text":"<p>When creating a String that will be displayed to a player, such as the name of a Player Character,  or the name a chip, keep in mind that we are \"restricted\" to the characters that are valid for the  font used. Unfortunately, accuracy to BN means that there are many fonts used for many different things,  so keep this in mind as you assign Strings.</p> <p>For example, in text boxes, you'll see periods just fine. But the font used to display a Player's name  in battle does not have that character, so it can't be displayed properly.</p> <p>Characters used that aren't in the font will often be shown as a tiny capital A.</p>"},{"location":"lua/variables/tables/","title":"Tables","text":"<p>Tables are basically the backbone of Lua. A lot of strong behavior and logic will hinge  on your understanding and usage of these.</p> <p>They're like arrays and maps in one type. Using them like either will have their own  sections here, but you can also do both at the same time.</p> <p>This is a more complex type, so I recommend doing additional reading. A lot more can  be done with tables that I don't touch on. See the manual.</p>"},{"location":"lua/variables/tables/#creating-a-table","title":"Creating a Table","text":"<p>Tables are created using a pair of curly braces <code>{}</code>.</p> <pre><code>local my_table = {}\n</code></pre> <p>You can construct a table and assign it data at the same time by separating data with commas.</p> <pre><code>local my_table = {\n    \"Hello\",\n    \"World\",\n    100,\n    {}\n}\n</code></pre> <p>Here, a table was created with data in integer indexes staring at 1, NOT 0. The String <code>\"Hello\"</code> is stored at index 1, <code>\"World\"</code> at index 2, and the number <code>100</code> is  stored at index 3. Finally, an empty table is stored at index 4.</p>"},{"location":"lua/variables/tables/#string-indexes","title":"String Indexes","text":"<p>Strings can also be indexes. You can construct a table with data at String indexes.</p> <pre><code>local my_table = {\n    str = \"Hello\",\n    100\n}\n</code></pre> <p>Here, a table was created with String index <code>\"str\"</code> containing <code>\"Hello\"</code>, and numerical index  <code>1</code> containing <code>100</code>.</p>"},{"location":"lua/variables/tables/#variable-indexes","title":"Variable Indexes","text":"<p>You can also use brackets, which allow the usage of a variable as the index or a number outside  of the sequential order.</p> <pre><code>local x = 10\nlocal str = \"Hello\"\n\nlocal my_table = {\n    [20] = x,\n    [x] = -13,\n    [str] = 0,\n    str = -1\n}\n</code></pre>"},{"location":"lua/variables/tables/#adding-and-accessing-data","title":"Adding and Accessing Data","text":"<p>You can add data to a table by storing it at an index, and access it using that index. These indexes can be Strings or integers. They can also be other things, but you are very unlikely to want to do that,  so I won't talk about it.</p>"},{"location":"lua/variables/tables/#integer-indexes","title":"Integer Indexes","text":"<p>Integer indexes are automatically assigned when constructing a table without explicitly declaring an  index. In this case, they start at <code>1</code>. </p> <p>Data can be accessed and set using brackets <code>[]</code>, with the index inside.</p> <pre><code>local my_table = {\n    \"Hello\",\n    \"World\",\n    100,\n    {}\n}\n\n-- Hello\nprint(my_table[1])\n-- World\nprint(my_table[2])\n-- 100\nprint(my_table[3])\n-- Pointer to the empty table\nprint(my_table[4])\n-- nil\nprint(my_table[5])\n\nmy_table[5] = 2\n-- 2\nprint(my_table[5])\n</code></pre> <p>You can also add data at numerical indexes by calling <code>table.insert</code>, passing in the table and  the data to add. The data will be added after the last numerical index in sequence.</p> <pre><code>local my_table = {\n    2, \n    4, \n    6\n}\n\n--[[\n    Table is now equivalent to\n\n    {\n        [1] = 2,\n        [2] = 4,\n        [3] = 6,\n        [4] = 8\n    }\n]]\ntable.insert(my_table, 8)\n</code></pre> <p>By adding one more parameter between the table to insert into and the value to insert, you can specify  the index to insert at, as long as the index specified is at the end of the sequential numerical indexes  or is a numerical index that has a value. This will push data at any numerical index at and after this  point up.</p> <pre><code>local my_table = {\n    2, \n    4, \n    6\n}\n\n--[[\n    Table is now equivalent to\n\n    {\n        [1] = 2,\n        [2] = 8,\n        [3] = 4,\n        [4] = 6\n    }\n]]\ntable.insert(my_table, 2, 8)\n</code></pre>"},{"location":"lua/variables/tables/#string-indexes_1","title":"String Indexes","text":"<p>Data at String indexes, like integer indexes, can be accessed with brackets <code>[]</code> and the index inside.</p> <pre><code>local my_table = {\n    str = \"Hello\"\n}\n\n-- Hello\nprint(my_table[\"str\"])\n\nmy_table[\"str\"] = \"World\"\n-- World\nprint(my_table[\"str\"])\n\nmy_table[\"num\"] = 2\n-- 2\nprint(my_table[\"num\"])\n</code></pre> <p>There's also a shorthand access that can be done using a dot.</p> <pre><code>local my_table = {\n    str = \"Hello\"\n}\n\n-- Hello\nprint(my_table.str)\n\nmy_table.str = \"World\"\n-- World\nprint(my_table.str)\n\nmy_table.num = 2\n-- 2\nprint(my_table.num)\n</code></pre> <p>Most code examples will use this type of \"dot\" access.</p>"},{"location":"lua/variables/tables/#nested-tables","title":"Nested Tables","text":"<p>As you might have noticed in the first example, a table can contain a table. Accessing  members of this nested table works as expected.</p> <pre><code>function pr()\n    print(\"Hello Nested World\")\nend\n\nlocal my_table = {\n    {\n        [10] = 4\n    },\n\n    table = {print = pr}\n}\n\n-- 4\nprint(my_table[1][10])\n\n-- Hello Nested World\nmy_table.table.print()\n</code></pre>"},{"location":"lua/variables/tables/#removing-data","title":"Removing Data","text":"<p>To remove data, simply set the value to <code>nil</code>. </p> <pre><code>local  my_table = {\n    2,\n    4,\n    6\n}\n\nmy_table[3] = nil\n</code></pre> <p>You may also call <code>table.remove</code> to remove from the end, or give it a number to remove a specific  index and move all other numerical indexes down around it. <code>table.remove</code> will return the removed value.</p> <pre><code>local  my_table = {\n    2,\n    4,\n    6\n}\n\n--[[\n    Table is now equivalent to\n\n    {\n        [1] = 4,\n        [2] = 6\n    }\n]]\nlocal removed = table.remove(my_table, 1)\n\n--2\nprint(removed)\n</code></pre> <pre><code>local  my_table = {\n    2,\n    4,\n    6\n}\n\n--[[\n    Table is now equivalent to\n\n    {\n        [1] = 2,\n        [2] = 4\n    }\n]]\ntable.remove(my_table)\n</code></pre>"},{"location":"lua/variables/tables/#table-length","title":"Table Length","text":"<p>There's a special operator to count the number items in a table. <code>#</code> placed before the table  will return the number of sequential integer indexes, starting at <code>1</code>, which have a value.</p> <pre><code>local my_table = {\n    [0] = 0,\n    2,\n    4,\n    8,\n    [5] = 10,\n    str_index = 12\n}\n\n--[[\n    This prints 3.\n\n    6 values are in the table, but one is a String index, \n    one is at index 0, and one is not in sequence by skipping \n    ahead by a number.\n]]\nprint(#my_table)\n</code></pre>"},{"location":"lua/variables/tables/#nil-values","title":"Nil Values","text":""},{"location":"lua/variables/tables/#accessing","title":"Accessing","text":"<p>Accessing data at an index which does not have any data is safe. <code>nil</code> will be given  as the value.</p> <pre><code>local my_table = {}\n\n-- nil\nprint(my_table[2])\n-- nil\nprint(my_table.string_index)\n</code></pre>"},{"location":"lua/variables/tables/#sequential-indexes","title":"Sequential Indexes","text":"<p>For certain operations, it will matter that data is stored in sequential integer indexes,  starting at 1. A consequence of <code>nil</code> being considered empty and nonexistent is that it can  break up a table.</p> <pre><code>local my_table = {\n    2,\n    4,\n    6,\n    8\n}\n\nmy_table[4] = nil\n\n--[[ \n    This will throw an out of bounds error, because index `4` is\n    completely disconnected from the sequence.\n]]\ntable.insert(my_table, 3, 6)\n</code></pre> <p>This matters for counting as well.</p> <pre><code>local my_table = {\n    2,\n    4,\n    nil,\n    8\n}\n\n--[[\n    Prints `2`, not `3`.\n]]\nprint(#my_table)\n</code></pre> <p>And iterating using <code>ipairs</code>, but not <code>pairs</code>.</p> <pre><code>local my_table = {\n    2,\n    4,\n    nil,\n    8\n}\n\nlocal visited_indexes = 0\n\nfor k, v in ipairs(my_table) do\n    visited_indexes = visited_indexes + 1\nend\n\n-- 2\nprint(visited_indexes)\n\nlocal visited_pairs_indexes = 0\n\nfor k, v in pairs(my_table) do\n    visited_pairs_indexes = visited_pairs_indexes + 1\nend\n\n-- 3\nprint(visited_pairs_indexes)\n</code></pre>"},{"location":"lua/variables/tables/#objects","title":"Objects","text":"<p>Tables can function similarly to objects in other languages. This is covered in  another section.</p>"},{"location":"onb_overview/","title":"Overview","text":"<p>The pages under this tab will introduce you to some of the tools Open Net  Battle offers, and give a sort of \"tech\" overview. I won't go deep into object usage in this section, nor will I document every aspect of them. </p> <p>You will not find documentation of every engine function in these pages. For that, see here: https://paintylux.github.io/OpenNetBattleDocs. Make sure to click into the <code>Main Docs</code>, <code>Classes &amp; Functions</code>, and <code>Code Snippets</code> tabs.</p> <p>Those linked docs are incomplete, and some information may be a little inaccurate. Just  small things that you might notice. For example, some index access is shown to use a colon  in places where you might have to use a period. If you find any information here that contradicts what you could find there, trust what I write. </p>"},{"location":"onb_overview/#capitalized-words","title":"Capitalized Words","text":"<p>Every time you see the name of an object type and it's capitalized, I'm referring to the  object type. Pay attention to this when wording would otherwise be ambiguous, like when  a variable named <code>tile</code> refers to a Tile class object.</p> <p>You'll notice this mostly when I talk about Player, the object, versus player, the person  behind the screen playing the game. Be careful not to confuse those.</p>"},{"location":"onb_overview/entities/","title":"Entity Class","text":"<p>The base class of things that appear on the field during battle. The player character,  an explosion effect, a pillar of fire, an enemy\u2014all of these are types of Entity.</p> <p>In the below sections, you will read about each type of Entity in the engine:</p> <ul> <li>Artifact</li> <li>Spell</li> <li>Obstacle</li> <li>Character</li> <li>Player</li> </ul> <p>Each of these types should be used in different scenarios, so be sure to understand  each one and use the most appropriate. </p>"},{"location":"onb_overview/entities/#scripted-version","title":"\"Scripted\" Version","text":"<p>I left out some types of Entity from the above list. For each Entity type (and most non-Entity  types), the engine has a second, very similar class:</p> <ul> <li>ScriptedArtifact</li> <li>ScriptedSpell</li> <li>ScriptedObstacle</li> <li>ScriptedCharacter</li> <li>ScriptedPlayer</li> </ul> <p>For the most part, there is not much difference between each class and its \"Scripted\"  counterpart. In these pages, I usually don't make the distinction and use them interchangeably, but keep an eye out for when I specifically mention the Scripted versions. They sometimes  have additional functionality and functions.</p> <p>Generally, when you create an instance of the class, it will be a Scripted version. When you are given an instance of the class, such as through the return value of an  engine function, it will not be. Except when you are \"given\" a reference in a defined  callback on the object, seen in the below callbacks section.</p> <p>When in doubt, use <code>print</code> to check the type. The console will tell you if it's a  Scripted version or not.</p>"},{"location":"onb_overview/entities/#is-a-relationship","title":"Is-A Relationship","text":"<p>In object oriented programming, you will often see a base class that other classes  inherit from. This means that those classes, those types of objects, have some things  in common. </p> <p>An Artifact is an Entity.  A Spell is an Entity. An Obstacle is an Entity. A Character is an Entity. A Player is an Entity. They all share traits with Entity.</p> <p>For descendants of Entity, this means they have access to many of the same functionality.  Everything outlined on this page, and more, applies to every other type of Entity.</p> <p>I will often be general in wording and say something affects Entities, or something  searches for Entities. You will also see this wording in the code. Know that that means  the function, code, logic, or intent applies to all types of Entity.</p> <p>Look out for this phrasing as you read.</p>"},{"location":"onb_overview/entities/#id","title":"ID","text":"<p>The engine keeps a running tally of created Entities. Whenever a new Entity is created,  it's assigned a unique ID in sequence. This ID can be used to identify the Entity without  storing a reference to the Entity, and is required for a few functions.</p> <pre><code>local artifact = Battle.Artifact.new()\nlocal spell = Battle.Spell.new(Team.Red)\n\nlocal id_1 = artifact:get_id()\nlocal id_2 = spell:get_id()\n\nprint(id_1)\n-- This number will be 1 higher than id_1\nprint(id_2)\n</code></pre>"},{"location":"onb_overview/entities/#accessible-class-members","title":"Accessible Class Members","text":"<p>Entities have their own, or store a reference to, some other engine class objects.  Below are functions related to these.</p> <p>Each of these classes will have their own page. Be sure to check them for what  you can do with these objects.</p>"},{"location":"onb_overview/entities/#field","title":"Field","text":"<p>An Entity has a Field that they are on. </p> <pre><code>local field = ent:get_field()\n</code></pre> <p><code>get_field</code> will fail if the Entity has not been spawned.</p>"},{"location":"onb_overview/entities/#tile","title":"Tile","text":"<p>An Entity has a single Tile on the Field that it stands on at a time.</p> <pre><code>local tile = ent:get_current_tile()\ntile = ent:get_tile()\ntile = ent:get_tile(Direction.Right, 1)\n</code></pre> <p>The <code>tile</code> returned from these functions can be <code>nil</code> if the Entity has  not been spawned, or if the Entity is not on the Field. (Being absent from  the field is unusual, so you will likely not have to code around it. But be  aware of it.)</p>"},{"location":"onb_overview/entities/#hitprops","title":"HitProps","text":"<p>An Entity has HitProps.</p> <pre><code>local props = ent:copy_hit_props()\nent:set_hit_props(props)\n</code></pre> <p>Only Spells and Obstacles make relevant use of HitProps.</p>"},{"location":"onb_overview/entities/#sprite","title":"Sprite","text":"<p>An Entity has a Sprite.</p> <pre><code>local sprite = ent:sprite()\n</code></pre>"},{"location":"onb_overview/entities/#animation","title":"Animation","text":"<p>An Entity has an Animation.</p> <pre><code>local anim = ent:get_animation()\n</code></pre>"},{"location":"onb_overview/entities/#other-important-values","title":"Other Important Values","text":"<p>There are many other handy fields on Entity. </p>"},{"location":"onb_overview/entities/#facing","title":"Facing","text":"<p>Every Entity is facing either Left or Right. Its Sprite will be drawn facing left  or right based on this. An Entity's facing is a Direction enum  value, but only <code>Direction.Right</code> and <code>Direction.Left</code> are valid.</p> <pre><code>local facing = player:get_facing()\nprint(\"Facing right?\", facing == Direction.Right)\n</code></pre> <p>You can also get the opposite of an Entity's facing using <code>Entity.get_facing_away</code>.</p> <pre><code>local facing_away = player:get_facing_away()\nprint(\"Not facing right?\", facing_away == Direction.Right)\n</code></pre> <p>Most importantly, you can set an Entity's facing.</p> <pre><code>spell:set_facing(player:get_facing())\n</code></pre>"},{"location":"onb_overview/entities/#default-facing","title":"Default Facing","text":"<p>When an Entity is created, it has no facing. You should set its facing. If you don't, it  will be given one when it is spawned, and it may not be what you wanted. </p> <p>If an Entity is spawned without having a facing set, its facing will be set to match the  facing of the Tile it was spawned on. Tiles on the left side of the field have a facing of  Direction.Right, and Tiles on the right side of the Field have a facing of Direction.Left.</p> <p>Essentially, their facing will be set so that they face the center of the screen.</p>"},{"location":"onb_overview/entities/#team","title":"Team","text":"<p>Entities have a Team, which is a Team enum. For Entities which can  be hit, this determines what attacks can hit them.</p> <pre><code>local team = player:get_team()\nprint(\"On Red Team?\", team == Team.Red)\n</code></pre> <p>You can set an Entity's Team with <code>Entity.set_team</code>, which takes a Team as input.</p> <pre><code>local artifact = Battle.Artifact.new()\nartifact:set_team(player:get_team())\n</code></pre> <p>You won't do this often, because most you will give most Entities a Team when you  create them.</p> <p>Changing Player Teams</p> <p>You will usually not want to change an Entity's Team after it has spawned. For  Players, this is even more true. A battle ends when one Team has no members left,  so swapping the Player's team might end the battle.</p>"},{"location":"onb_overview/entities/#default-team","title":"Default Team","text":"<p>Most Entities are given a Team when you create them, but not all. An Artifact will  default to <code>Team.Other</code>. Characters and Players created by a Mob package will default  to the Team of the Tile they spawn on.</p>"},{"location":"onb_overview/entities/#element","title":"Element","text":"<p>Every Entity has an Element, which is an Element enum value.  See the page on Element for their effects.</p> <p>You can set an Entity's Element with <code>Entity.set_element</code>, and fetch it with  <code>Entity.get_element</code>.</p> <pre><code>player:set_element(Element.Fire)\nlocal element = player:get_element()\n-- true\nprint(element == Element.Fire)\n</code></pre> <p>By default, an Entity's Element is <code>Element.None</code>.</p>"},{"location":"onb_overview/entities/#callbacks","title":"Callbacks","text":"<p>Entities have some indexes which are used as callback functions. They are often <code>nil</code> by default, but can be set to a function which the  engine will call under certain conditions.</p> <p>Many callbacks pass <code>self</code> in. Expect the same type that the Entity on the  lefthand side of the <code>.</code> is.</p> <p>Many of these callbacks only exist and can be set on the Scripted class  versions.</p>"},{"location":"onb_overview/entities/#update_func","title":"update_func","text":"<p>An Entity's <code>update_func</code> takes the Entity as a parameter. It will be  called no more than once during a frame, and will be called alongside the  Entity's update. </p> <p>It will not be called in a frame if the Entity will not update during that frame. </p> <pre><code>ent.update_func = function(self)\n    print(\"Update\")\nend\n</code></pre>"},{"location":"onb_overview/entities/#delta-time","title":"Delta Time","text":"<p>The update_func actually has one more input, a delta time <code>dt</code>, in milliseconds,  since the last frame. It will nearly always be equal to <code>1/60</code>. I omit it here  for two reasons:</p> <ol> <li>It will be removed in the next engine update.</li> <li>It encourages you to make logic that is not based on frame numbers and that  may be vulnerable to floating point imprecision.</li> </ol> <p>For point 2, the latter reason may be a non-issue in almost all cases. But it's  more correct to use frame numbers as a basis for logic in an engine that is precisely  based on frame timing. You are less likely to regret it.</p> <p>If you need to count or time something, remember that this callback will run once  every frame.</p> <pre><code>spell.delay = 5\nspell.update_func = function(self)\n    if self.delay == 0 then\n        print(\"Did nothing for 5 frames\")\n    end\n\n    self.delay = self.delay - 1\nend\n</code></pre>"},{"location":"onb_overview/entities/#on_spawn_func","title":"on_spawn_func","text":"<p>The <code>on_spawn_func</code> takes the Entity as a parameter. The engine will call it when  the Entity is successfully spawned. It will run only once in an Entity's lifetime.</p> <pre><code>ent.on_spawn_func = function(self)\n    print(\"Spawned entity with ID \"..self:get_id())\nend\n</code></pre> <p>Fact Check Needed</p> <p>This notice will be removed once I check if it can run for an Entity which failed  to spawn.</p>"},{"location":"onb_overview/entities/#battle_start_func","title":"battle_start_func","text":"<p>The <code>battle_start_func</code> takes the Entity as a parameter. The engine will call it  when battle starts. This will happen only once.</p> <pre><code>ent.battle_start_func = function(self)\n    print(\"Battle started.\")\nend\n</code></pre> <p>This callback may run later than you would expect. Specifically, it will be called  on the first frame the player gains control after clicking OK on the Custom Screen.  This will be just as the \"Battle Start\" text disappears.</p> <p>Fact Check Needed</p> <p>This notice will be removed once I check if it runs at the start of this frame, or the end of the previous one.</p> <p>Because it runs only once, an Entity that is spawned after this will never have its  callback run.</p> <p>Fact Check Needed</p> <p>This notice will be removed once I check if it only runs for Entities which exist  as the battle is created. </p>"},{"location":"onb_overview/entities/#battle_end_func","title":"battle_end_func","text":"<p>The <code>battle_end_func</code> takes the Entity as a parameter. It will run when the battle ends. Specifically, when the text saying \"Enemy Deleted\" or similar begins to appear.</p> <pre><code>player.battle_end_func = function(self)\n    print(\"Battle ended.\")\nend\n</code></pre> <p>Currently, this callback only runs for Players. In the future, other Entity types will  have access to it.</p> <p>Fact Check Needed</p> <p>This notice will be removed once I check if it only runs for Entities which exist  as the battle is created, which Players are. I also need to check if it runs for  all Characters.</p>"},{"location":"onb_overview/entities/#can_move_to_func","title":"can_move_to_func","text":"<p>The <code>can_move_to_func</code> takes a Tile as paramter. It will be called whenever  the Entity attempts a MoveEvent, and the destination Tile for the MoveEvent  will be passed in.</p> <p>The engine expects a boolean value to be returned. If <code>true</code> is returned,  you are telling the engine that the movement to that Tile is OK and should  be allowed to continue. If <code>false</code> is returned, you are telling the engine to  reject the movement.</p> <pre><code>spell.can_move_to_func = function(tile)\n    return tile:is_walkable()\nend\n</code></pre> <p>A common mistake when making a projectile that should move across the screen  is forgetting to define a <code>can_move_to_func</code>. Without it, the engine will  believe that all MoveEvents should fail.</p> <p>This callback will not be used for any type of Player. </p>"},{"location":"onb_overview/entities/#delete_func","title":"delete_func","text":"<p>The <code>delete_func</code> takes the Entity as parameter. It will be called immediately  when the Entity is marked for deletion by the <code>Entity.delete</code> function.</p> <p><pre><code>spell.delete_func = function(self)\n    print(\"Deleted\")\nend\n\nprint(\"About to delete\")\nspell:delete()\nprint(\"Finished deleting\")\n</code></pre> The above code would output</p> <pre><code>About to delete\nDeleted\nFinished deleting\n</code></pre> <p>The <code>delete_func</code> will not be called more than once.</p>"},{"location":"onb_overview/entities/#deletion","title":"Deletion","text":"<p>An Entity can be marked for deletion at the end of the frame by calling <code>Entity.delete</code>.</p> <pre><code>spell:delete()\n</code></pre> <p>This will cause the Entity's <code>delete_func</code> callback to run.</p> <p>Once <code>delete</code> has been called, the Entity is put into a state where it is waiting to  be removed from the field. The Entity \"is deleted\" already.</p> <p>While deleted, certain actions cannot be taken on the Entity object. If you try, you'll  see an error appear telling you that data is deleted. Your code should often have  safeguards when handling Entity references because of this, especially if the reference  is kept and accessed across frames.</p> <pre><code>--[[\n    Runs every frame. `player` could be deleted by the next \n    time this runs, so check.\n]]\nspell.update_func = function(self)\n    if player:is_deleted() then \n        return\n    end\n\n    print(player:get_current_tile():x())\nend\n</code></pre> <p>At some point, the \"deleted\" Entity will be removed from the field.</p> <p>Missing Info</p> <p>This notice will be removed once I check when exactly they are removed.</p>"},{"location":"onb_overview/entities/#erase","title":"erase","text":"<p>There is another function similar to <code>Entity.delete</code>. This is <code>Entity.erase</code>.</p> <pre><code>spell:erase()\n</code></pre> <p>My recommendation is to never call it, and to always use <code>Entity.delete</code> if you  want to delete something. This is because <code>Entity.erase</code> will skip running an  Entity's <code>Entity.delete_func</code> callback, which may have had important cleanup  logic. </p> <p>One benefit to <code>Entity.erase</code> is that the Entity will not be drawn the frame  it's called, unlike <code>Entity.delete</code>. But calling <code>Entity.delete</code> with a call to  <code>Entity.hide</code> will accomplish the same, without compromising <code>Entity.delete_func</code>.</p>"},{"location":"onb_overview/entities/artifact/","title":"Artifact","text":"<p>Artifacts are the lightest Entity type. They have the least logic associated with them. </p>"},{"location":"onb_overview/entities/artifact/#creating-an-artifact","title":"Creating an Artifact","text":"<p>Calling <code>Battle.Artifact.new()</code> will return a new Artifact object. Like every  other type of Entity, it will need to be spawned on the Field before it will  do anything.</p> <pre><code>local artifact = Battle.Artifact.new()\n</code></pre>"},{"location":"onb_overview/entities/artifact/#when-to-use","title":"When to Use","text":"<p>Artifacts should only be used for purely graphical effects. Tying any sort  of logic to them beyond that is often a mistake, due to their update timing.</p> <p>Other Entity types may only update during time freeze if they were spawned  during that time freeze, and the next time time freezes they will not update  during it. An Artifact, on the other hand, will continue to update during every  time freeze. </p> <p>This is perfect for a graphical effect, so it can continue to animate, finish its  animation, and remove itself without blocking the players' view for very long. But  if you have any logic that affects the battle tied to it, the timing can be thrown  completely off by time freeze beginning during it.</p>"},{"location":"onb_overview/entities/character/","title":"Character","text":"<p>Characters can take damage and use CardActions. They display their HP below their sprite. They also have a \"Rank\". Deleting them affects final battle results.</p>"},{"location":"onb_overview/entities/character/#creating-a-character","title":"Creating a Character","text":"<p>Calling <code>Battle.Obstacle.new(Team, Rank)</code> will return a new Character object. Like  every other type of Entity, it will need to be spawned on the Field before it will  do anything.</p> <pre><code>local character = Battle.Character.new(team, rank)\n</code></pre> <p>The <code>team</code> variable in the above code snippet must be a Team enum value, and <code>rank</code>  must be a Rank enum value. </p> <p>You will usually not directly call the function to create a Character, since it  will be handled for you in Mob packages. </p>"},{"location":"onb_overview/entities/character/#from-character-id","title":"From Character ID","text":"<p>There is no loadable mod package specifically for Characters, but you can still define a Character and give it a unique package ID. How to do this will be covered in a  different section.</p> <p>If you know a Character's ID, you can create that Character, calling its <code>package_init</code> in the process, using that ID.</p> <pre><code>local character = Battle.Character.from_package(id, team, rank)\n</code></pre> <p>Mod Sync</p> <p>When mods sync for PvP, a library that defines the Character with that ID might  not have been shared Be wary of using this in a context where the function could be  called in PvP.</p>"},{"location":"onb_overview/entities/character/#when-to-use","title":"When to Use","text":"<p>You will typically use Characters when you want to create a more character-like  Entity, something that has movement and attack patterns. Enemies are the most  common Character uses.</p>"},{"location":"onb_overview/entities/character/#character-or-obstacle","title":"Character or Obstacle","text":"<p>When deciding whether to use Characters or Obstacles, keep the following in mind:</p> <ol> <li>Characters can be counterhit, granting FullSynchro and a bonus towards Busting Level</li> <li>Characters can be double- or triple-deleted, putting text on the screen and granting  a bonus to Busting Level</li> <li>Characters are made to be able to easily respond to Rank, to allow you to set different  stats, colors, behavior, etc. for different versions of the same Character (like V1 and V2 bosses)</li> </ol>"},{"location":"onb_overview/entities/character/#type-checking","title":"Type Checking","text":"<p>You can test if an Entity is a Character. The <code>Battle.Character.from(entity)</code> function  call will return a Character cast of the input Entity if it was a Character, or <code>nil</code>  if it was not.</p> <pre><code>spell.attack_func = function(self, other)\n    local p = Battle.Character.from(other)\n    if p ~= nil then \n        print(\"Damaged a Character\")\n    else\n        print(\"Damaged a different type of Character\")\n    end\nend\n</code></pre> <p>Remember that a Player is a Character, so <code>Battle.Character.from(entity)</code> when  <code>entity</code> is a Player will return a Character object, not nil.</p>"},{"location":"onb_overview/entities/obstacle/","title":"Obstacle","text":"<p>Obstacles are non-Characters which can take damage. Unlike Characters, they  do not display their HP, and they don't count towards any battle results.</p>"},{"location":"onb_overview/entities/obstacle/#creating-an-obstacle","title":"Creating an Obstacle","text":"<p>Calling <code>Battle.Obstacle.new(Team)</code> will return a new Obstacle object. Like every  other type of Entity, it will need to be spawned on the Field before it will  do anything.</p> <pre><code>local obstacle = Battle.Obstacle.new(team)\n</code></pre> <p>The <code>team</code> variable in the above code snippet must be a Team enum value. </p> <p>Don't forget to give it a health value after creating one, or else it will not  be able to get hit. The first call to <code>Obstacle.set_health</code> will also set its max health.</p> <pre><code>local obstacle = Battle.Obstacle.new(team)\n\n-- 0\nprint(obstacle:get_max_health())\n\nobstacle:set_health(200)\n\n-- 200\nprint(obstacle:get_max_health())\n</code></pre>"},{"location":"onb_overview/entities/obstacle/#when-to-use","title":"When to Use","text":"<p>Things like RockCube or Anubis are often called \"objects\", or maybe \"summons\"  by Battle Network players. These are the sorts of things you would replicate  using an Obstacle.</p> <p>Their use is not limited to just those, however. Remember, an Obstacle is just  something that can take damage that isn't a Character. You might use them for  detecting a hit on a different Tile, or an attack that can be destroyed, like  PropellerBomb from BN4, or CutMan's scissors which block attacks.</p>"},{"location":"onb_overview/entities/obstacle/#obstacle-limit","title":"Obstacle Limit","text":"<p>BN players may remember that certain objects they spawn have a limit. You can  only have two RockCubes on your field before trying to spawn a third will  destroy the first, or you might want to use Prism and BlkBomb at the same time,  but trying to throw the BlkBomb will destroy the Prism. The limit is based on  a sort of \"type\" of object, where certain objects fit into the type that allows  2 slots, and others fit into the 1 slot type. Others still, like FlashBomb from  BN6, can be thrown without ever affecting other field objects.</p> <p>These limits do not exist and are not enforced in ONB. Modders have created  importable scripts to add the behavior to your Obstacles, with a short an opt-in  process.This will be talked about in another section. Until then, you can find me  (Alrysc) on the ONB Discord server and ask about my ObstacleInfo library.</p>"},{"location":"onb_overview/entities/obstacle/#attacking","title":"Attacking","text":"<p>Obstacles are allowed to attack and deal damage in the same way as Spells. See  similar sections on the Spells page.</p>"},{"location":"onb_overview/entities/obstacle/#type-checking","title":"Type Checking","text":"<p>You can test if an Entity is an Obstacle. The <code>Battle.Obstacle.from(entity)</code> function  call will return an Obstacle cast of the input Entity if it was an Obstacle, or <code>nil</code>  if it was not.</p> <pre><code>spell.attack_func = function(self, other)\n    local ob = Battle.Obstacle.from(other)\n    if ob ~= nil then \n        print(\"Damaged an Obstacle\")\n    else\n        print(\"Damaged a different type of Entity\")\n    end\nend\n</code></pre>"},{"location":"onb_overview/entities/player/","title":"Player","text":"<p>Players are Characters that are controlled by the one playing the game.  They have their own mod package type, and additional stats and functions.</p>"},{"location":"onb_overview/entities/player/#creating-a-player","title":"Creating a Player","text":"<p>You cannot create a Player object. You will explicity be given a ScriptedPlayer in the function parameters of the <code>player_init</code> in a Player mod file.</p>"},{"location":"onb_overview/entities/player/#stats","title":"Stats","text":"<p>In addition to health, Players have a few extra stats.</p>"},{"location":"onb_overview/entities/player/#attack-level","title":"Attack Level","text":"<p>Players have an attack level, which is an integer ranging from 1 to 5. By default,  it is 1.</p> <p>You can use <code>Player.get_attack_level</code> to get the current attack level, and  <code>player.set_attack_level</code> to set a new one. </p> <pre><code>local current_attack = player:get_attack_level()\n\n-- 1\nprint(current_attack)\n\nplayer:set_attack_level(current_attack + 10)\n\n-- 5, because it's capped\nprint(player:get_attack_level())\n</code></pre> <p>A Player's attack level is often used in the formula to determine the damage their  attacks will do.</p>"},{"location":"onb_overview/entities/player/#charge-level","title":"Charge Level","text":"<p>Players have a charge level, which affects how fast they can charge for their charged attack. See Charging for specific speeds.</p> <p>Charge level is an integer ranging from 1 to 5. By default, it is 1.</p> <pre><code>local current_charge = player:get_charge_level()\n\n-- 1\nprint(current_charge)\n\nplayer:set_charge_level(current_charge + 10)\n\n-- 5, because it's capped\nprint(player:get_charge_level())\n</code></pre>"},{"location":"onb_overview/entities/player/#charging","title":"Charging","text":"<p>While holding the Shoot button, a Player will begin to charge. There are three states  to charging:</p> <ol> <li>For the first 10 frames, there is no visual cue that charging has started</li> <li>After the first 10 frames, a graphic appears</li> <li>After the full charge time, the graphic changes and changes color</li> </ol> <p>While in the third state, releasing the Shoot button will call the <code>charged_attack_func</code>.</p> <p>It takes 110 frames to reach full charge. The Player cannot charge during another action. Anything that would end an active action will also reset the charge. </p>"},{"location":"onb_overview/entities/player/#charge-speed","title":"Charge Speed","text":"<p>It takes 110 frames to reach full charge at charge level 1. The higher the Player's charge level, the less time it will take. Specifically, 10 frames are cut off for each level. The  formula would be something like:</p> <p><code>120 - 10 * c</code></p> <p>where <code>c</code> is the charge level. Keep in mind that charge level will be a number from 1 to 5,  hence the 110 frame time at level 1.</p> <p>Late Charge Level Effect</p> <p>In v2.0, charge level will not affect charge speed until the Player has flinched.</p>"},{"location":"onb_overview/entities/player/#changing-the-formula","title":"Changing the Formula","text":"<p>Currently, a Player's base form cannot have a different charge time formula than what is  described above. In the future, it will be possible. For now, only a PlayerForm can have  a different forumla.</p>"},{"location":"onb_overview/entities/player/#built-in-cardactions","title":"Built-In CardActions","text":"<p>ScriptedPlayers have three definable functions that can return CardActions, which  will be called by the engine under certain circumstances.</p>"},{"location":"onb_overview/entities/player/#normal_attack_func","title":"normal_attack_func","text":"<p>The <code>normal_attack_func</code> will run when the player presses the Shoot button  while the Player is actionable. It takes the ScriptedPlayer as input and expects  to return a CardAction.</p> <p>A common CardAction to return is the Buster action, which replicates MegaMan's  normal attacks in the official games when given <code>false</code> as the second parameter.</p> <pre><code>player.normal_attack_func = function(self)\n    -- false to use normal attack graphics on hit, attack level as damage\n    return Battle.Buster.new(self, false, self:get_attack_level())\nend\n</code></pre>"},{"location":"onb_overview/entities/player/#charged_attack_func","title":"charged_attack_func","text":"<p>The <code>charged_attack_func</code> will run when the player releases the Shoot button after  holding it for long enough to become fully charged. It takes the ScriptedPlayer as  input and expects to return a CardAction.</p> <p>A common CardAction to return is the Buster action, which replicates MegaMan's  charged attacks in the official games when <code>true</code> is given as the second parameter.</p> <pre><code>player.charged_attack_func = function(self)\n    --[[\n        true to use charged attack graphics on hit and charged attack\n        framedata, attack level * 10 as damage\n    ]]\n    return Battle.Buster.new(self, true, self:get_attack_level() * 10)\nend\n</code></pre>"},{"location":"onb_overview/entities/player/#special_attack_func","title":"special_attack_func","text":"<p>The <code>special_attack_func</code> will run when the player releases the Special button  while the Player is actionable. It takes the ScriptedPlayer as input and expects  to return a CardAction. </p> <p>The Special button is intended to parallel the B+Back input from the official  games. </p> <pre><code>-- Play the \"PLAYER_HIT\" animation and do nothing else\nplayer.special_attack_func = function(self)\n    local action = Battle.CardAction.new(self, \"PLAYER_HIT\")\n\n    return action\nend\n</code></pre>"},{"location":"onb_overview/entities/player/#inputs","title":"Inputs","text":"<p>You can read the player's inputs from their associated Player using the <code>Player.input_has</code>  function, passing in the input to check for. These are represented by the Input enum  values.</p> <p>Inputs come in three types:</p> <ol> <li>Pressed, true only on the exact frame a button was pressed down</li> <li>Held, true every frame the button is down after the first</li> <li>Released, true on the exact frame a button was let up</li> </ol> <p>Only one of the above types will be <code>true</code> at a time for one input.</p> <p>Frame Step</p> <p>In v2.0, the tracking for held button inputs continues to advance even while  the engine is paused. This means it's difficult, if not impossible, to read a  Pressed input while frame stepping.</p> <pre><code>if player:input_has(Input.Pressed.Shoot) then \n    print(\"Shoot button was pressed this frame\")\nend\n</code></pre> <pre><code>local count = 0\nspell.update_func = function(self)\n    if player:input_has(Input.Held.Right) then \n        count = count + 1\n        print(\"Holding Right for \"..count..\" frames\")\n    elseif player:input_has(Input.Released.Right) then \n        print(\"Player let go\")\n        self:delete()\n    end\nend\n</code></pre>"},{"location":"onb_overview/entities/player/#forms","title":"Forms","text":"<p>Players have access to a form changing mechanic, a recreation of the Cross system  in Battle Network 6. A player can choose forms that are added to the Player from the  Custom screen, the same as BN6.</p> <p>A Player can have up to 5 forms. You can add one by calling <code>Player.create_form</code>  when the <code>player_init</code> runs. Calling it later will not add the form.</p> <pre><code>function player_init(player)\n    local form_1 = player:create_form()\nend\n</code></pre> <p>This creates a PlayerForm object. These will be detailed in another page.</p>"},{"location":"onb_overview/entities/player/#type-checking","title":"Type Checking","text":"<p>You can test if an Entity is a Player. The <code>Battle.Player.from(entity)</code> function  call will return a Player cast of the input Entity if it was a Player, or <code>nil</code>  if it was not.</p> <pre><code>spell.attack_func = function(self, other)\n    local p = Battle.Player.from(other)\n    if p ~= nil then \n        print(\"Damaged a Player\")\n    else\n        print(\"Damaged a different type of Entity\")\n    end\nend\n</code></pre> <p>Remember that a Player is a Character, so <code>Battle.Character.from(entity)</code> when  <code>entity</code> is a Player will return a Character object, not nil.</p>"},{"location":"onb_overview/entities/player/#checking-for-scriptedplayer","title":"Checking For ScriptedPlayer","text":"<p><code>Battle.Player.from(entity)</code> will return a ScriptedPlayer instead of a Player if  the input Entity is exactly the Player type.</p> <p>Because this is a Scripted type, this means you can access and set user indexes  on the Player. This is commonly used for mods that change normal, charged, or  special attacks.</p> <p>This can be dangerous, however, because you may collide with the names of indexes  the creator of that Player mod added to the Player. Take care when adding any.  Try to use especially unique names, similar to when you choose a package ID name.</p>"},{"location":"onb_overview/entities/spell/","title":"Spell","text":"<p>Spells are nearly synonymous with hitboxes. They are what you will spawn  on the field to do damage to something.</p>"},{"location":"onb_overview/entities/spell/#creating-a-spell","title":"Creating a Spell","text":"<p>Calling <code>Battle.Spell.new(Team)</code> will return a new Spell object. Like every  other type of Entity, it will need to be spawned on the Field before it will  do anything.</p> <pre><code>local spell = Battle.Spell.new(team)\n</code></pre> <p>The <code>team</code> variable in the above code snippet must be a Team enum value. </p>"},{"location":"onb_overview/entities/spell/#when-to-use","title":"When to Use","text":"<p>A Spell is used to attack and deal damage. It's one of the two Entity types  that is allowed to attack, alongside Obstacle.</p>"},{"location":"onb_overview/entities/spell/#attacking","title":"Attacking","text":"<p>We attack using a Spell by telling a Tile (typically its own) to queue an attack. Usually you will see this done during its <code>update_func</code> logic.</p> <pre><code>spell.update_func = function(self)\n    self:get_current_tile():attack_entities(self)\nend\n</code></pre> <p>The above code snippet will, every frame the Spell <code>spell</code> is on the Field, queue  an attack on the Spell's Tile to happen later in the frame, when attacks are  processed.</p> <p>It's important to understand that attacks will happen later in the frame, and  not immediately when you call <code>Tile.attack_entities</code>. </p>"},{"location":"onb_overview/entities/spell/#attack-targets","title":"Attack Targets","text":"<p>All Entities on the Tile will be checked for attacking. Entities which are on the  same Team as the Spell will not be hit, unless the Spell is Team.Other. </p> <p>Only Characters, Obstacles, and Players can be hit by an attack.</p>"},{"location":"onb_overview/entities/spell/#attacking-multiple-times","title":"Attacking Multiple Times","text":"<p>The snippet above will queue an attack every frame, but this does not mean an  Entity standing on the same Tile as a Spell will take damage rapidly. </p> <p>Once a Spell has collided with an Entity, further attacks  on the same Tile will not be queued. You may still queue attacks on other  Tiles which have not yet been hit by this Spell, but if you want to hit again,  you will need to spawn additional Spells.</p> <p>For example, see the code below. A Spell is created which does not attack itself,  but instead spawns another Spell every few frames to do the attack. This allows  you to repeatedly attack the same Tile.</p> <pre><code>function spawn_attack(field, team, props, tile)\n    local spell = Battle.Spell.new(team)\n    spell:set_hit_props(props)\n\n    spell.update_func = function(self)\n        self:get_current_tile():attack_entities(self)\n        -- Only attack for one frame, and then delete. \n        self:delete()\n    end\n\n    field:spawn(spell, tile)\nend\n\nlocal field = player:get_field()\nlocal team = player:get_team()\nlocal tile = player:get_current_tile()\nlocal props = -- Omitted HitProps creation\n\nlocal spell = Battle.Spell.new(team)\n\nlocal frame = 0\nspell.update_func = function(self)\n    if frame % 5 == 0 then \n        spawn_attack(field, self:get_team(), props, self:get_current_tile())\n    end\n\n    frame = frame + 1\nend\n\nfield:spawn(spell, tile)\n</code></pre>"},{"location":"onb_overview/entities/spell/#on-queuing-attacks","title":"On Queuing Attacks","text":"<p>You may have noticed in the above code that I called <code>Tile.attack_entities</code> and then  immediately deleted the Spell used to attack. The attack was queued, so it won't  happen until later in the frame. Then, by the time the attack happens, won't the Spell  be deleted? Can it still attack?</p> <p>The answer is \"Yes\". That queued attack will still go through later in the frame, so  that Spell queuing an attack and then deleting itself will only attack once.</p>"},{"location":"onb_overview/entities/spell/#attack_func","title":"attack_func","text":"<p>ScriptedSpells have an <code>attack_func</code> index that your code can define. It will  run only if and when an attack made by the Spell dealt damage. If it was blocked  by a DefenseRule, it will not run. </p> <p>It takes the Spell and the Entity that was hit as parameter. Modders have taken  to calling the second parameter <code>other</code>, so you will often see that name. I will  also use it here.</p> <pre><code>spell.attack_func = function(self, other)\n    print(\"Spell \"..self:get_id()..\" damaged Entity \"..other:get_id())\nend\n</code></pre>"},{"location":"onb_overview/entities/spell/#collision_func","title":"collision_func","text":"<p>ScriptedSpells have a <code>collision_func</code> index that your code can define. It will  run only if and when an attack made by the Spell collided with the Entity. It  could not run if, for example, an Entity is intangible after being hit with an attack  that had the Hit.Flashing flag. If it does run, it will run before the <code>attack_func</code>,  or may run even if the <code>attack_func</code> does not.</p> <p>It takes the Spell and the Entity that was hit as parameter. Modders have taken  to calling the second parameter <code>other</code>, so you will often see that name. I will  also use it here.</p> <pre><code>spell.collision_func = function(self, other)\n    print(\"Spell \"..self:get_id()..\" collided with Entity \"..other:get_id())\nend\n</code></pre>"},{"location":"onb_overview/entities/spell/#hitbox","title":"Hitbox","text":"<p>There is another type, Hitbox, that is related to Spell. A Hitbox is a Spell. I  briefly mention it here without much detail, mostly because I have never felt the  need to use it. </p> <p>A Hitbox is a Spell which has a few preconfigurations. Notably, it's automatically  set up to queue an attack and delete itself.</p> <p>Overall, however, a Hitbox is more restrictive than a Spell, and often cannot be  used alone to replicate attacks you can find in the official games.</p> <ul> <li>It has no \"Scripted\" version<ul> <li>You cannot set indexes on it to contain your own data</li> </ul> </li> <li>It can't be used with a graphic or animation</li> <li>The attack can only have one active frame (one frame where it can do damage)</li> <li>Setting the <code>collision_func</code> and <code>attack_func</code> indexes is more awkward</li> </ul> <p>A Hitbox can be created in the same way as a Spell.</p> <pre><code>local hitbox = Battle.Hitbox.new(team)\n</code></pre> <p>You must use its <code>Hitbox.set_callbacks</code> function to set both the <code>collision_func</code>  and the <code>attack_func</code> at the same time.</p> <pre><code>local hitbox = Battle.Hitbox.new(team)\n\nlocal function collision_func(self, other)\n    print(\"Hitbox \"..self:get_id()..\" collided with Entity \"..other:get_id())\nend\n\nlocal function attack_func(self, other)\n    print(\"Hitbox \"..self:get_id()..\" damaged Entity \"..other:get_id())\nend\n\n\nhitbox:set_callbacks(attack_func, collision_func)\n</code></pre> <p>In the Attacking Multiple Targets section of this page,  there was a code snippet that would attack one Tile multiple times. In that particular  instance, Hitbox could do the same in fewer lines.</p> <pre><code>function spawn_attack(field, team, props, tile)\n    local hitbox = Battle.Hitbox.new(team)\n    hitbox:set_hit_props(props)\n\n    field:spawn(hitbox, tile)\nend\n\nlocal field = player:get_field()\nlocal team = player:get_team()\nlocal tile = player:get_current_tile()\nlocal props = -- Omitted HitProps creation\n\nlocal spell = Battle.Spell.new(team)\n\nlocal frame = 0\nspell.update_func = function(self)\n    if frame % 5 == 0 then \n        spawn_attack(field, self:get_team(), props, self:get_current_tile())\n    end\n\n    frame = frame + 1\nend\n\nfield:spawn(spell, tile)\n</code></pre>"},{"location":"onb_overview/entities/spell/#sharedhitbox","title":"SharedHitbox","text":"<p>A SharedHitbox is in a similar place to Hitbox. You may see it used in especially  old mods that replicate Sword chips, but it isn't required and I have never felt  the need to use it.</p> <p>You can create a SharedHitbox by passing in an Entity and a time, in milliseconds,  that it will exist for. I'll be referring to that Entity as the SharedHitbox's \"owner\".  The engine source code uses the same name.</p> <pre><code>local spell = Battle.Spell.new(team)\nlocal shared = Battle.SharedHitbox.new(spell, 0.033)\n</code></pre> <p>Frames</p> <p>Remember that 1 in-game frame is roughly equal to 0.0166 seconds. When in doubt, use  <code>frame_count / 60</code>. For example, <code>21/60</code> as the time if you want it to last for 21 frames.</p> <p>A SharedHitbox will reference the HitProps and Team of its owner, as well as its <code>attack_func</code> and  <code>collision_func</code>. When spawned, it will stay on the Field and continually attack its Tile  until the specified amount of time passes. </p> <p>A SharedHitbox will stop attacking before its timer expires if the Entity used to  created it is deleted.</p> <p>No Deletion</p> <p>If the Entity used to create the SharedHitbox is deleted before the timer expires,  the SharedHitbox may not be deleted automatically.</p>"},{"location":"onb_overview/enums/","title":"Enums","text":"<p>Enums are not an actual Lua type, but they are a C++ type, and the engine  gives access to them.</p>"},{"location":"onb_overview/enums/#what-are-enums","title":"What Are Enums","text":"<p>You can think of an enum as a table with String indexes which hold number  values. The number value usually isn't important, but the String is. Its  name will tell you what it should be treated as.</p> <p>They're a way to keep code looking less arbitrary and more readable when  you need logic to respond to certain signals. For example, take the following  code:</p> <pre><code>function do_something(thing, a, b)\n    if thing == 0 then \n        return a + b\n    elseif thing == 1 then \n        return a * b\n    elseif thing == 2 then \n        return a / b\n    end\nend\n\n\n-- 2\nprint(do_something(2, 10, 5))\n</code></pre> <p>When you call <code>do_something</code>, it's a little less clear what the intent is.  Future code changes might add or remove values, and now the <code>2</code> that's given  here might have a different meaning.</p> <p>With enums, we can essentially assign these values a name. Here's how something  else could look:</p> <pre><code>local things = {\n    add = 1,\n    multiply = 2,\n    divide = 3\n}\n\nfunction do_something(thing, a, b)\n    if thing == things.add then \n        return a + b\n    elseif thing == things.multiply then \n        return a * b\n    elseif thing == things.divide then \n        return a / b\n    end\nend\n\n-- 2\nprint(do_something(things.divide, 10, 5))\n</code></pre> <p>Now it's much more clear what the intent is behind each value. When working  with the values given in Lua, the first <code>do_something</code> function, which checked  <code>thing == 0</code> etc., checking against exact numbers, would still work when given the  new <code>things.add</code> and so on, but remember the reasons why we wouldn't refer to the  exact value.</p> <p>Say we had updated the \"enum\" values in a month to now be </p> <pre><code>local things = {\n    add = 1,\n    subtract = 2,\n    multiply = 3,\n    divide = 4\n}\n</code></pre> <p>Now the function which checked exactly == 2 and multiplied is incorrect. The  version that checked for <code>things.multiply</code> will still work as expected.</p>"},{"location":"onb_overview/enums/#enums-in-onb","title":"Enums In ONB","text":"<p>The pages in this section describe the engine enums we have access to from Lua  when modding. There are a couple things you should notice about them:</p> <ol> <li>They always use capitalized names</li> <li>Accessing is just like a Lua table with String indexes</li> <li>Their indexed values are (almost) always numbers</li> </ol> <p>The first point is a reminder that you may want to avoid capitalizing your variable  names. snake_case is perferred. Imagine you had code like this:</p> <pre><code>local Direction = player:get_facing()\n</code></pre> <p>You've now shadowed the actual <code>Direction</code> enum and can't access it in this scope  anymore. You won't be able to test against <code>Direction.Left</code> and so on because now  <code>Direction</code> refers to a number value, which you can't index without error.</p> <p>The third point is a reminder that trying to print values will not be that useful.</p> <pre><code>local facing = player:get_facing()\n\n-- Prints 2... What does that mean?\nprint(facing)\n</code></pre> <p>Because of this, you might instead want to use comparisons to check.</p> <pre><code>local facing = player:get_facing()\n\nprint(\"Facing left? \"..(facing == Direction.Left))\n</code></pre> <p>I won't include the number values of any enums here, because you mostly shouldn't  use them for reasons described above. You can find them in the engine source if  you really need them.</p>"},{"location":"onb_overview/enums/audiopriority/","title":"AudioPriority","text":"<p><code>AudioPriority</code> values are used in calls to <code>Engine.play_audio</code> to describe  how aggressively the audio will try to be played. </p> <p>Similar to the GBA games, ONB has a number of SFX channels. Using certiain  AudioPriority could cause a sound to defer to another, not playing at all  if channels are busy. The following priorities exist:</p> <ul> <li>Lowest</li> <li>Low</li> <li>High</li> <li>Highest</li> </ul>"},{"location":"onb_overview/enums/audiopriority/#usage","title":"Usage","text":"<p><code>Engine.play_audio</code> takes an AudioPriority as its second parameter.</p> <pre><code>Engine.play_audio(SFX_HANDLE, AudioPriority.Low)\n</code></pre> <p><code>SFX_HANDLE</code> in the above snippet must be an audio handle returned from a  call to <code>Engine.load_audio</code>, or an AudioType enum value.</p>"},{"location":"onb_overview/enums/audiopriority/#lowest","title":"Lowest","text":"<p><code>AudioPriority.Lowest</code> plays on a free channel, but other <code>Lowest</code> priority  sounds will not play at the same time.</p>"},{"location":"onb_overview/enums/audiopriority/#low","title":"Low","text":"<p><code>AudioPriority.Low</code> plays the sound a free channel. It can play at the same  time as other sounds. If you ever have issues where a sound doesn't play, using  this priority will solve it.</p>"},{"location":"onb_overview/enums/audiopriority/#high","title":"High","text":"<p><code>AudioPriority.High</code> forces your sound to play, but other High priority can't play  at the same time. This also means your sound won't play if another High priority sound  is currently playing.</p>"},{"location":"onb_overview/enums/audiopriority/#highest","title":"Highest","text":"<p><code>AudioPriority.Highest</code> tries to force your sound to play. </p> <p>Missing Info</p> <p>I'm not sure what the difference between Highest and Low is in practice. This notice  will be removed once I've done more research.</p>"},{"location":"onb_overview/enums/audiopriority/#usage-suggestion","title":"Usage Suggestion","text":"<p>I almost always use the Low piority. It practically guarantees that the sound will play. If you are sure your code is supposed to be playing it but you're not hearing it, and you  know it's loud enough to hear, you may want to change to Low priority.</p>"},{"location":"onb_overview/enums/audiotype/","title":"AudioType","text":"<p>You can play sounds in ONB using <code>Engine.play_audio</code>. You will mostly use it with  sound effects that are in your mods, but you can also access the sound effects  bundled with the engine by using the AudioType enum.</p> <p>AudioType has the following indexes:</p> <ul> <li>CounterBonus</li> <li>DirTile</li> <li>Fanfare</li> <li>Appear</li> <li>AreaGrab</li> <li>AreaGrabTouchdown</li> <li>BusterPea</li> <li>BusterCharged</li> <li>BusterCharging</li> <li>BubblePop</li> <li>BubbleSpawn</li> <li>GuardHit</li> <li>Cannon</li> <li>Counter</li> <li>Wind</li> <li>ChipCancel</li> <li>ChipChoose</li> <li>ChipConfirm</li> <li>ChipDesc</li> <li>ChipDescClose</li> <li>ChipError</li> <li>CustomBarFull</li> <li>CustomScreenOpen</li> <li>ItemGet</li> <li>Deleted</li> <li>Explode</li> <li>Gun</li> <li>Hurt</li> <li>PanelCrack</li> <li>PanelReturn</li> <li>Pause</li> <li>PreBattle</li> <li>Recover</li> <li>Spreader</li> <li>SwordSwing</li> <li>TossItem</li> <li>TossItemLite</li> <li>Wave</li> <li>Thunder</li> <li>ElecPulse</li> <li>Invisible</li> <li>ProgramAdvance</li> <li>LowHP</li> <li>DarkCard</li> <li>PointSFX</li> <li>NewGame</li> <li>Text</li> <li>Shine</li> <li>TimeFreeze</li> <li>Meteor</li> <li>Deform</li> </ul>"},{"location":"onb_overview/enums/audiotype/#usage","title":"Usage","text":"<p>You can use an AudioType in the same place you would use an audio handle in  a call to <code>Engine.play_audio</code>.</p> <pre><code>Engine.play_audio(AudioType.Shine, AudioPriority.Low)\n</code></pre> <p>It's possible that these sound files may change quality or volume in the future,  or may be removed or swapped for other sounds.</p>"},{"location":"onb_overview/enums/blocks/","title":"Blocks","text":"<p>The <code>Blocks</code> enum contains indexes representing the supported NaviCust block  colors. This includes the following:</p> <ul> <li>White</li> <li>Red</li> <li>Green</li> <li>Blue</li> <li>Pink</li> <li>Yellow</li> </ul> <p>Only colors from BN6 are included. </p>"},{"location":"onb_overview/enums/blocks/#usage","title":"Usage","text":"<p>You will use this enum to set the color of blocks in your Block packages.</p> <pre><code>function package_init(block)\n    block:set_color(Blocks.White)\n    -- Omitted the rest of package_init for example\nend\n</code></pre> <p>If no color is set, a default of <code>Blocks.White</code> will be used.</p>"},{"location":"onb_overview/enums/cardclass/","title":"CardClass","text":"<p><code>CardClass</code> indexes describe a card's class. A card's preview color  changes with the CardClass, and certain effects may target certain classes. </p> <p>The following CardClass indexes are available:</p> <ul> <li>Standard</li> <li>Mega</li> <li>Giga</li> <li>Dark</li> </ul> <p>By default, <code>CardClass.Standard</code> is used.</p>"},{"location":"onb_overview/enums/cardclass/#usage","title":"Usage","text":"<p>A CardClass can be set on a CardProperties object's <code>card_class</code> index. Usually, this is  set in the <code>package_init</code> of a card mod.</p> <pre><code>function package_init(package) \n    local props = package:get_card_props()\n    props.card_class = CardClass.Standard\n    -- Omitted the rest of the package_init for the example\nend\n</code></pre>"},{"location":"onb_overview/enums/cardclass/#copy-limits","title":"Copy Limits","text":"<p>In the official games, each class would have an associated limit within your folder. For  example, in Battle Network 6, you could only have up to 5 Mega chips in your folder, and  only 1 Giga chip without additional modifiers.</p> <p>Currently, ONB does not enforce these limits. However, in the future, expect to see user- created servers that do, or that may control limits in other ways based on their CardClass.</p>"},{"location":"onb_overview/enums/cardclass/#effects","title":"Effects","text":"<p>A card's CardClass can be read by code in certain places. Nothing in the engine does, but  user-created mods might change behavior based on them. For an official example, see the  Beat NaviCust Part, which will activate when the opponent uses a Mega or Giga class chip. </p> <p>Currently in ONB, we can only reasonably act on the CardClass in the <code>filter_hand_step</code>.  This would allow, for example, an effect like GaiaSword that only consumes Standard chips  in your hand.</p>"},{"location":"onb_overview/enums/cardclass/#dark","title":"Dark","text":"<p>Dark chips only appeared in a meaningful capacity in BN4 and BN5. ONB takes more of a BN5  approach with Dark chips, as they can be put into your folder. </p> <p>Currently, ONB replicates the following Dark chip behavior:</p> <ul> <li>Hovering a Dark chip in the Custom window will dim the screen, lower music volume,  and play a sound</li> <li>A Dark chip appearing in the Custom window will cause the cursor to jump to it  when Custom is opened</li> </ul> <p>Music Volume</p> <p>If you leave a battle using the Esc key while the cursor is on a Dark chip, the music  volume will not return to its original volume.</p> <p>A few more behaviors may be replicated in future versions.</p>"},{"location":"onb_overview/enums/cardclass/#expectations","title":"Expectations","text":"<p>In the official games, Dark chips inflict the user with a bug, and may also inflict whatever  they hit with a bug as well, under certain conditions. Using any during a battle will also make you permanently lose 1 max HP when the battle ends, up to some maximum. </p> <p>Due to the nature of ONB, you shouldn't necessarily expect either of those to be true. All  card mods are made by modders, so it's up to them to add bugs and so on. What a card mod  can't do is reduce max HP, which you should especially expect from the nature of ONB. But  a server might be able to track that you have used a Dark chip while on the server and do  something, such as lowering max HP, based on it. That would only apply to that server, and  the server must be programmed to do such things.</p>"},{"location":"onb_overview/enums/colormode/","title":"ColorMode","text":"<p>The <code>ColorMode</code> enum values determine the way a Color will be applied to  a Sprite.</p> <p>The available ColorMode indexes are:</p> <ul> <li>Multiply</li> <li>Additive</li> </ul> <p>The default is usually <code>ColorMode.Additive</code>. Descendent Sprites may sometimes  be <code>ColorMode.Multiply</code> by default instead.</p> <p>Missing Info</p> <p>This notice will be removed once I've confirmed exactly when descendents  use Multiply as a default.</p>"},{"location":"onb_overview/enums/colormode/#usage","title":"Usage","text":"<p>You can use <code>Sprite.set_color_mode</code> to change a Sprite's ColorMode.</p> <pre><code>local artifact = Battle.Artifact.new()\nlocal sprite = artifact:sprite()\nsprite:set_color_mode(ColorMode.Multiply)\n</code></pre> <p>Doing that alone may cause the color of the Sprite to sharply change. You will  usually follow a call to <code>set_color_mode</code> with a call to <code>set_color</code>.</p> <pre><code>sprite:set_color_mode(ColorMode.Multiply)\n\nlocal red = Color.new(255, 0, 0, 255)\nsprite:set_color(red)\n</code></pre>"},{"location":"onb_overview/enums/colormode/#additive","title":"Additive","text":"<p><code>ColorMode.Additive</code> will cause Colors to increase RGBA values. Generally, this  is used to make a Sprite appear brighter. <code>Color.new(0, 0, 0, 255)</code> represents  no change, and <code>Color.new(255, 255, 255, 255)</code> represents white.</p>"},{"location":"onb_overview/enums/colormode/#multiply","title":"Multiply","text":"<p><code>ColorMode.Multiply</code> will cause Colors to multiply RGBA values. Generally, this  is used to make a Sprite appear darker. <code>Color.new(255, 255, 255, 255)</code> represents  no change, and <code>Color.new(0, 0, 0, 255)</code> represents black.</p>"},{"location":"onb_overview/enums/defenseorder/","title":"DefenseOrder","text":"<p>The <code>DefenseOrder</code> enum is used when creating a DefenseRule, and describes the time  at which the DefenseRule will be checked against an attack.</p> <p>It has the following indexes:</p> <ul> <li>Always</li> <li>CollisionOnly</li> </ul>"},{"location":"onb_overview/enums/defenseorder/#usage","title":"Usage","text":"<p>You must pass in a <code>DefenseOrder</code> when creating a DefenseRule.</p> <pre><code>local defense = Battle.DefenseRule.new(1, DefenseOrder.Always)\n</code></pre> <p>No DefenseRules react to an attack which could never hit the Entity, such as if the  attack and the Entity are not Team.Other and not on the same Team, or if the Entity's  hitbox is toggled off.</p>"},{"location":"onb_overview/enums/defenseorder/#always","title":"Always","text":"<p>DefenseRules with the <code>DefenseOrder.Always</code> DefenseOrder will always run for an attack  that is able to hit. These will run before <code>DefenseOrder.CollisionOnly</code>, and will run  even if the Entity is intangible.</p>"},{"location":"onb_overview/enums/defenseorder/#collisiononly","title":"CollisionOnly","text":"<p>DefenseRules with the <code>DefenseOrder.CollisionOnly</code> DefenseOrder will only run for attacks  that collide. This means it will not run if the Entity is intangible.</p> <p>An attack's <code>collision_func</code> will run just before these DefenseRules are checked.</p>"},{"location":"onb_overview/enums/direction/","title":"Direction","text":"<p>The Direction enum has values for each direction. It also has a few  useful functions for manipulating them.</p> <p>It has the following indexes:</p> <ul> <li>None</li> <li>Up</li> <li>UpRight</li> <li>Right</li> <li>DownRight</li> <li>Down</li> <li>DownLeft</li> <li>Left</li> <li>UpLeft</li> </ul> <p>Additionally, the following indexes have function values:</p> <ul> <li>join</li> <li>reverse</li> <li>flip_x</li> <li>flip_y</li> <li>unit_vector</li> </ul>"},{"location":"onb_overview/enums/direction/#usage","title":"Usage","text":"<p>The actual directions on Direction will mostly be used for an Entity's facing  direction, the direction for something to move in, or the direction to pivot  from a Tile when calling <code>Entity.get_tile</code> or <code>Tile.get_tile</code>.</p> <pre><code>-- Tile to the right of the player\nlocal tile = player:get_tile(Direction.Right, 1)\n</code></pre> <p>It's less common to refer to exactly Left or Right, because those directions may mean different things for player 1 and player 2. Try to keep Left/Right references  relative.</p> <pre><code>local facing = player:get_facing()\n-- Tile in front of the player\nlocal tile = player:get_tile(facing, 1)\n</code></pre>"},{"location":"onb_overview/enums/direction/#join","title":"join","text":"<p><code>Direction.join</code> will return the combination of two input Directions. Up and  Right becomes UpRight, for example.</p> <p><code>Direction.join</code> can help when using relative directions. If you want to get  the Tile that's in front of the player and one up, for example, you can do this:</p> <pre><code>local facing = player:get_facing()\nlocal joined_direction = Direction.join(facing, Direction.Up)\nlocal tile = player:get_tile(joined_direction, 1)\n</code></pre> <p>Note that it is called with a period instead of a colon.</p> <p>The alternative is to travel across two different Tiles, which also necessitates a  check for <code>nil</code> on the first <code>get_tile</code> call.</p>"},{"location":"onb_overview/enums/direction/#reverse","title":"reverse","text":"<p><code>Direction.reverse</code> will reverse an input Direction, returning its opposite. Left  becomes Right, Up becomes Down, and so on.</p> <p><code>Direction.reverse</code> can help when using relative directions. If you want to get the  Tile that's behind the user, for example, you can do this:</p> <pre><code>local facing = player:get_facing()\nlocal reverse_facing = Direction.reverse(facing)\nlocal tile = player:get_tile(reverse_facing, 1)\n</code></pre> <p>Note that it is called with a period instead of a colon.</p> <p>Also remember that the above intention can also be done using <code>Entity.get_facing_away</code> and skipping the reverse. Regardless, it'll be a useful tool, like when you don't have  an Entity to get the facing direction of.</p>"},{"location":"onb_overview/enums/direction/#flip_x","title":"flip_x","text":"<p><code>Direction.flip_x</code> will flip the horizontal part of a Direction and return the result. </p> <pre><code>local flip = Direction.flip_x(Direction.UpRight)\n</code></pre> <p><code>flip</code> in the above code will equal <code>Direction.UpLeft</code>.</p> <p>Note that it is called with a period instead of a colon.</p> <p>You can and likely will mostly use <code>Direction.reverse</code> for this, because most of the time  when you want to flip a facing Direction, you can use <code>Direction.reverse</code>. An Entity can  only face left or right, so there usually won't be a diagonal that you may only want to  flip the horizontal on.</p>"},{"location":"onb_overview/enums/direction/#flip_y","title":"flip_y","text":"<p><code>Direction.flip_y</code> will flip the vertical part of a Direction and return the result. </p> <pre><code>local flip = Direction.flip_y(Direction.UpRight)\n</code></pre> <p><code>flip</code> in the above code will equal <code>Direction.DownRight</code>.</p> <p>Note that it is called with a period instead of a colon.</p> <p>You can and likely will mostly use <code>Direction.reverse</code> for this, because most of the time  when you want to flip a facing Direction, you can use <code>Direction.reverse</code>. An Entity can  only face left or right, so there usually won't be a diagonal that you may only want to  flip the vertical on.</p>"},{"location":"onb_overview/enums/direction/#unit_vector","title":"unit_vector","text":"<p><code>Direction.unit_vector</code> will return a Vector representation of an input Direction.  Right becomes (1, 0), UpRight becomes approximately (0.707, -0.707), Left becomes (-1, 0),  and so on.</p> <p>You are unlikely to use this very often.</p>"},{"location":"onb_overview/enums/direction/#bitwise-operations","title":"Bitwise Operations","text":"<p>The number values in the indexes on Direction are powers of 2 in the source code. This  means you can treat them like flags, where all of them can be \"set\". However, doing so  with this set of values accomplishes nothing. The engine specifically expects exact values,  and does not use any bitwise operations when checking these values. Additionally, with  values like these, you might expect <code>Direction.UpRight</code> to equal <code>Direction.Up | Direction.Right</code>,  but this is not the case.</p>"},{"location":"onb_overview/enums/element/","title":"Element","text":"<p>Entities and HitProps have Elements. They determine what Entities take bonus  damage from, what HitProps deal bonus damage to, and what special interactions  on a Tile the HitProps might have.</p> <p>Card mod packages separately can have an Element set to display an icon. This  can be programmed to be a different Element than the damage dealt by an attack,  and sometimes is in official games.</p> <p>The Elements available in v2.0 match the ones you'll find in BN6:</p> <ul> <li>None</li> <li>Fire</li> <li>Aqua</li> <li>Elec</li> <li>Wood</li> <li>Sword</li> <li>Break</li> <li>Cursor</li> <li>Wind</li> <li>Summon</li> <li>Plus</li> </ul> <p>A few more will be added in the future.</p> <p>Typically, you would say a Navi that is Fire Element is, or has, FireBody. An attack  that has the Fire Element can be said to deal Fire damaga. I'll be using that wording  throughout these docs.</p> <p>The None element is often referred to as Null. I'll mostly do the same.</p>"},{"location":"onb_overview/enums/element/#interactions","title":"Interactions","text":""},{"location":"onb_overview/enums/element/#none","title":"None","text":"<p>An Entity with NullBody has no special interactions and does not take additional damage  from attacks of any other element.</p> <p>An attack that deals Null damage has no special interactions.</p>"},{"location":"onb_overview/enums/element/#fire","title":"Fire","text":"<p>An Entity with FireBody takes bonus damage from Aqua attacks.</p> <p>An attack that deals Fire damage will deal bonus damage to WoodBody Entities. If the Tile  an Entity is standing when they get hit is in the Grass TileState, the TileState will be set  to <code>TileState.None</code>, and they will take bonus damage.</p> <p>Grass Burn</p> <p>In the official games, a Fire attack passing over a Grass Tile would cause the Tile to  revert to normal. This does not happen in v2.0, but will in the future. </p> <p>Lava</p> <p>In the official games, FireBody lets you stand on Lava Tiles without taking damage. This  is not in v2.0, but will happen in the future.</p>"},{"location":"onb_overview/enums/element/#aqua","title":"Aqua","text":"<p>An Entity with AquaBody takes bonus damage from Elec attacks. Additionally, an Entity with  AquaBody will not slip when moving to a Tile that is in the Ice TileState.</p> <p>An attack that deals Aqua damage will deal bonus damage to FireBody Entities. If the Tile  an Entity is standing when they get hit is in the Ice TileState, the TileState will be set  to <code>TileState.None</code>, and they will be frozen.</p> <p>Lava and Volcano</p> <p>In the official games, an Aqua attack passing over Lava and Volcano Tiles will set  them to normal. This does not happen in v2.0, but will in the future.</p> <p>Aqua Spell</p> <p>In v2.0, a Spell whose Element (not HitProps.element) is Aqua will set Volcano Tiles to normal. In future versions, this behavior will be removed and replaced with having  the state change when the Tile is attacked with an Aqua attack.</p>"},{"location":"onb_overview/enums/element/#elec","title":"Elec","text":"<p>An Entity with ElecBody takes bonus damage from Wood attacks. </p> <p>An attack that deals Elec damage will deal bonus damage to AquaBody Entities. If the Tile  an Entity is standing when they get hit is in the Ice TileState, they will take bonus  damage. This aspect will be removed in a future version, as the official games do not do that  after BN3.</p>"},{"location":"onb_overview/enums/element/#wood","title":"Wood","text":"<p>An Entity with WoodBody takes bonus damage from Fire attacks.</p> <p>An attack that deals Wood damage will deal bonus damage to ElecBody Entities. </p> <p>Grass healing</p> <p>In the official games, WoodBody lets you heal over time while standing on a Grass Tile.  This does not have in v2.0, but will in the future.</p>"},{"location":"onb_overview/enums/element/#sword","title":"Sword","text":"<p>An Entity with SwordBody takes bonus damage from Break attacks.</p> <p>An attack that deals Sword damage will deal bonus damage to WindBody Entities. </p>"},{"location":"onb_overview/enums/element/#break","title":"Break","text":"<p>An Entity with BreakBody takes bonus damage from Cursor attacks.</p> <p>An attack that deals Break damage will deal bonus damage to SwordBody Entities. </p> <p>Pierce Guard and Freeze Break</p> <p>A common misconception is that the Break element is what allows an attack to  go through shields, break objects, or deal bonus damage to a frozen target. This  is not the case. It's a certain hitflag that acts as a signal for this to happen.</p> <p>All Break element attacks in the official games happen to have this flag, but  many other attacks also do.</p>"},{"location":"onb_overview/enums/element/#cursor","title":"Cursor","text":"<p>An Entity with CursorBody takes bonus damage from Wind attacks.</p> <p>An attack that deals Cursor damage will deal bonus damage to BreakBody Entities. </p> <p>Breaking Traps</p> <p>In BN6, Cursor element attacks also remove active traps set by the target.  This is not an automatic effect in ONB, since traps are UGC. When making traps,  it's recommended to keep this interaction intact.</p>"},{"location":"onb_overview/enums/element/#wind","title":"Wind","text":"<p>An Entity with WindBody takes bonus damage from Sword attacks.</p> <p>An attack that deals Wind damage will deal bonus damage to CursorBody Entities. </p> <p>Barriers/Auras</p> <p>In BN6, any Wind element attack will remove a Barrier or Aura. This is not an  automatic effect in ONB, since they are UGC. When making Barrier or Aura effects,  it's recommended to keep this interaction intact.</p>"},{"location":"onb_overview/enums/element/#summon-and-plus","title":"Summon and Plus","text":"<p>The Summon and Plus Elements do nothing as a Body or attack damage.</p> <p>As a consequence of Element appearing in multiple contexts, the engine allows you to  set these as the Element of an Entity or as a damage Element. Regardless, I will recommend  here and elsewhere to never do that. </p> <p>The official games use these Elements only for its icon on a chip, which you can do separately with the mod package. If you use this in other places, mods aiming for accuracy to the source  material might have unexpected conditions.</p> <p>Mechanically, they are essentially a Null that isn't actually Null.</p>"},{"location":"onb_overview/enums/entitystatus/","title":"EntityStatus","text":"<p>The <code>EntityStatus</code> enum is a status returned by calls to <code>Field.spawn</code> to describe  the results of the spawn.</p> <p>It has the following values:</p> <ul> <li>Queued</li> <li>Added</li> <li>Failed</li> </ul>"},{"location":"onb_overview/enums/entitystatus/#usage","title":"Usage","text":"<p>You can inspect the return value of <code>Field.spawn</code>.</p> <pre><code>local spell = Battle.Spell.new(player:get_team())\nlocal status = player:get_field():spawn(spell, 3, 1)\n\n-- true\nprint(status == EntityStatus.Queued)\n</code></pre> <p>You are unlikely to use this value very often, because it won't give useful information  in most use cases. You should structure your code such that you know whether or not  the Entity will successfully spawn, such as ensuring you don't pass in nonsensical  coordinates.</p>"},{"location":"onb_overview/enums/entitystatus/#queued","title":"Queued","text":"<p><code>Field.spawn</code> returns <code>EntityStatus.Queued</code> if the call was made while the Field  was updating. Nearly all of your spawn calls will return this one.</p>"},{"location":"onb_overview/enums/entitystatus/#added","title":"Added","text":"<p><code>Field.spawn</code> returns <code>EntityStatus.Added</code> if the call was made while the Field  was not updating and the Entity to spawn was successfully added.</p>"},{"location":"onb_overview/enums/entitystatus/#failed","title":"Failed","text":"<p><code>Field.spawn</code> returns <code>EntityStatus.Added</code> if the call was made while the Field  was not updating and the Entity to spawn was not successfully added. This happens  if the coordinates to spawn at did not match an existing Tile, for example:</p> <p><pre><code>local spell = Battle.Spell.new(player:get_team())\nlocal status = player:get_field():spawn(spell, 100, 1)\n</code></pre> The <code>status</code> value would be <code>EntityStatus.Queued</code> if called during the update, or  <code>EntityStatus.Failed</code> otherwise.</p>"},{"location":"onb_overview/enums/highlight/","title":"Highlight","text":"<p>The <code>Highlight</code> enum describes the way a Tile should highlight.</p> <p>The following indexes are available: </p> <ul> <li>Solid</li> <li>Flash</li> <li>None</li> </ul>"},{"location":"onb_overview/enums/highlight/#usage","title":"Usage","text":"<p>Most commonly, you will call <code>Tile.highlight</code> and pass in a Highlight.</p> <pre><code>player:get_current_tile():highlight(Highlight.Solid)\n</code></pre> <p>This will cause the Tile to highlight for one frame. For a highlight that  lasts longer, you will need to call it multiple frames in a row. Because of  this, it's common to do it in some <code>update_func</code>.</p> <p>You can also call <code>Spell.highlight_tile</code> and pass in a Highlight to cause the  Spell's current Tile to be highlighted according to the Highlight every frame  automatically.</p>"},{"location":"onb_overview/enums/highlight/#solid","title":"Solid","text":"<p><code>Highlight.Solid</code> keeps the Tile lit up for every frame that it is called.</p>"},{"location":"onb_overview/enums/highlight/#flash","title":"Flash","text":"<p><code>Highlight.Flash</code> works on a global timer, so using this Highlight for only one  frame may often not light the Tile up at all. The Tile will light up for 4 frames,  then stay normal for 4 frames, and repeat.</p> <p>Because the flash highlight is on a global timer, you may start trying to highlight  in the middle of the 4-on-4-off sequence.</p> <p>If you need to have two different Flash highlights that are asynchronous, you will  need to use <code>Highlight.Solid</code> with your own timer to determine when the highlight  should be on and off.</p>"},{"location":"onb_overview/enums/highlight/#none","title":"None","text":"<p><code>Highlight.None</code> will cause there to be no highlight on the Tile.</p>"},{"location":"onb_overview/enums/highlight/#hidden-tile","title":"Hidden Tile","text":"<p>Tiles with <code>TileState.Hidden</code> as their state will never highlight.</p>"},{"location":"onb_overview/enums/highlight/#priority","title":"Priority","text":"<p>Calls to <code>Tile.set_highlight</code> for a particular Tile act as a request. If multiple  requests are made in one frame, priority is given to the largest. The highest  priority is <code>Highlight.None</code>, and the lowest is <code>Highlight.Solid</code>.</p>"},{"location":"onb_overview/enums/hit/","title":"Hit","text":"<p>The <code>Hit</code> enum makes up what I'll be calling \"hitflags\", values that are  used as signals, or flags, that certain behavior should happen on a hit. </p> <p>It contains the following values:</p> <ul> <li>None</li> <li>Flinch</li> <li>Flash</li> <li>Stun</li> <li>Root</li> <li>Impact</li> <li>Shake</li> <li>Pierce</li> <li>Retangible</li> <li>Breaking</li> <li>Freeze</li> <li>Drag</li> <li>Blind</li> </ul> <p>Bubble</p> <p><code>Hit.Bubble</code> also exists and is accessible, but it is not complete in  v2.0 and will cause a crash if used.</p> <p>There is an additional flag that doesn't have an enum to access its value,  but we can use its raw associated number. This will be mentioned later in  the page.</p> <p>Statuses</p> <p>Many of the flags here inflict statuses. In the future, I may split  some of the information here to another page for statuses.</p> <p>Statuses and certain reactions to hitflags are only applied when the  attack passes all DefenseRules without being blocked. If their  <code>attack_func</code> plays, then the flags have been fully applied.</p>"},{"location":"onb_overview/enums/hit/#bits","title":"Bits","text":"<p><code>Hit</code> values are set up so that they can be used as bit flags. This means you  can use bitwise operations on them. Some of the following sections will show  some examples of using these.</p>"},{"location":"onb_overview/enums/hit/#usage","title":"Usage","text":"<p>When creating a <code>HitProps</code>, use <code>Hit</code> enum values when setting its <code>flags</code>  field.</p> <pre><code>local hitprops = HitProps.new(\n    -- damage\n    10,\n    -- flags\n    Hit.None,\n    -- element\n    Element.None,\n    -- context\n    player:get_context(),\n    -- Drag\n    Drag.None\n)\n</code></pre>"},{"location":"onb_overview/enums/hit/#multiple-flags","title":"Multiple Flags","text":"<p>You will often use <code>|</code> to combine multiple flags.</p> <pre><code>local hitprops = HitProps.new(\n    10,\n    Hit.Impact | Hit.Flinch | Hit.Flash,\n    Element.None,\n    player:get_context(),\n    Drag.None\n)\n</code></pre> <p>The above HitProps will make impact, cause the hit target to flinch, and also  cause them to flash.</p>"},{"location":"onb_overview/enums/hit/#checking-for-flags","title":"Checking For Flags","text":"<p>You can use bitwise operations to inspect and manipulate hitflags.</p> <pre><code>local flags = Hit.Impact | Hit.Flinch | Hit.Flash\n\n-- If flags has Hit.Flash\nif flags &amp; Hit.Flash == Hit.Flash then\n    -- Remove Hit.Flinch\n    flags = flags &amp; ~Hit.Flinch\nend\n\n-- Another way to check if flags has Hit.Flash\nif flags | Hit.Flash == flags then \n\nend\n</code></pre>"},{"location":"onb_overview/enums/hit/#values","title":"Values","text":""},{"location":"onb_overview/enums/hit/#none","title":"None","text":"<p><code>Hit.None</code> is the <code>0</code> value. It has no other behavior. Think of this  as the absence of all other flags.</p> <p>This also means you never have to explicitly use <code>Hit.None</code> if you have  multiple flags.</p> <pre><code>-- true\nprint((Hit.None | Hit.Impact) == Hit.Impact)\n</code></pre>"},{"location":"onb_overview/enums/hit/#impact","title":"Impact","text":"<p><code>Hit.Impact</code> is an extremely important flag. When in doubt, add it! It determines a few crucial properties of an attack and how other things  tend to react to it. </p> <p>Because everything is user-generated, things may not match exactly. I'll  describe what it does in the official games as a frame of reference:</p> <p>With Impact:</p> <ul> <li>Attacks will cause the target to flash white when hit</li> <li>Damage sounds will play</li> <li>Barriers will block the attack</li> <li>Shields will play a block sound and spawn a graphic, and reflect if able</li> <li>Damage dealt will be tallied for the Damage Judge to determine a winner when  the round's time runs out</li> </ul> <p>Put another way, Impact is used for attacks that really hit someone. Swords,  fire attacks, bombs, etc. all use Impact. They may be blocked by defenses.</p> <p>Attacks without Impact are often things that act as \"HP drains\". Anubis and  GunDelSol are examples of these. Shield still blocks them, but they go through  AntiDamage and Barriers.</p> <p>When creating mods that react to damage, take care in checking for <code>Hit.Impact</code>  where appropriate.</p>"},{"location":"onb_overview/enums/hit/#flinch","title":"Flinch","text":"<p><code>Hit.Flinch</code> causes Players to enter their \"PLAYER_HIT\" animation state. Many  attacks use this, but not all. It's common to strip it away using the SuperArmor  NaviCust Part in the official games.</p> <p>Missing Info</p> <p>This notice will be removed once I check what the duration of the flinch animation is. It's somewhere around 18-24f.</p>"},{"location":"onb_overview/enums/hit/#flinching-enemies","title":"Flinching Enemies","text":"<p>Characters that are not Players do not inherently have any reaction to <code>Hit.Flinch</code>. When programming enemies which should flinch, such as Navi bosses, you will need  to handle flinching yourself.</p>"},{"location":"onb_overview/enums/hit/#flash","title":"Flash","text":"<p><code>Hit.Flash</code> causes the hit Entity to become intangible for some time, while their  sprite flickers between visible and invisible. Viruses and objects in the official  games often strip this flag when hit.</p> <p>While an Entity is intangible because of this flag, we say that they are \"flashing\". The duration of this is 120 frames.</p> <p>While flashing, an Entity is intangible. Attacks will not make collision unless they  have the <code>Hit.Pierce</code> flag. If they don't collide, the attack's <code>collision_func</code> will  not play and no damage will be done. DefenseRules with the <code>CollisionOnly</code> DefenseOrder also will not have their <code>can_block_func</code> play.</p>"},{"location":"onb_overview/enums/hit/#stun","title":"Stun","text":"<p><code>Hit.Stun</code> causes the hit Entity to become stunned. This will prevent them from making  actions for a period of time, and their sprite will flash yellow. CardActions that are  currently in use will immediately end, and any which are queued will be discarded. Objects in the official games strip this flag when hit.</p> <p>Stun lasts 120 frames, but can be cancelled early by an attack that flinches and flashes.</p> <p>Counter</p> <p>Being counterhit will also stun, but not using the hitflag. Being stunned in this  way will have a duration of 150 frames instead.</p> <p>Stun Duration</p> <p>In the official games, stuns often have different durations. For example, Thunder  stuns for 90 frames, JudgeMan stuns for 120 frames, and FlashBomb2 stuns for 150  frames. v2.0 does not support different stun durations, but expect it in the future.</p> <p>The official games also allow stun duration to tick an extra time whenever you  have an input pressed that frame, so you can \"mash out\" faster. This is not a  feature in v2.0, but is likely to be added in the future.</p> <p>Missing Info</p> <p>This notice will be removed once I confirm whether or not an attack with Hit.Stun  getting a counterhit will stun for 120 frames or 150 frames. </p>"},{"location":"onb_overview/enums/hit/#root","title":"Root","text":"<p><code>Hit.Root</code> causes the hit Entity to become rooted to the spot. This will prevent them  from moving, and their sprite will flash black. Objects in the official games strip this flag when hit. Another name used for the inflicted status is \"immobilze\", but I will be  using \"Root\" to match the code.</p> <p>Root lasts 120 frames, but can be cancelled early if the Entity is intangible, such  as after being hit by an attack that flashes.</p> <p>Root Over Holes</p> <p>In the official games, the Root status cannot be applied to an Entity whose Tile is a hole. This is not the case in v2.0. </p> <p>Root Duration</p> <p>In the official games, roots often have different durations. v2.0 does not support  this, but is likely to in the future.</p> <p>Missing Info</p> <p>This notice will be removed when I confirm exactly how Root interacts with  MoveEvents. Do they fail to queue, or only fail to update? What happens if  you are rooted mid-movement?</p>"},{"location":"onb_overview/enums/hit/#shake","title":"Shake","text":"<p><code>Hit.Shake</code> causes a hit Entity's sprite to shake quickly. In the official games,  this is seen whenever damage is dealt while time is frozen.</p> <p>Shake is automatically applied to hits that happen during time freeze. If aiming  for official game accuracy, this flag should never be manually applied by your  code.</p> <p>Shake After Time Freeze</p> <p>In v2.0, the shake effect happens again, after time freeze ends. This will be fixed in a later version.</p>"},{"location":"onb_overview/enums/hit/#pierce","title":"Pierce","text":"<p><code>Hit.Pierce</code> signals that an attack should pierce intangibility. This bypasses the  intangibility granted by the flashing status and allows a collision and damage.</p> <p>Because it's just a flag, be sure to check for it when you make certain intangible effects. For example, a recreation of the Invis chip from the official games should allow attacks  with <code>Hit.Pierce</code> to deal damage.</p> <p>Other Pierces</p> <p>There are other forms of intangibility found across the BN series. PopUp, from BN3,  should be pierced by a flag different from the one that pierces Invis and flashing.  This is not handled in v2.0. Future versions will have more flags and renamed flags  for more clarity.</p>"},{"location":"onb_overview/enums/hit/#retangible","title":"Retangible","text":"<p><code>Hit.Retangible</code> signals that an attack should remove intangibility. This will typically  be paired with <code>Hit.Pierce</code>. This will remove the flashing status.</p> <p>When an attack has <code>Hit.Retangible</code> and <code>Hit.Flash</code>, expect intangible effects to end  and then for the flashing status to be applied after.</p> <p>Because it's just a flag, be sure to check for it when you make certain intangible effects. For example, a recreation of the Invis chip from the official games should end its effect  when hit by a Retangible attack.</p>"},{"location":"onb_overview/enums/hit/#breaking","title":"Breaking","text":"<p><code>Hit.Breaking</code> signals that an attach should go through certain guards, destroy certain  objects, and deal additional damage to a frozen Entity.</p> <p>Following official games, every attack with the Break element should have this flag. Many  objects are destroyed instantly, but not necessarily all of them, and some have special  reactions to it. When in doubt, you will likely want to allow them to be destroyed by the  Breaking flag.</p> <p>Because it's just a flag, be sure to check for it based on the mod. A recreation of the  Reflect chip from the official games should not block attacks with this flag, and a recreation  of RockCube should be instantly destroyed by an attack with this flag. </p> <p>Breaking Vs. Break</p> <p>A common misconception is that the Break element has the properties described above. In reality, the Break element on its own has no extra behavior; all Break element  attacks just so happen to have the <code>Hit.Breaking</code> flag.</p> <p>Many other attacks in the series have this flag while not being Break element. See  Sensor (Elec), EraseMan (Cursor), the charge shot used by Charge Cross (Fire), the  DustMan chip (Null), and more.</p>"},{"location":"onb_overview/enums/hit/#freeze","title":"Freeze","text":"<p><code>Hit.Freeze</code> causes an attack to inflict the Freeze status. This will prevent them from  taking actions, and their Sprite will be lightened and have ice fragments overlaid.  CardActions that are currently in use will immediately end, and any which are queued will  be discarded.</p> <p>The freeze status lasts for 150 frames. It can also be ended early by being hit by an  attack with the <code>Hit.Breaking</code> flag, or an attack which flinches and flashes. It will  also end early if it is replaced by the Stun or Drag statuses. Objects in the official  games are immune to this status.</p> <p>If an attack would freeze, it will not cause Flashing.</p> <p>This flag is rarely, if ever, used in the official games. ElementMan Ice and FreezeBomb,  from BN2, may be the only possible examples, though BN2 treated the status differently. When deciding to use it or not, keep in mind that the Freeze status is a very powerful  one, and much stronger than Stun.</p> <p>Ice Panel Freeze</p> <p>The Freeze status can also be inflicted on an Entity if they take damage from an Aqua  attack while standing on an Ice panel. When freeze is inflicted in this way, it  does not use the <code>Hit.Freeze</code> flag.</p> <p>Missing Info</p> <p>This notice will be removed once I have confirmed which status takes priority if  both Freeze and Stun are inflicted at the same time.</p>"},{"location":"onb_overview/enums/hit/#drag","title":"Drag","text":"<p><code>Hit.Drag</code> causes the hit Entity to be forced into movement. This also inflicts the  Drag status. Their current CardAction, if any, will immediately end, and any that are  queued will be discarded.</p> <p>If a <code>Drag</code> is not defined in the <code>HitProps</code>, this flag will effectively do nothing.  Using a <code>Drag</code> with <code>Direction.None</code>, including <code>Drag.None</code>, as its movement direction will  not cause any of the above described behavior. Using a distance of <code>0</code> will also fail to  do anything related to <code>Hit.Drag</code>. Negative distances will be treated as positive.</p> <p>Root and Drag</p> <p>In v2.0, while an Entity is Rooted, they cannot be forced to move, even by Drag. The  movement will continue after Root has ended. This will be fixed in a future version.</p> <p>While under the Drag status, other statuses and reactions to certain hit flags will be continually requeued, only finally applying properly once the status ends. For example,  if a Character is under the Drag status, they can be hit by an attack with the Flinch,  Flash, and Stun flags, and they will not flinch, start flashing, or be stunned until the  Drag finishes.</p> <p>Drag Duration</p> <p>In the official games, Drag will continue to last several frames after movement  stops. This means there is still time after movement stops where statuses are queued  and not yet taking effect, and the Entity could still not move or attack. In v2.0,  this is not the case, but it can be expected in future versions.</p>"},{"location":"onb_overview/enums/hit/#drag-movement","title":"Drag Movement","text":"<p>The way Drag moves an Entity is described by the final parameter of <code>HitProps</code>, the  <code>Drag</code>. If an attack will not do any movement, <code>Drag.None</code> can be used. Otherwise,  use <code>Drag.new</code> and pass in a Direction to move in and a number of Tiles  to travel. Movement will be extended if an Entity slides onto an Ice Tile.</p> <pre><code>local facing = player:get_facing()\nlocal hitprops = HitProps.new(\n    10,\n    Hit.Impact | Hit.Flinch | Hit.Flash,\n    Element.None,\n    player:get_context(),\n    -- Push 1 Tile in the direction of `facing`\n    Drag.new(facing, 1)\n)\n</code></pre> <p>Typically, you will use the facing Direction of the one creating the attack. Prefer using  relative Directions like this, as in other places. If <code>Direction.None</code> is used, or the distance  to travel is 0, no movement will occur and the <code>Hit.Drag</code> flag will effectively do nothing. Negative distances will be treated as positive.</p> <p>The movement from Drag is a MoveEvent which completes in 4 frames, using <code>ActionOrder.Immediate</code>.  Another movement will be made until the entire distance has been travelled or the next Tile cannot be  moved to.</p>"},{"location":"onb_overview/enums/hit/#common-distances","title":"Common Distances","text":"<p>In the official games, only two Drag distances are used: 1 panel, or the entire field. The Field  considers itself 6 Tiles long, and because movement ends when the Entity can no longer move, and  an Entity usually cannot move off onto the edges, something like the below code will do fine  to push across the entire Field, but it may leave something to be desired.</p> <pre><code>local facing = player:get_facing()\nDrag.new(facing, 6)\n</code></pre> <p>Suppose, someday, the Field in ONB is allowed to be longer than 6 Tiles. Then the above code will  not hold up. Instead, you should consider using <code>Field.width</code> to determine how far to push.</p> <pre><code>local facing = player:get_facing()\nlocal field = player:get_field()\nDrag.new(facing, field:width())\n</code></pre>"},{"location":"onb_overview/enums/hit/#interactions-with-objects","title":"Interactions with Objects","text":"<p>In the official games, Drag has a number of special interactions when hitting objects. Here are  some examples:</p> <ul> <li>RockCube will slide until it can't move to the next panel even if the Drag would normally  only move 1 space. See AirShot hitting RockCube.</li> <li>The big rock, which spawns on some fields, will not be moved at all by Drag.</li> <li>RockCube does not take damage from attacks that Drag, while something like BlkBomb does.</li> </ul>"},{"location":"onb_overview/enums/hit/#blind","title":"Blind","text":"<p><code>Hit.Blind</code> causes the hit Entity to become blinded. An icon will be drawn over them. Players who are Blind will be unable to see Obstacles and Characters which are not on  their Team. </p> <p>The Blind status lasts 300 frames. </p> <p>Blind Enemies</p> <p>In official games, enemies with the Blind status behave differently than normal. Another page will have information on how the games tend to handle this.</p> <p>In ONB, naturally, we need to check for a Blind status and change logic based on it  to have this behavior. In v2.0, there is not yet a way to check for the Blind status,  but there will be in a future version.</p> <p>Missing Info</p> <p>This notice will be removed once I have confirmed where the Blind icon is drawn. Is it  on the \"head\" point of an animation frame, or around the height set by <code>Entity.set_height</code>?</p>"},{"location":"onb_overview/enums/hit/#nocounter","title":"NoCounter","text":"<p><code>Hit.NoCounter</code> is not accessible through the enum, but it can be accessed using its  associated value, <code>2048</code>. In future versions, this will be fixed. This flag makes an  attack unable to counterhit.</p> <p>If using this, be aware of the benefits of using an enum compared to the raw value, and  the risks you take in using the number. Namely, the NoCounter flag may not have this  value in future versions, which could impact your code logic. </p>"},{"location":"onb_overview/enums/input/","title":"Input","text":"<p>There are three sets of Input values:</p> <ol> <li>Pressed</li> <li>Held</li> <li>Released</li> </ol> <p>The following indexes are on each of them:</p> <ul> <li>Use</li> <li>Shoot</li> <li>Special</li> <li>Left</li> <li>Right</li> <li>Up</li> <li>Down</li> </ul> <p>Notice that there are a few inputs we don't yet have access to. Some extra  inputs, such as the left and right shoulder buttons, will be exposed in the  future.</p> <p>Access by using Input, one of the three types, and then one of the inputs.</p> <pre><code>Input.Pressed.Use\nInput.Held.Shoot\nInput.Released.Special\n</code></pre>"},{"location":"onb_overview/enums/input/#usage","title":"Usage","text":"<p>Input enum values are only used as the parameter for <code>Player.input_has</code>.  Its usage is described on the Player page.</p>"},{"location":"onb_overview/enums/lifetimes/","title":"Lifetimes","text":"<p>The <code>Lifetimes</code> enum is used as a specifier for the update behavior of a  Component. Specifically, they decide the battle state required in order  for it to update, as well as the moment within a game frame that it will update.</p> <p>It has the following values:</p> <ul> <li>Local</li> <li>Battlestep</li> <li>Scene</li> </ul>"},{"location":"onb_overview/enums/lifetimes/#usage","title":"Usage","text":"<p>A <code>Lifetimes</code> is used when creating a Component.</p> <pre><code>local component = Battle.Component.new(player, Lifetimes.Local)\n\nplayer:register_component(component)\n</code></pre> <p>When talking about a Component, I will often say that it is a Local  Component, or a Battlestep Component, etc., indicating which <code>Liftimes</code>  was used in its creation.</p>"},{"location":"onb_overview/enums/lifetimes/#differences","title":"Differences","text":""},{"location":"onb_overview/enums/lifetimes/#local","title":"Local","text":"<p>A Local Component's <code>update_func</code> runs during an Entity's <code>update_func</code>.  If the Entity will not update that frame, neither will the Component. </p> <p>Usually, an Entity will only update during the battle startup period (before the Custom Screen opens) and during the turn while time is not  frozen.</p> <p>Note that an Entity's <code>update_func</code> will not be called while the Entity  is stunned , but a Local Component will still be updated on that frame.</p>"},{"location":"onb_overview/enums/lifetimes/#battlestep","title":"Battlestep","text":"<p>A Battlestep Component's <code>update_func</code> runs near the end of the game frame,  after all Entities and Tiles on the Field have updated. The <code>update_func</code>  will only be called during the turn, while time is not frozen.</p> <p>Battlestep Components are updated in tandem with Scene Components, so a  Battlestep Component registered before a Scene Component will update first,  and vice versa.</p>"},{"location":"onb_overview/enums/lifetimes/#scene","title":"Scene","text":"<p>A Scene Component's <code>update_func</code> runs near the end of the game frame,  after all Entities and Tiles on the Field have updated. The <code>update_func</code>  will be called every frame. Scene Components are the only Components that  always update.</p>"},{"location":"onb_overview/enums/lifetimes/#choosing","title":"Choosing","text":"<p>Choose the <code>Lifetimes</code> to use taking into account the effect you want to  achieve. You should think of this in terms of when the update will happen,  and if that timing is appropriate for the effect.</p>"},{"location":"onb_overview/enums/lifetimes/#local-vs-battlestep","title":"Local vs. Battlestep","text":"<p>A lot of the ideas you think of that could fit a Local Component might also  fit a Battlestep Component, and vice versa. Even if the logic may play out  similarly, there could be subtle differences in practical behavior based  on which you choose. Below are some examples that highlight these.</p>"},{"location":"onb_overview/enums/lifetimes/#example-field-checks","title":"Example: Field Checks","text":"<p>You may want to use a Component to check for certain Entities, or maybe  TileStates, on the Field. </p> <p>With a Local Component, the update may be running before some other Entities  have updated, and before other logic during the frame has completed. By using  a BattleStep Component instead, the update will run closer to the end of the  frame and would be more likely to pick up on more changes that happened during  the frame.</p> <p>Say you wanted to do something similar to ColonelSoul's ability in BN5, which  causes objects to turn into soldiers. This would require you to observe the Field,  remove certain Entities, and spawn new ones.</p> <p>With a Local Component, the soldiers would spawn on the same frame you checked  the Field, but any objects that spawned on the same frame would not have spawned  in time for you to catch them in a Field check. With a Battlestep Component, you  can catch the objects that were spawned that frame, but your new spawns will not  appear until the end of the next frame.</p>"},{"location":"onb_overview/enums/lifetimes/#example-hp-bug","title":"Example: HP Bug","text":"<p>Effects like an HP Bug could be a Local or Battlestep Component, because then  HP wouldn't drop during Custom or time freeze. </p> <p>Recall that HP Bugs in the official games do not delete you, but stop draining  when you are at 1 HP. Here's a scenario where it can be game-changing to do  this using a Local or Battlestep Component, due to the difference in when  during the frame they update:</p> <ul> <li>You are at 2 HP, and when you update this frame your HP will drop to 1.</li> <li>A Spell's update this frame will attack your Tile.</li> </ul> <p>With a Local Component, you will update, drop to 1 HP, then get hit by the Spell  and be deleted. With a Battlestep Component, you will update, get hit by the Spell  and possibly fall to 1 HP (if you had UnderShirt installed, or the attack did 1 damage),  and then the Component updates and does not drop HP because you are at 1 HP. You  survive.</p> <p>Disclaimer</p> <p>I don't know how this scenario will end in the official games. You will need to do  extra research to get things like this right, if you are aiming for accuracy.</p>"},{"location":"onb_overview/enums/lifetimes/#scene_1","title":"Scene","text":"<p>Scene Components are not used as often, because most effects' logic should not  run all the time. </p> <p>Somewhere you might use a Scene Component comes from a special case with Barriers. Barriers animate during time freeze. Since the graphic should be added as a  SpriteNode, it would only animate during time freeze if its animation update was handled by a Scene Component's update.</p> <p>Because Scene Components also update during Custom and the Barrier should not  animate during Custom (except the first Custom screen), a few extra updates  using other Components or Entities can be used to determine that Custom is open  and avoid updating the animation.</p>"},{"location":"onb_overview/enums/locktype/","title":"LockType","text":"<p>The <code>LockType</code> enum describes the condition under which a CardAction will be  considered complete. </p> <p>It has the following indexes:</p> <ul> <li>Animation</li> <li>Async</li> <li>Sequence</li> </ul> <p>The default is <code>LockType.Animation</code>.</p>"},{"location":"onb_overview/enums/locktype/#usage","title":"Usage","text":"<p>You will never use the LockType enum on its own. Instead, you will use a  series of related functions to set the type on the CardAction. These  functions refer to these types as a \"lockout\", but don't confuse them with  another enum, <code>Lockout</code>.</p>"},{"location":"onb_overview/enums/locktype/#animation","title":"Animation","text":"<p>The CardAction will end when the associated Animation ends. This is the  default, so you are unlikely to ever set this. But if you wanted to, you  can use <code>make_animation_lockout</code>.</p> <pre><code>local action = Battle.CardAction.new(player, \"PLAYER_IDLE\")\naction:set_lockout(make_animation_lockout())\n</code></pre>"},{"location":"onb_overview/enums/locktype/#async","title":"Async","text":"<p>The CardAction will do cleanup, free the user, and call its <code>CardAction.action_end_func</code>  when the associated Animation ends, but it will continue calling its <code>CardAction.update_func</code>  until a specified amount of time passes based on the value given to the Async lockout.</p> <p>For example, see the code below:</p> <pre><code>local action = Battle.CardAction.new(player, \"PLAYER_IDLE\")\naction:set_lockout(make_async_lockout(0.5))\n</code></pre> <p><code>make_async_lockout</code> is called with a time in milliseconds. The above code gives 0.5 (30 frames).</p> <p>Once the <code>PLAYER_IDLE</code> animation finishes, <code>action</code> will continue updating for 30 frames.</p>"},{"location":"onb_overview/enums/locktype/#lockout","title":"Lockout","text":"<p>The Async LockType's timer has an additional effect. Until it expires, CardActions of the associated  LockoutGroup will not be performed.</p> <p>Missing Info</p> <p>This notice will be removed once I figure out if the CardAction is still queued or if it will  only be discarded once it should begin waiting to execute.</p>"},{"location":"onb_overview/enums/locktype/#sequence","title":"Sequence","text":"<p>Instead of ending when the animation ends, the CardAction will end when all  of its Steps have completed. </p> <pre><code>local action = Battle.CardAction.new(player, \"PLAYER_IDLE\")\naction:set_lockout(make_sequence_lockout())\n</code></pre> <p>You should add Steps afterwards. </p> <pre><code>local step = Battle.Step.new()\nstep.update_func = function(self)\n    self:complete_step()\nend\n\naction:add_step(step)\n</code></pre> <p>The above Step will complete itself on its first update. In this example, because  it's the only Step, the CardAction will then end. If another Step had been added,  that Step would begin updating on the next frame.</p> <p>Action Immediately Ends</p> <p>If you set a Sequence lockout but didn't add any Steps, the CardAction  will end immediately. This is a common mistake when setting up Sequence  lockout actions.</p>"},{"location":"onb_overview/enums/playback/","title":"Playback","text":"<p><code>Playback</code> enum values describe how an Animation should play. </p> <p>It has the following indexes:</p> <ul> <li>Once</li> <li>Loop</li> <li>Bounce</li> <li>Reverse</li> </ul> <p>The default for an Animation is <code>Playback.Once</code>. </p>"},{"location":"onb_overview/enums/playback/#usage","title":"Usage","text":"<p>You can set an Animation's Playback type using <code>Animation.set_playback</code>.</p> <pre><code>local artifact = Battle.Artifact.new()\nlocal anim = artifact:get_animation()\nanim:set_playback(Playback.Loop)\n</code></pre> <p>Calling <code>Animation.set_state</code> will revert any Playback setting back to <code>Playback.Once</code>. If you want to set state and set Playback, be sure to call <code>Animation.set_state</code> before  <code>Animation.set_playback</code>.</p>"},{"location":"onb_overview/enums/playback/#once","title":"Once","text":"<p>The default Playback for an Animation is <code>Playback.Once</code>. With this, an Animation  will play once and then stop.</p> <p>Completion callbacks will run on the game frame that the animation's last keyframe  finishes its duration.</p>"},{"location":"onb_overview/enums/playback/#loop","title":"Loop","text":"<p><code>Playback.Loop</code> will cause an Animation to restart once it reaches its end.</p> <p>Completion callbacks run at a similar time to <code>Playback.Once</code>, but will play again  at the end of each loop. <code>on_frame</code> callbacks will also run again each loop, unless  <code>Animation.on_frame</code> was called with <code>true</code> as the last parameter.</p> <p>Repeated Callbacks</p> <p>While looping, completion callbacks may run an additional time one game frame after  it runs. <code>on_frame</code> callbacks may also run again all at once when the loop happens.</p> <p>Extra Callbacks</p> <p>While looping, an <code>on_frame</code> callback set for the keyframe number that is one higher  than the Animation's final keyframe may run when the loop happens.</p>"},{"location":"onb_overview/enums/playback/#bounce","title":"Bounce","text":"<p><code>Playback.Bounce</code> will cause an Animation to play until its end, then start playing in  reverse.</p> <p>No Bounce</p> <p><code>Playback.Bounce</code> may not function properly in v2.0.</p>"},{"location":"onb_overview/enums/playback/#reverse","title":"Reverse","text":"<p><code>Playback.Reverse</code> will cause an Animation to start on its last frame and play until  it reaches the first frame, and then stop.</p> <p>When using this Playback, <code>on_frame</code> callbacks will not play in reverse. In other words,  the first frame to play will still call the <code>on_frame</code> callbacks for frame 1. The Animation  still proceeds from frame 1 to frame 2, but frame 1 is the last animation frame, and frame 2  is the second to last animation frame, and so on.</p> <p>Completion callbacks will run on the game frame that the animation's last keyframe  finishes its duration.</p>"},{"location":"onb_overview/enums/rank/","title":"Rank","text":"<p>The Rank enum is used when creating a Character. These mostly cover the  \"versions\" you see in the official games:</p> <ul> <li>V1</li> <li>V2</li> <li>V3</li> <li>SP</li> <li>EX</li> <li>Rare1</li> <li>Rare2</li> <li>NM</li> </ul> <p>NM is an original Rank, which stands for \"Nightmare\". Future engine versions  will add more Ranks.</p> <p>Despite \"EX\" having a higher number than \"SP\", remember that SP is a higher  rank in the official games.</p>"},{"location":"onb_overview/enums/rank/#usage","title":"Usage","text":"<p>Rank does nothing on its own, but can be read from the <code>package_init</code> of a  Character to branch logic, which can be helpful for setting different stats,  palettes, behavior, etc.</p> <pre><code>function package_init(character)\n    local rank = character:get_rank()\n\n    --[[\n        Adds a \"damage\" index on `character`, which this code will \n        read later when creating HitProps.\n    ]] \n    if rank == Rank.V1 then \n        character:set_health(40)\n        character.damage = 10\n    elseif rank == Rank.V2 then \n        character:set_health(60)\n        character.damage = 20\n    else\n        print(\"Unhandled Rank: \"..rank)\n        character:set_health(1)\n        character.damage = 10\n    end\nend\n</code></pre> <p>Make sure your Character has stats set for any Rank. The above code does  it with an <code>else</code> as a catch-all, but you can also set stats earlier in the  code and then change them with each Rank.</p> <p>If you don't set health, the Character may not appear in battle.</p> <p>I will also reiterate that the <code>damage</code> index in the above code is not an  official convention or supported index that does anything on its own. If  you add one, you would need to read it later when you write other logic.</p>"},{"location":"onb_overview/enums/shadow/","title":"Shadow","text":"<p>Entities can have a shadow appear under them. Often this is done by having  the shadow be part of the spritesheet, but ONB also supports setting a different  one using <code>Entity.set_shadow</code>, which will stay on the ground when you change the  Entity's elevation.</p> <p>Using the <code>Shadow</code> enum, you can access shadow textures that are included in the  engine, or remove one you have set. This includes the following:</p> <ul> <li>None</li> <li>Small</li> <li>Big</li> </ul> <p>By default, <code>Shadow.None</code> is used.</p>"},{"location":"onb_overview/enums/shadow/#usage","title":"Usage","text":"<p>Set a shadow by giving a Shadow value to <code>Entity.set_shadow</code>, and then call  <code>Entity.show_shadow</code> with a value of <code>true</code> to see it.</p> <pre><code>local artifact = Battle.Artifact.new()\nartifact:set_shadow(Shadow.Small)\nartifact:show_shadow(true)\n</code></pre>"},{"location":"onb_overview/enums/team/","title":"Team","text":"<p>All Entities have a Team, which decides what they can be attacked by  and what they can attack.</p> <p>There are three indexes:</p> <ul> <li>Red</li> <li>Blue</li> <li>Other</li> </ul>"},{"location":"onb_overview/enums/team/#usage","title":"Usage","text":"<p>You will usually pass a Team in when creating an Entity.</p> <pre><code>local spell = Battle.Spell.new(Team.Other)\n</code></pre> <p>It's uncommon to refer to a direct value. Similar to Direction, you  will usually want to use a Team relative to another Entity's Team. For  example:</p> <pre><code>function create_spell(player)\n    local spell = Battle.Spell.new(player:get_team())\n    spell:set_facing(player:get_facing())\nend\n</code></pre> <p>This function will create a Spell that can hit <code>player</code>'s enemies (Characters  and Obstacles not on the same Team).</p> <p>Another common use is to find Entities which are not on a certain Team.</p> <pre><code>local field = player:get_field()\nlocal team = player:get_team()\n\nlocal all_enemies = field:find_characters(function(ent)\n    return ent:get_team() ~= team\nend)\n</code></pre>"},{"location":"onb_overview/enums/tilestate/","title":"TileState","text":"<p><code>TileState</code> describes the state a Tile is in, and also affects its behavior  and other Entities' and attacks' interactions with it.</p> <p>The following TileStates are available:</p> <ul> <li>Broken</li> <li>Cracked</li> <li>DirectionDown</li> <li>DirectionLeft</li> <li>DirectionRight</li> <li>DirectionUp</li> <li>Empty</li> <li>Grass</li> <li>Hidden</li> <li>Holy</li> <li>Ice</li> <li>Lava</li> <li>Normal</li> <li>Poison</li> <li>Volcano</li> </ul> <p>The default TileState is <code>TileState.Normal</code>.</p>"},{"location":"onb_overview/enums/tilestate/#usage","title":"Usage","text":"<p>You can change a Tile's state using <code>Tile.set_state</code>. </p> <p><pre><code>local tile = player:get_current_tile()\ntile:set_state(TileState.Ice)\n</code></pre> You can inspect the current state of a Tile using <code>Tile.get_state</code>.</p> <pre><code>print(player:get_current_tile():get_state() == TileState.Normal)\n</code></pre> <p>Edge Tiles cannot have their state set. </p>"},{"location":"onb_overview/enums/tilestate/#broken","title":"Broken","text":"<p>A Tile with the <code>TileState.Broken</code> state cannot be stepped on by Players  who do not have AirShoes. </p> <p>A Broken Tile will revert to <code>TileState.Normal</code> after 10 seconds (600 frames).  Setting <code>TileState.Broken</code> on a Tile that is already broken will refresh its timer.</p> <p>Trying to set <code>TileState.Broken</code> on a Tile which has Obstacles or Characters on it  will fail. </p>"},{"location":"onb_overview/enums/tilestate/#cracked","title":"Cracked","text":"<p>A Tile with the <code>TileState.Cracked</code> state will change to <code>TileState.Broken</code> when  a Character which does not have FloatShoes steps off it.</p> <p>AirShoes</p> <p>In v2.0, a Character which has AirShoes will also prevent the Tile from breaking. This will not be the case in future versions.</p> <p>Missing Info</p> <p>Obstacles may be affected as well. This notice will be removed once I have confirmed.</p> <p>A Tile that is in the <code>TileState.Broken</code> or <code>TileState.Empty</code> states cannot be set to  Cracked.</p>"},{"location":"onb_overview/enums/tilestate/#directions","title":"Directions","text":"<p>Tiles with <code>TileState.DirectionDown</code>, <code>TileState.DirectionLeft</code>, <code>TileState.DirectionRight</code>, or <code>TileState.DirectionUp</code> states will move an Obstacle or Character in that direction when it  steps onto it. Having FloatShoes will exempt the Entity from this movement.</p> <p>AirShoes</p> <p>In v2.0, having AirShoes will also prevent the movement. This will not be the case in  future versions.</p> <p>The movement is an Involuntary MoveEvent that completes in 3 frames.</p> <p>These types of Tiles might also be called \"conveyor panels\" by some BN players. They're created  by ComingRoad and GoingRoad in BN6.</p>"},{"location":"onb_overview/enums/tilestate/#empty","title":"Empty","text":"<p>Tiles with <code>TileState.Empty</code> are simliar to <code>TileState.Broken</code> in effect, with the exception  that it does not revert to <code>TileState.Normal</code>. </p> <p>These types of Tiles might also be called \"perma-holes\" by some BN players, because they are always a hole. Traditionally, these Tiles cannot be taken by the other Team, and they can never  be set to a different TileState. This is not the case in ONB. If you want to make your mods  feel more like BN, you should often check for this TileState.</p>"},{"location":"onb_overview/enums/tilestate/#grass","title":"Grass","text":"<p>Tiles with <code>TileState.Grass</code> will add damage after a Fire element attack hits an Entity on that  Tile. Then, the TileState will revert to <code>TileState.Normal</code>.</p> <p>Grass Burn</p> <p>In the official games, a Fire element attack will remove Grass even if no Entity is hit.  This is not the case in v2.0, but will be in future versions.</p> <p>Grass Heal</p> <p>In the official games, WoodBody Characters heal slowly over time while standing on a Grass  Tile. This does not happen in v2.0, but will in future versions.</p>"},{"location":"onb_overview/enums/tilestate/#hidden","title":"Hidden","text":"<p>A Tile with <code>TileState.Hidden</code> will not be drawn. You can see this in the official games during  the fights with Duo, Nebula Gray, and Falzar.</p> <p>Hidden Tiles are not walkable. They cannot change Team, and a Tile with <code>TileState.Hidden</code> cannot  change states to any other state. They will be Hidden forever. They also cannot be highlighted.</p>"},{"location":"onb_overview/enums/tilestate/#holy","title":"Holy","text":"<p>Entities standing on Tiles with the <code>TileState.Holy</code> state will take reduced damage from attacks.</p> <p>Damage is halved and rounded down after all DefenseRules have run their <code>can_block_func</code>.</p> <p>Damage Rounding and Impact</p> <p>In v2.0, the round down means that 1 damage attacks will become 0 damage, which is  not BN behavior. This will be changed in a later version.</p> <p>Typically, attacks that lack the <code>Hit.Impact</code> flag will not have their damage reduced by  Holy Tiles. In v2.0, they will still have their damage reduced.</p> <p>'Holy Aura' Strategy</p> <p>A well-known strategy in the official games involves using a LifeAura combined with a  Holy panel to require a very high damage value to destroy the Aura. This behavior will  typically not be seen in ONB mods at this time because of the timing of damage reduction from Holy Tiles.</p>"},{"location":"onb_overview/enums/tilestate/#ice","title":"Ice","text":"<p>Tiles with the <code>TileState.Ice</code> state will move any Entity when they step onto it in the same  direction that they were moving in. For example, if the Entity moved to the right to step  onto it, they would continue sliding right. The Entity will continue to slide until they  land on a Tile with a different state, or the next Tile is inaccessible according to their  <code>can_move_to_func</code>.</p> <p>Entities that have FloatShoes or are AquaBody will not slide.</p> <p>The slide is a MoveEvent that takes 4 frames to complete.</p> <p>If an Entity is hit by an Aqua attack while on ice, it will be frozen. </p> <p>Elec Damage</p> <p>In v2.0, Ice Tiles grant bonus damage to Elec attacks in the same way Grass does to  Fire. This is behavior from games before BN6, and will be removed in future versions.</p>"},{"location":"onb_overview/enums/tilestate/#lava","title":"Lava","text":"<p>A Character or Obstacle that stands on a Tile with the <code>TileState.Lava</code> state will be damaged,  and then the Tile will revert to <code>TileState.Normal</code>. </p> <p>If the Entity has FloatShoes, the Lava will not attack it. Because it does not attack, it also  does not revert.</p> <p>FireBody</p> <p>In the official games, being FireBody would also avoid Lava attacks. This is not the  case in v2.0, but will be in the future.</p> <p>The attack does 50 Null damage with the Hit.Flash flag.</p> <p>Fire Lava</p> <p>In the official games, Lava tends to do Fire damage. This is not the case in v2.0,  but may change in the future.</p>"},{"location":"onb_overview/enums/tilestate/#normal","title":"Normal","text":"<p>Tiles in the <code>TileState.Normal</code> TileState have no special effects.</p>"},{"location":"onb_overview/enums/tilestate/#poison","title":"Poison","text":"<p>Tiles in the <code>TileState.Poison</code> TileState will damage Characters standing on them. This  uses a global counter, which counts for all Tiles even while in different TileStates.  Every 7 frames on this counter, damage will be dealt.</p> <p>An Entity with Floatshoes will not be attacked.</p> <p>The attack does 1 Null damage with the Hit.Pierce flag.</p> <p>Damage Timing</p> <p>The damage timing in v2.0 does not match the official games. This will be made more  accurate in future versions.</p>"},{"location":"onb_overview/enums/tilestate/#volcano","title":"Volcano","text":"<p>Tiles in the <code>TileState.Volcano</code> TileState will attack once in a while on a global  timer.</p> <p>Every 2 seconds (120f), the Volcano will change animation states to flicker just before  erupting. It will flicker for about 33f before attacking, at which point the 2 second timer restarts and the attack is spawned.</p> <p>The attack lasts as long as the erupted lava is visible, which is approximately 38f. It  does 50 Null damage, with the Hit.Impact and Hit.Flinch flags.</p> <p>Volcano Timing</p> <p>In v2.0, the timing may be different from the original games. It also uses the same  time for each Team's Volcano Tiles, which will change in future versions. </p>"},{"location":"onb_overview/enums/tilestate/#usage-tips","title":"Usage Tips","text":""},{"location":"onb_overview/enums/tilestate/#walkable-tiles","title":"Walkable Tiles","text":"<p>It's common to check for certain states when creating attacks that travel along  the ground and would make sense to be stopped by holes, such as the Shockwave  or WaveArm chips from the official games, or when creating enemies or Obstacles  that should avoid holes. </p> <p>Because there are serveral other similar states, you should instead check <code>Tile.is_walkable()</code>. It will return <code>false</code> if the Tile's TileState is Hidden, Broken, or Empty, or if  the Tile is an edge Tile.</p>"},{"location":"onb_overview/enums/tilestate/#breaking-tiles","title":"Breaking Tiles","text":"<p>Common behavior of attacks that crack Tiles is to break a Tile if it's already cracked.  This isn't always the case, but it does happen sometimes. For example, the GutsMan  chip in BN3 will crack panels as shockwaves pass over them, but it will break panels  that are already cracked. The ElecCross Beast chip charge in BN6 will crack panels, but  will not break cracked panels.</p> <p>If you want to break cracked panels, check if the Tile is already cracked, and then  break it if so.</p> <p>ONB will reset the broken Tile timer if you set the state again, which is unlike effects  seen in the games. Remember to check if the Tile was already broken before trying, so you  don't reset the timer.</p>"},{"location":"onb_overview/enums/tilestate/#making-holes","title":"Making Holes","text":"<p>Some attacks and effects might skip cracking a Tile and go straight to breaking it.  These effects often crack a Tile if it couldn't break, for example if something was  standing on the Tile. To cover for this case, you can set the state to Cracked, and then  on the next line set it to Broken.</p>"},{"location":"updates/v2.1/","title":"v2.1","text":"<p>v2.1 pulls some fixes, changes, and features from ahead in the repo's history, and even from  Jamesking's work on the upcoming v2.5, with extra help from James in devising and revising  the new systems in play that weren't in v2.5 yet.</p> <p>This is a non-breaking update. No mods should be broken, but some behavior has been affected, and new behavior is now possible that you may want to implement.  Read the changelog, then see Recommended Mod Upgrades.</p> <p>If any mods have broken, ping me (Alrysc) on Discord and I'll see about patching. </p>"},{"location":"updates/v2.1/#changelog","title":"Changelog","text":"<ul> <li>Folder and pack can be sorted using the Pause button (default Enter) </li> <li>Folders can be copied with CTRL+C while editing</li> <li>Sea, Metal, and Sand TileStates added<ul> <li>Sea boosts damage of Aqua cards used on them, doubles Elec damage taken while on one, and roots Entities that step on them</li> <li>Metal cannot be cracked or broken</li> <li>Sand roots Entities that step on them and doubles Wind damage taken while on one</li> </ul> </li> <li>Charge times are recalculated even without flinching<ul> <li>Player.charged_time_table_func and PlayerForm.charged_time_table_func can be used reliably as a result</li> </ul> </li> <li>Wood element Entities will heal over time while standing on a Grass Tile</li> <li>Fire element Entities will not take damage from Lava</li> <li>Elec damage is no longer doubled on Ice</li> <li>Grass Tiles are now removed by Fire, even if damage was not dealt to any Entities</li> <li>Holy Panel damage rounds up</li> <li>Movement no longer acts as if endlag is 1 frame when it's 0 frames</li> <li>Drag lasts the correct amount of time now</li> <li>Pressing inputs during Stun and Freeze will cause them to end more quickly</li> <li>Status interactions with each other are overall more accurate<ul> <li>Some may cancel others, and will do so correctly</li> </ul> </li> <li>Form changing will cancel various statuses</li> <li>Flinching can no longer be cancelled by using a card</li> <li>TFC cannot be performed until 10 frames into time freeze</li> <li>Charge is no longer used up when performing TFC</li> <li>Anger/FullSync now only consumed by boostable cards</li> <li>Time freeze actions show damage and modifiers</li> <li>Health turns red at low HP</li> <li>Mugshots no longer bounce</li> <li>Freedom battles always send data to the server, and turns can no longer end while the last enemy is dying</li> <li>Freedom battles read input during time freeze</li> <li>Card long descriptions are prioritized over short descriptions in battle</li> <li>Time Freeze actions can be marked uncounterable</li> <li>Time Freeze actions now call action_end_func</li> <li>Field.find_nearest_characters returns an ordered table</li> <li>Battle.AlertSymbol.new is available</li> <li>Access to Left_Shoulder and Right_Shoulder inputs</li> <li>Hit.NoCounter hitflag, prevents attack from countering</li> <li>All Entities can use battle_start_func and battle_end_func</li> <li>Access to Character.can_attack</li> <li>Access to Entity.set_counter_frame_range</li> <li>Access to Entity. is_stunned, is_frozen, is_rooted, and is_blind</li> </ul>"},{"location":"updates/v2.1/#recommended-mod-upgrades","title":"Recommended Mod Upgrades","text":"<p>No mods should be broken by this update, but modders now have an opportunity to  add more to their mods. Some of these recommendations are to warn about behavioral  changes, but mod updates are not necessarily required.</p> <p>Other recommendations are for new things that can be added to mods to either make  certain logic safer, or improve mods with new functionality.</p>"},{"location":"updates/v2.1/#new-things-you-may-want-to-add","title":"New Things You May Want To Add","text":""},{"location":"updates/v2.1/#custom-charge-times","title":"Custom Charge Times","text":"<p>v2.1 fixes charge time calculation, which means Player mods are free to have unique  charge times. If you do not add one, the mod will continue to use the default  provided by the engine.</p> <p>This is done using the <code>charged_time_table_func</code>, both on Players and on PlayerForms. The <code>charged_time_table_func</code> is passed a number <code>level</code> representing the current  Charge level, and expects a <code>frametime</code> to be returned. The <code>level</code> will be a number  from 1 to 5, inclusive. Be sure to cover all cases.</p> <pre><code>local form = player:create_form()\nplayer.charged_time_func = function(level)\n    if level == 1 then\n        return frames(50)\n    end\n\n    if level == 2 then \n        return frames(40)\n    end\n\n    -- etc.\nend\n\nform.charged_time_func = function(level)\n    if level == 1 then\n        return frames(100)\n    end\n\n    if level == 2 then \n        return frames(90)\n    end\n\n    -- etc.\nend\n</code></pre> <p>Some tips for determining charge times:</p> <ul> <li>The default charge time is 90 frames at level 1, 80 at level 2, 70 at level 3, 60 at level 4, and 50 and level 5.</li> <li>If your charge time can be based on a formula, use one<ul> <li>For exmaple, the ONB default can be replicated in one line with <code>return frames(100 - 10 * level)</code></li> </ul> </li> <li>The official games often do not use linear charge times. For example, HeatCross in BN6 has times   60, 50, 40, 35, 30, for levels 1-5. Notice how having more levels past 3 has lesser effect.</li> <li>The returned time is applied after holding the Shoot button for 10 frames (when the graphic appears)<ul> <li>This means returning <code>frames(10)</code> actually means you need to hold B for 20 frames total to be fully charged</li> <li>Sources on charge times for the official games may or may not count the 10 frames before holding Shoot.  Take this into consideration when taking data from other sources. </li> </ul> </li> </ul> <p>If your mod changes the <code>Player.charged_attack_func</code>, consider also changing the <code>Player.charged_time_func</code>  to go with it. If you do change the <code>charged_time_func</code>, remember that it will not be run when set.  To recalculate time with the new function, you can set your charge level, for example by doing  <code>player:set_charge_level(player:get_charge_level())</code>.</p>"},{"location":"updates/v2.1/#access-to-shoulder-buttons","title":"Access to Shoulder Buttons","text":"<p>v2.1 adds the <code>right_shoulder</code> and <code>left_shoulder</code> inputs to be read by mods. You  can perform some logic based on these, and you might have some mods that were getting  especially crowded using only the Special button. </p> <p>Note that the shoulders are typically used to open the Custom screen. Your logic may  be performed at the same time the Custom screen opens if the Custom Gauge is full.</p>"},{"location":"updates/v2.1/#safer-card_action_event","title":"Safer card_action_event","text":"<p>In v2.0, if you used <code>Character.card_action_event</code>, you had no way of knowing whether  or not the Card would be added or would execute, or even could execute. You might  have queued the action multiple times, causing it to happen more times than intended.  With v2.1, this can be made somewhat safer because we can check whether or not the  Character is available to perform an action using <code>Character.can_attack</code>.</p> <p><code>Character.can_attack</code> returns false if the Character already has a CardAction, or  is flinching, stunned, frozen, or in the middle of Drag. By combining this with a  check for <code>Entity.is_moving</code>, you can more consistently avoid queueing the action  multiple times, since the frame after you queue the action <code>Character.can_attack</code> will  return false until the action has either finished or been discarded.</p> <p><pre><code>player.update_func = function(self)\n    local can_act = player:can_attack() and not player:is_moving()\n    if can_act and player:input_has(Input.Pressed.Left_Shoulder) then \n        player:card_action_event(make_my_action(), ActionOrder.Voluntary)\n    end \nend\n</code></pre> If the above code did not make those checks, a player could repeatedly press the left shoulder button and queue the action multiple times, or could even press it while stunned and have the  action happen immediately when stun ends. Guarding the <code>card_action_event</code> with <code>can_attack</code>  and <code>is_moving</code> prevents this.</p>"},{"location":"updates/v2.1/#hitno_counter","title":"Hit.no_counter","text":"<p>You can now make attacks that can never counterhit. In v2.0, this was able to be done using  the raw value of the enum (2048), but now the enum value is accessible using <code>Hit.no_counter</code>.  If you used <code>2048</code>, consider updating to use the enum value, which is guaranteed to always  work in the future.</p>"},{"location":"updates/v2.1/#battle_end_func-and-battle_start_func","title":"<code>battle_end_func</code> and <code>battle_start_func</code>","text":"<p>All Entities can use the <code>battle_start_func</code> and <code>battle_end_func</code> now. This is most likely  to come up where modders have wanted to remove Spells from the Field when battle ends, or  prevent enemies from spawning new attacks, which is common for official game behavior. </p>"},{"location":"updates/v2.1/#timefreeze-action_end_func","title":"TimeFreeze action_end_func","text":"<p>In v2.0, time freeze CardActions did not call their <code>action_end_func</code>. This has been fixed.  If your mods had certain cleanup that must be performed at the end, this could be a good  place to move things.</p>"},{"location":"updates/v2.1/#timefreeze-uncounterable","title":"TimeFreeze Uncounterable","text":"<p>Time freeze actions can now be marked as uncounterable, using <code>CardMeta.counterable = false</code>.</p> <p>Try not to abuse it too much. This is typically used for time freezes that happen as a  result of some condition, like Guardian being hit, or an elemental attack appearing  on the field and triggering ElementTrap, or a boss changing phases. Mods that have these  sorts of actions likely already wanted to be uncounterable, and now they can be.</p>"},{"location":"updates/v2.1/#set_counter_frame_range","title":"set_counter_frame_range","text":"<p>Instead of toggling counter on and off, you can now set a range of frames for which an  Entity will be counterable. This is based on the current animation.</p> <p>In the official games, almost every counterable action has counter frames for the first  15 or 16 frames (to be determined). If you wanted your scripted action to be conuterable  for this frame, you can do</p> <p><pre><code>action.execute_func = function(self, actor)\n    -- TODO: This could be (1, 16), or (1, 15), or (2, 16), or (2, 15)\n    actor:set_counter_frame_range(1, 16)\nend\n</code></pre> Note that this is done specifically in the <code>execute_func</code>, which is the first time the  user has entered the action animation.</p>"},{"location":"updates/v2.1/#breaking-metal-tiles","title":"Breaking Metal Tiles","text":"<p>The Metal TileState prevents cracking and breaking a Tile. This means calls like  <code>tile:set_state(TileState.Cracked)</code> or <code>tile:set_state(TileState.Broken)</code> will do  nothing if the current state is <code>TileState.Metal</code>. </p> <p>Some effects intend to overwrite Tiles, which is different flavor from breaking  them. For example, in BN3, MetalMan, GutsMan, and BassGS don't affect Metal Tiles,  but Geddon1 and Geddon2 do. Geddon1 cracks all Tiles, including Metal Tiles; Geddon2  turns all Tiles into holes, but Metal Tiles are instead cracked. If you intend for  this sort of behavior, you can change the Tile to <code>TileState.Normal</code> and then crack  and break it, or only crack if it was Metal beforehand. </p>"},{"location":"updates/v2.1/#engine-alert-symbol","title":"Engine Alert Symbol","text":"<p>v2.1 adds access to <code>Battle.AlertSymbol.new()</code>, which creates an alert symbol, the  double exclamation point icon that appears when taking weakness damage or performing  TFC. If your mods have created one for themselves, you may consider using this instead. </p>"},{"location":"updates/v2.1/#behavior-changes-be-aware","title":"Behavior Changes (Be Aware)","text":""},{"location":"updates/v2.1/#using-hitdrag","title":"Using Hit.Drag","text":"<p>v2.1 makes Drag interactions much closer to source material. This reveals some  possible mistakes modders have made with Drag attacks. Below are some nuances that  may have been unknown before, and that modders should reconsider for attacks that  inflict Drag: 1. Drag makes the hit Entity totally unable to act for over 20 frames after movement stops 2. Drag and Freeze are fully incompatible. If any attacks have Hit.Freeze and Hit.Drag, they     will never cause Freeze. If you have done this, consider removing Hit.Freeze.</p>"},{"location":"updates/v2.1/#movement-endlag","title":"Movement Endlag","text":"<p>In v2.0, all movement had at least one frame of endlag. Endlag of <code>frames(0)</code> and  <code>frames(1)</code> were identical. With v2.1, this is no longer the case. </p> <p>This will affect any MoveEvent that was using <code>frames(0)</code> for its endlag, which  is most sliding Spells. There is no actual fix necessary, because modders likely  intended their 0 frame endlag to really be 0 frames, but modders should be aware  that projectiles may appear to move slightly more quickly. </p> <p>The actual effect on speed has to do with how long it takes to reach mutiple Tiles  away. Things that moved two Tiles will reach the second Tile 1 frame faster now that  the endlag isn't there. Moving three Tiles will reach the third Tile 2 frames faster,  etc.</p> <p>If you intended to have an extra frame on each Tile, you can use <code>frames(1)</code> as the  endlag to replicate how <code>frames(0)</code> looked and moved in v2.0.</p>"},{"location":"updates/v2.1/#spawning-hit-effects","title":"Spawning Hit Effects","text":"<p>Some Spells will spawn hit effects in their <code>collision_func</code> or <code>attack_func</code>. Some  mods spawn the effect on the Spell's Tile; others spawn on the hit Entity's Tile.  Spawning on the Spell's Tile has always been less correct, because the Spell is moving  and may have already reached the next Tile before the effect was spawned. This could  mean the effect spawns behind the hit Entity, for example. </p> <p>Because of the movement endlag change, this may be more noticeable (but it could have happened in v2.0, too). If a mod spawned the hit effect on the target's Tile, no change is necessary. If they  spawned on the Spell's Tile, consider changing this.</p>"},{"location":"updates/v2.1/#deleting-moving-attacks","title":"Deleting Moving Attacks","text":"<p>Some Spells will delete themselves in their <code>collision_func</code>. If the Spell is moving,  it may have changed Tiles before the <code>collision_func</code> ran. This means it could have  been drawn on the next Tile even though it hit on the previous Tile, because Entities  still draw on the frame <code>Entity:delete()</code> is called.</p> <p>This draw error could happen in v2.0, but is likely more noticeable now because of the  movement endlag change.</p> <p>If you call <code>erase</code> in your <code>delete_func</code>, or if you called <code>erase</code> intead of <code>delete</code>,  or if you call <code>hide</code> when you called <code>delete</code>, or if you call <code>hide</code> in the <code>delete_func</code>,  this will never happen to your Spells. If you do not do any of these, consider adding one. My recommendation is to call <code>Entity.hide</code> in your <code>delete_func</code>.</p>"},{"location":"updates/v2.1/#find_nearest_characters-fix","title":"find_nearest_characters Fix","text":"<p>In v2.0, <code>Field.find_nearest_characters</code> did not actually return an ordered list, so the  first item was not necessarily the nearest Character. This is fixed by v2.1. </p> <p>If you have used <code>find_nearest_characters</code> and intended to target the nearest Character,  no change is needed; you may notice that you are now actually getting the nearest Character.</p> <p>If you have avoided <code>find_nearest_characters</code> to use your own solution, or because it did  not work as expected, consider updating to now use it.</p>"},{"location":"updates/v2.1/#fire-and-grass","title":"Fire and Grass","text":"<p>Fire element attacks now remove Grass even if they did not hit an Entity. Mods that  handled this interaction on their own in v2.0 can now remove their implementation, as the engine will handle it.</p>"},{"location":"updates/v2.1/#grass-lava-effects","title":"Grass, Lava Effects","text":"<p>Grass now heals Wood Entities. If your Player mods have implemented a sort of grass heal,  you can now remove this and rely on the engine's. If you do not, your healing effect will stack with the engine's.</p> <p>Fire Entities are no longer harmed by Lava Tiles. If you have added FloatShoes to your  Player mods only to recreate this interaction in v2.0, you can now remove the FloatShoes  and remain immune to Lava.</p>"},{"location":"updates/v2.1/#new-tilestates","title":"New TileStates","text":"<p>Because of the new TileStates (Sea, Metal, Sand), mods that attempted to change Tiles  on the Field to any TileState (e.g. a mod that picks random TileStates each time)  may want to be updated to support the additions.</p> <p>Servers that send data for encounters tend to use hardcoded values based on the TileState  enum (ezencounters does this). Any use of <code>TileState.Hidden</code> on your server encounters  may now appear as Sea Tiles. See the repo for new values to adjust to.</p>"}]}